<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Python进阶函数和功能</title>
      <link href="/2018/03/19/python-adv/"/>
      <content type="html"><![CDATA[<p>最开始接触 Python 是因为女票选了 Python 的课，为了秀一下“男友力”，我花了2个钟头读完 Python 3.6 的文档，做了她一学期的私人答疑。嗯，一点点秀。</p><p>在使用Python的过程中，其 <strong>解释性的语言</strong>，<strong>众多彩蛋语法糖</strong>，<strong>优雅的数据结构</strong>，<strong>优秀的包管理工具</strong>，<strong>大量的例程和学习资料</strong>，让我一直把 Python 作为我的 <strong>首要编程语言</strong>。</p><p>本文是我在研究 Python 语言本身 <strong>高级特性</strong> 时所做的笔记，会慢慢更新。<br>如果你恰好也和我一样喜欢 Python。希望本文能对你的学习有所帮助！</p><blockquote><p><strong>下面是快捷方式</strong>（点击直达）<br><a href="/2018/03/19/python-adv/#map"><code>map()</code></a>、<a href="/2018/03/19/python-adv/#reduce"><code>reduce()</code></a>、<a href="/2018/03/19/python-adv/#filter"><code>filter()</code></a>、<a href="/2018/03/19/python-adv/#sorted"><code>sorted()</code></a>、<a href="/2018/03/19/python-adv/#Python中返回函数"><code>返回函数</code></a>、<a href="/2018/03/19/python-adv/#闭包"><code>闭包</code></a></p></blockquote><a id="more"></a><h2 id="map"><a href="#map" class="headerlink" title="map()"></a><strong>map()</strong></h2><p>map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。</p><p>例如，对于list [1, 2, 3, 4, 5, 6, 7, 8, 9]</p><p>如果希望把list的每个元素都作平方，就可以用map()函数：</p><p><img src="http://img.mukewang.com/54c8a7e40001327303410245.png" alt="file-list"></p><p>因此，我们只需要传入函数f(x)=x*x，就可以利用map()函数完成这个计算：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"><span class="keyword">print</span> map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p><p><strong>输出结果：</strong>[1, 4, 9, 10, 25, 36, 49, 64, 81]</p><p><code>注意：map()函数不改变原有的 list，而是返回一个新的 list。</code></p><p>利用map()函数，可以把一个 list 转换为另一个 list，只需要传入转换函数。</p><p>由于list包含的元素可以是任何类型，因此，map() 不仅仅可以处理只包含数值的 list，事实上它可以处理包含任意类型的 list，只要传入的函数f可以处理这种数据类型。</p><hr><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a><strong>reduce()</strong></h2><p>reduce()函数也是Python内置的一个高阶函数。reduce()函数接收的参数和 map()类似，<code>一个函数 f</code>，<code>一个list</code>，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。</p><p>例如，编写一个f函数，接收x和y，返回x和y的和：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p><p>调用 reduce(f, [1, 3, 5, 7, 9])时，reduce函数将做如下计算：</p><blockquote><ol><li>先计算头两个元素：f(1, 3)，结果为4； </li><li>再把结果和第3个元素计算：f(4, 5)，结果为9； </li><li>再把结果和第4个元素计算：f(9,7)，结果为16； </li><li>再把结果和第5个元素计算：f(16, 9)，结果为25；</li><li>由于没有更多的元素了，计算结束，返回结果25。</li></ol></blockquote><p>上述计算实际上是对 list的所有元素求和。虽然Python内置了求和函数sum()，但是，利用reduce()求和也很简单。</p><p>reduce()还可以接收第3个可选参数，作为计算的初始值。如果把初始值设为100，计算：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], <span class="number">100</span>)</span><br></pre></td></tr></table></figure></p><p>结果将变为<code>125</code>，因为第一轮计算是：</p><p>计算初始值和第一个元素：<code>f(100, 1)</code>，结果为<code>101</code>。</p><hr><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a><strong>filter()</strong></h2><p>filter()函数是 Python 内置的另一个有用的高阶函数，filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，<strong>filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。</strong></p><p>例如，要从一个list [1, 4, 6, 7, 9, 12, 17]中删除偶数，保留奇数，首先，要编写一个判断奇数的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>然后，利用filter()过滤掉偶数：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(is_odd, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">17</span>])</span><br></pre></td></tr></table></figure></p><p><strong>结果:</strong> [1, 7, 9, 17]</p><p>利用filter()，可以完成很多有用的功能，例如，删除 None 或者空字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_not_empty</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> len(s.strip()) &gt; <span class="number">0</span></span><br><span class="line">filter(is_not_empty, [<span class="string">'test'</span>, <span class="keyword">None</span>, <span class="string">''</span>, <span class="string">'str'</span>, <span class="string">'  '</span>, <span class="string">'END'</span>])</span><br></pre></td></tr></table></figure></p><p><strong>结果：</strong>[‘test’, ‘str’, ‘END’]</p><p><code>注意: s.strip(rm) 删除 s 字符串中开头、结尾处的 rm 序列的字符。</code></p><p>当rm为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)，如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> = <span class="string">'     123'</span></span><br><span class="line"><span class="selector-tag">a</span>.strip()</span><br></pre></td></tr></table></figure></p><p><strong>结果：</strong> ‘123’<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a='<span class="symbol">\t</span><span class="symbol">\t</span>123<span class="symbol">\r</span><span class="symbol">\n</span>'</span><br><span class="line">a.strip()</span><br></pre></td></tr></table></figure></p><p><strong>结果：</strong>‘123’</p><hr><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a><strong>sorted()</strong></h2><p>Python内置的 sorted()函数可对list进行排序：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">21</span>])</span><br><span class="line"></span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">21</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure></p><p>但 sorted()也是一个高阶函数，它可以接收一个比较函数来实现自定义排序，比较函数的定义是，传入两个待比较的元素 x, y，<strong>如果 x 应该排在 y 的前面，返回 -1，如果 x 应该排在 y 的后面，返回 1。如果 x 和 y 相等，返回 0。</strong></p><p>因此，如果我们要实现倒序排序，只需要编写一个reversed_cmp函数：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversed_cmp</span><span class="params">(x, y)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="symbol">y:</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="symbol">y:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>这样，调用 sorted() 并传入 reversed_cmp 就可以实现倒序排序：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">21</span>], reversed_cmp)</span><br><span class="line">[<span class="number">36</span>, <span class="number">21</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><p>sorted()也可以对字符串进行排序，字符串默认按照ASCII大小来比较：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>])</span><br><span class="line">[<span class="string">'Credit'</span>, <span class="string">'Zoo'</span>, <span class="string">'about'</span>, <span class="string">'bob'</span>]</span><br></pre></td></tr></table></figure></p><p>‘Zoo’排在’about’之前是因为’Z’的ASCII码比’a’小。</p><hr><h2 id="Python中返回函数"><a href="#Python中返回函数" class="headerlink" title="Python中返回函数"></a><strong>Python中返回函数</strong></h2><p>Python的函数不但可以返回int、str、list、dict等数据类型，还可以返回函数！</p><p>例如，定义一个函数 f()，我们让它返回一个函数 g，可以这样写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'call f()...'</span></span><br><span class="line">    <span class="comment"># 定义函数g:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call g()...'</span></span><br><span class="line">    <span class="comment"># 返回函数g:</span></span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure></p><p>仔细观察上面的函数定义，我们在函数 f 内部又定义了一个函数 g。由于函数 g 也是一个对象，函数名 g 就是指向函数 g 的变量，所以，最外层函数 f 可以返回变量 g，也就是函数 g 本身。</p><p>调用函数 f，我们会得到 f 返回的一个函数：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; x = f()   <span class="comment"># 调用f()</span></span><br><span class="line">call f()...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x   <span class="comment"># 变量x是f()返回的函数：</span></span><br><span class="line">&lt;function g at <span class="number">0x1037bf320</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x()   <span class="comment"># x指向函数，因此可以调用</span></span><br><span class="line">call g()...   <span class="comment"># 调用x()就是执行g()函数定义的代码</span></span><br></pre></td></tr></table></figure></p><p>请注意区分返回函数和返回值：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myabs</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> abs   <span class="comment"># 返回函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myabs2</span><span class="params">(x)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> abs(x)   <span class="comment"># 返回函数调用的结果，返回值是一个数值</span></span><br></pre></td></tr></table></figure></p><p>返回函数可以把一些计算延迟执行。例如，如果定义一个普通的求和函数：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span><span class="params">(lst)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> sum(lst)</span><br></pre></td></tr></table></figure></p><p>调用calc_sum()函数时，将立刻计算并得到结果：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>但是，如果返回一个函数，就可以“延迟计算”：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span><span class="params">(lst)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> sum(lst)</span><br><span class="line">    <span class="keyword">return</span> lazy_sum</span><br><span class="line"><span class="comment"># 调用calc_sum()并没有计算出结果，而是返回函数:</span></span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; f = calc_sum([1, 2, 3, 4])</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; f</span></span><br><span class="line">&lt;function lazy_sum at 0x1037bfaa0&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 对返回的函数进行调用时，才计算出结果:</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; f()</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>由于可以返回函数，我们在后续代码里就可以决定到底要不要调用该函数。</p><p>编写一个函数calc_prod(lst)，它接收一个list，返回一个函数，返回函数可以计算参数的乘积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_prod</span><span class="params">(lst)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方法一：</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prod</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x * y, lst)</span><br><span class="line">    <span class="keyword">return</span> prod</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方法二：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> :reduce(<span class="keyword">lambda</span> x, y: x * y, lst)</span><br><span class="line"></span><br><span class="line">f = calc_prod([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="keyword">print</span> f()</span><br></pre></td></tr></table></figure><hr><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><strong>闭包</strong></h2><p>在函数内部定义的函数和外部定义的函数是一样的，只是他们无法被外部访问：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'g()...'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'f()...'</span></span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure></p><p>将 g 的定义移入函数 f 内部，防止其他代码调用 g：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'f()...'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'g()...'</span></span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure></p><p>但是，考察上一小节定义的 calc_sum 函数：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span><span class="params">(lst)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> sum(lst)</span><br><span class="line">    <span class="keyword">return</span> lazy_sum</span><br></pre></td></tr></table></figure></p><p><code>注意: 发现没法把 lazy_sum 移到 calc_sum 的外部，因为它引用了 calc_sum 的参数 lst。</code></p><p>像这种内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为闭包（Closure）。</p><p>闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。举例如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 希望一次返回3个函数，分别计算1x1,2x2,3x3:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>)<span class="symbol">:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">             <span class="keyword">return</span> i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br></pre></td></tr></table></figure></p><p>你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果全部都是 9（请自己动手验证）。</p><p>原因就是当count()函数返回了3个函数时，这3个函数所引用的<code>变量 i</code> 的值已经变成了3。由于f1、f2、f3并没有被调用，所以，此时他们并未计算 i*i，当 f1 被调用时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f1()</span><br><span class="line">9     # 因为f1现在才计算i*i，但现在i的值已经变为3</span><br></pre></td></tr></table></figure></p><p>因此，返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p><blockquote><p><strong>返回闭包不能引用循环变量，请改写count()函数，让它正确返回能计算1x1、2x2、3x3的函数。</strong></p></blockquote><blockquote><p>考察下面的函数 f:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> j*j</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>它可以正确地返回一个闭包g，g所引用的变量j不是循环变量，因此将正常执行。<br>在count函数的循环内部，如果借助f函数，就可以避免引用循环变量i。</p><blockquote><p><strong>参考代码:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    ---</span><br><span class="line">        <span class="comment"># 写法一：</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">                <span class="keyword">return</span> j*j</span><br><span class="line">            <span class="keyword">return</span> g</span><br><span class="line">        r = f(i)</span><br><span class="line">        fs.append(r)</span><br><span class="line">    ---</span><br><span class="line">        <span class="comment"># 写法二：</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">lambda</span> : i*i</span><br><span class="line">        fs.append(f(i))</span><br><span class="line">    ---</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line"><span class="keyword">print</span> f1(), f2(), f3()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World !</title>
      <link href="/2018/03/18/new/"/>
      <content type="html"><![CDATA[<p><code>本文置顶。</code></p><p>这是庄心昊的 <strong>个人博客</strong> ，旨在分享个人学习路径中的所获所得，避免后生走弯路。<br>本博客中 <strong>所有代码均经过本人调试</strong> ，关于 <strong>调试环境</strong> 若无特殊说明请参看 <a href="/about/#env"><code>代码环境</code></a> 。</p><p>点 <strong><a href="/archives/"><code>这里</code></a></strong> 查看我的文章列表</p><blockquote><p><strong>注意：</strong>本博客内的所有文章采用&ensp; <strong><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></strong> &ensp;进行许可，转载请勿用于商业目的，并请著名原作者（若不是本人我会特别注明）及原文链接。</p></blockquote><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Happy coding !</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
    </entry>
    
    <entry>
      <title>汇编指令简析</title>
      <link href="/2017/10/09/asm/"/>
      <content type="html"><![CDATA[<p>本文是上学期学习汇编语言时候的课堂笔记。</p><div id="content"></div><blockquote><p><strong>分类索引</strong>（单击命令直接索引）</p></blockquote><table><thead><tr><th style="text-align:center">分类</th><th>命令</th></tr></thead><tbody><tr><td style="text-align:center">符号数相关</td><td><a href="/2017/10/09/asm/#1"><code>JG</code></a>、<a href="/2017/10/09/asm/#1"><code>JL</code></a>、<a href="/2017/10/09/asm/#2"><code>IMUL</code></a></td></tr><tr><td style="text-align:center">通用数据传送指令</td><td><a href="/2017/10/09/asm/#3"><code>MOV</code></a>、<a href="/2017/10/09/asm/#4"><code>POP</code></a>、<a href="/2017/10/09/asm/#4"><code>PUSH</code></a>、<a href="/2017/10/09/asm/#5"><code>XCHG</code></a>、<a href="/2017/10/09/asm/#6"><code>IN</code></a>、<a href="/2017/10/09/asm/#6"><code>OUT</code></a></td></tr><tr><td style="text-align:center">地址传送指令</td><td><a href="/2017/10/09/asm/#LEA"><code>LEA</code></a>、<a href="/2017/10/09/asm/#LDS"><code>LDS</code></a>、<a href="/2017/10/09/asm/#LES"><code>LES</code></a>、<a href="/2017/10/09/asm/#PUS"><code>PUSHF</code></a>、<a href="/2017/10/09/asm/#PUS"><code>POPF</code></a></td></tr><tr><td style="text-align:center">转换指令</td><td><a href="/2017/10/09/asm/#CBW"><code>CBW</code></a>、<a href="/2017/10/09/asm/#CBW"><code>CWD</code></a>、<a href="/2017/10/09/asm/#XLAT"><code>XLAT</code></a></td></tr><tr><td style="text-align:center">加减乘除</td><td><a href="/2017/10/09/asm/#PLU"><code>ADD</code></a>、<a href="/2017/10/09/asm/#PLU"><code>INC</code></a>、<a href="/2017/10/09/asm/#PLU"><code>ADC</code></a>、<a href="/2017/10/09/asm/#MIN"><code>SUB</code></a>、<a href="/2017/10/09/asm/#MIN"><code>DEC</code></a>、<a href="/2017/10/09/asm/#MIN"><code>NEG</code></a>、<a href="/2017/10/09/asm/#TIM"><code>MUL</code></a>、<a href="/2017/10/09/asm/#DIV"><code>DIV</code></a></td></tr><tr><td style="text-align:center">逻辑运算</td><td><a href="/2017/10/09/asm/#A"><code>AND</code></a>、<a href="/2017/10/09/asm/#A"><code>OR</code></a>、<a href="/2017/10/09/asm/#A"><code>XOR</code></a>、<a href="/2017/10/09/asm/#A"><code>NOT</code></a>、<a href="/2017/10/09/asm/#A"><code>TEST</code></a></td></tr><tr><td style="text-align:center">移位指令</td><td><a href="/2017/10/09/asm/#B"><code>SHL</code></a>、<a href="/2017/10/09/asm/#B"><code>SHR</code></a>、<a href="/2017/10/09/asm/#B"><code>SAL</code></a>、<a href="/2017/10/09/asm/#B"><code>SAR</code></a>、<a href="/2017/10/09/asm/#C"><code>ROL</code></a>、<a href="/2017/10/09/asm/#C"><code>ROR</code></a>、<a href="/2017/10/09/asm/#C"><code>RCL</code></a>、<a href="/2017/10/09/asm/#C"><code>RCR</code></a></td></tr><tr><td style="text-align:center">字符串操作</td><td><a href="/2017/10/09/asm/#MOV"><code>MOV</code></a>、<a href="/2017/10/09/asm/#CMPSB"><code>CMPSB</code></a>、<a href="/2017/10/09/asm/#SCASB"><code>SCASB</code></a>、<a href="/2017/10/09/asm/#STOSB"><code>STOSB</code></a>、<a href="/2017/10/09/asm/#LODSB"><code>LODSB</code></a></td></tr><tr><td style="text-align:center">控制转移指令</td><td><a href="/2017/10/09/asm/#JMP"><code>JMP</code></a>、<a href="/2017/10/09/asm/#LOOP"><code>LOOP</code></a>、<a href="/2017/10/09/asm/#CAL"><code>CALL</code></a>、<a href="/2017/10/09/asm/#CAL"><code>RETN</code></a>、<a href="/2017/10/09/asm/#CAL"><code>RETF</code></a></td></tr></tbody></table><a id="more"></a><p><br></p><hr><p><br></p><h2 id="符号数相关"><a href="#符号数相关" class="headerlink" title="符号数相关"></a>符号数相关</h2><h3 id="1">jg/jl大小比较</h3> <p>jg 符号数大于<br>jl 符号数小于</p><blockquote><p>跳转依据：</p></blockquote><table><thead><tr><th style="text-align:center">符号</th><th>依据</th></tr></thead><tbody><tr><td style="text-align:center">a &lt; b</td><td>SF！=OF</td></tr><tr><td style="text-align:center">a==b</td><td>ZF=0</td></tr><tr><td style="text-align:center">a &gt; b</td><td>SF=OF且ZF=0</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ah=0FFh, bh=1</span><br><span class="line">cmp ah, bh</span><br><span class="line">jg ah_is_larger; </span><br><span class="line">//跳转不发生（0FF作为符号数为-1）</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="2">imul 符号数乘法</h3><ul><li><strong>imul eax<code>只寄存器</code>, ebx<code>寄存器或变量</code>, 1234h<code>只常数</code></strong><br>eax = ebx * 1234h</li><li><strong>imul eax, ebx</strong><br>eax自乘ebx</li></ul><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="通用数据传送指令"><a href="#通用数据传送指令" class="headerlink" title="通用数据传送指令"></a>通用数据传送指令</h2><h3 id="3">MOV 指令</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[√] <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">bx</span>], <span class="number">ah</span></span><br><span class="line">[×] <span class="keyword">mov</span>              <span class="built_in">ax</span> , <span class="number">bh</span> <span class="comment">;左右操作数宽度必须相等</span></span><br></pre></td></tr></table></figure><ul><li><code>DS</code> / <code>CS</code> / <code>IP</code> 不能被mov改变</li></ul><p><strong>mov 的变体</strong></p><ul><li><code>movzx</code> : move by zero extention</li><li><code>movsx</code> : move by sign extention</li><li><code>[rep] movsb</code>  ; 以字节为单位移动CX个字符</li></ul><blockquote><p>DS : SI 指向源字符串<br>ES : DI 指向目标字符串<br>若 DF=0 即正方向则SI++，DI++，否则反之。</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="4">POP / PUSH 指令</h3><ul><li>不能对8位值进行push/pop:</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[×] <span class="keyword">push</span> <span class="number">ah</span></span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="5"> XCHG 指令 </h3><p>（略）</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="6"> IN / OUT 指令 </h3><p>基本格式：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>, <span class="number">21h</span></span><br></pre></td></tr></table></figure></p><p>从21h号端口读取一个字节存放到AL中</p><blockquote><ul><li>端口地址&gt;=100h，必须存放到DX</li><li>端口地址的范围是：[0000h, 0FFFFh]，共65536个端口。</li></ul></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h2><h3 id="LEA"> LEA  <code>取变量的偏移地址</code></h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lea</span> <span class="built_in">eax</span>, [<span class="built_in">ebp</span>-<span class="number">64</span>]</span><br></pre></td></tr></table></figure><p>EAX = EBP-64</p><blockquote><ul><li>lea dx, ds:[1000h] ; DX=1000h</li><li>设BX=1000h, SI=2<br>lea ax, ds:[bx+si+3]; AX=bx+si+3=1005h</li></ul></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="LDS"> LDS <code>把远指针装到DS:DEST</code> </h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lds</span> dest, src</span><br></pre></td></tr></table></figure><p>把 <code>src</code> 指向的地址，高位存放在<code>DS</code>中，低位存放在<code>dest</code>中。</p><blockquote><p>16位时，<br>比如当前DS=1000H, BX=0100H.<br>当前内存:<br>1000:0100 01<br>1000:0101 02<br>1000:0102 03<br>1000:0103 04<br>而有一条指令:LDS BX,[BX]<br>[BX]指向1000:0100,执行后BX存低位的内容,也就是BX=0201H,<br>而DS则存高位的内容,也就是[BX+2]的内容,DS=0403H</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="LES"> LES <code>把远指针装到ES:DEST</code> </h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">les</span> dest, src</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="PUS"> PUSHF，POPF <code>标志寄存器传送指令</code> </h3><p>（把FL压入/弹出ax）<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pushf</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ax</span> <span class="comment">; AX=FL</span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">ax</span>, <span class="number">1</span><span class="comment">; 第0位变1，其它位不变</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">popf</span>    <span class="comment">; FL=AX</span></span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="转换指令"><a href="#转换指令" class="headerlink" title="转换指令"></a>转换指令</h2><h3 id="CBW"> CBW，CWD <code>符号扩充指令</code> </h3><blockquote><p><strong>CBW:</strong> convert byte to word<br><strong>CWD:</strong> convert word to double word<br><strong>CDQ:</strong> convert double word to quadruple word(32位扩充为64位)</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">7Fh</span></span><br><span class="line"><span class="keyword">cbw</span>         <span class="comment">; AX=007F</span></span><br></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">0F9h</span></span><br><span class="line"><span class="keyword">cbw</span>         <span class="comment">; AX=0FFF9h</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 8000h</span><br><span class="line">cwd         ; <span class="attribute">DX</span>=0FFFFh, <span class="attribute">AX</span>=8000h</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, <span class="number">0</span>FFFFFFFFh</span><br><span class="line">cdq         ; EDX=<span class="number">0</span>FFFFFFFFh, EAX=<span class="number">0</span>FFFFFFFFh</span><br><span class="line">                  高<span class="number">32</span>位           低<span class="number">32</span>位</span><br></pre></td></tr></table></figure><ul><li><code>movzx</code> : move by zero extention</li><li><code>movsx</code> : move by sign extention</li></ul><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="XLAT"> XLAT <code>换码指令</code> </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 设 char t[]="0123456789ABCDEF";</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, offset t</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">10</span></span><br><span class="line"><span class="keyword">xlat</span><span class="comment">; 结果AL='A'</span></span><br><span class="line">     实际<span class="built_in">AL</span>=<span class="built_in">DS</span>:[<span class="built_in">BX</span>+<span class="built_in">AL</span>]</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h2><h3 id="PLU"> 加 </h3><table><thead><tr><th>指令</th><th>用法</th></tr></thead><tbody><tr><td>add</td><td></td></tr><tr><td>inc</td><td>不影响CF位</td></tr><tr><td>adc</td><td>带进位加法。当进行32位以上运算时，要求低位字节相加，而高位字节再相加时就要考虑低位相加的进位，即CF</td></tr></tbody></table><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="MIN"> 减 </h3><table><thead><tr><th>指令</th><th>用法</th></tr></thead><tbody><tr><td>sub</td><td></td></tr><tr><td>dec</td><td>自减</td></tr><tr><td>neg</td><td>求相反数</td></tr></tbody></table><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="TIM"> 乘 <code>非符号</code> </h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mul </span>src</span><br></pre></td></tr></table></figure><p>src <code>不能是立即数，寄存器和地址均可</code></p><table><thead><tr><th>src字节数</th><th>操作对象</th><th>结果存放</th></tr></thead><tbody><tr><td>8字节</td><td>al</td><td>ax</td></tr><tr><td>16字节</td><td>ax</td><td>dx : ax</td></tr><tr><td>32字节</td><td>eax</td><td>edx : eax</td></tr></tbody></table><p><code>即 AX = AL * src</code></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="DIV"> 除 <code>非符号</code> </h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> op</span><br></pre></td></tr></table></figure><table><thead><tr><th>op字节数</th><th>操作对象</th><th>结果存放</th></tr></thead><tbody><tr><td>8字节</td><td>ax</td><td>al（整除）；ah（余数）</td></tr><tr><td>16字节</td><td>dx : ax</td><td>ax（整除）；dx（余数）</td></tr><tr><td>32字节</td><td>edx : eax</td><td>eax（整除）；edx（余数）</td></tr></tbody></table><blockquote><p>语句比较</p><ul><li><code>test</code> / <code>and</code>（<code>cmp</code> / <code>sub</code>）<br>运算结果不影响操作数，<strong>只影响标志位</strong>。<br><strong>影响标志：</strong> C,O,P,Z,S(其中C与O两个标志会被设为0)</li><li><code>neg</code> / <code>not</code><br><code>neg</code> 求相反数，<code>not</code> 逐位求反</li><li><code>inc</code> / <code>add</code><br>是否影响flag</li><li><code>jc</code> 与 <code>jb</code> 指令完全等价。<br><code>jz</code> 与 <code>je</code> 指令完全等价。</li></ul></blockquote><h4 id="比较方法"><a href="#比较方法" class="headerlink" title="比较方法"></a>比较方法</h4><ol><li>非符号数：CF / ZF</li><li>符号数：SF / OF / ZF<blockquote><p>OF=1 即结果溢出（有错），否定SF得到的符号结果</p></blockquote></li></ol><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="逻辑运算和移位"><a href="#逻辑运算和移位" class="headerlink" title="逻辑运算和移位"></a>逻辑运算和移位</h2><p><br></p><h3 id="A"> 逻辑运算指令 </h3><p><code>AND</code>，<code>OR</code>，<code>XOR</code>，<code>NOT</code>，<code>TEST</code></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h3><p><code>SHL</code>，<code>SHR</code>，<code>SAL</code>，<code>SAR</code>，<br><code>ROL</code>，<code>ROR</code>，<code>RCL</code>，<code>RCR</code><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shl</span> <span class="number">ah</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h4 id="B"> <strong>单向</strong> </h4><table><thead><tr><th>符号</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td>SHL</td><td>逻辑左移</td><td>低位补0, 高位进CF</td></tr><tr><td>SHR</td><td>逻辑右移</td><td>低位进CF, 高位补0</td></tr><tr><td>SAL</td><td>算术左移</td><td>（同SHL）</td></tr><tr><td>SAR</td><td>算术右移</td><td>每位右移, 低位进CF, 高位不变</td></tr></tbody></table><p><code>它们的结果影响 OF、SF、ZF、PF、CF</code></p><h4 id="C"> <strong>循环</strong> </h4><table><thead><tr><th>符号</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td>ROL</td><td>循环左移</td><td>高位到低位并送CF</td></tr><tr><td>ROR</td><td>循环右移</td><td>低位到高位并送CF</td></tr><tr><td>RCL</td><td>带进位循环左移</td><td>进位值(原CF)到低位, 高位进CF</td></tr><tr><td>RCR</td><td>带进位循环右移</td><td>进位值(原CF)到高位, 低位进CF</td></tr></tbody></table><p><code>它们的结果影响 OF、CF</code></p><blockquote><p>8086中，当次数&gt;=2时，移位次数应先赋值给 <strong>cl</strong></p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="MOV"> MOVSB <code>字符串传送</code> </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">rep</span>] <span class="keyword">movsb</span></span><br></pre></td></tr></table></figure><p>以字节为单位，从 <strong>DS:SI</strong> 到 <strong>ES:DI</strong> 移动CX个字符</p><ul><li>DF控制方向。若DF=0即正方向则SI++，DI++。</li></ul><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="CMPSB"> CMPSB <code>字符串比较</code> </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">repe</span> | <span class="keyword">repne</span>] <span class="keyword">cmpsb</span></span><br></pre></td></tr></table></figure><p>若本次比较 <code>相等</code> / <code>不等</code> 则继续比较下一个</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="SCASB"> SCASB <code>字符串查找</code> </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">repe</span> | <span class="keyword">repne</span>] <span class="keyword">scasb</span></span><br></pre></td></tr></table></figure><p>设ES:DI → 以’\0’结束的字符串，要求该字符串长度<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">1000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>, <span class="number">1080h</span>   <span class="comment">; ES:DI → "ABC..."</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">0FFFFh</span>  <span class="comment">; ES:DI → "ABC",0,[]...</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">0</span>       <span class="comment">; AL=待查找的字符</span></span><br><span class="line"><span class="keyword">cld</span></span><br><span class="line"><span class="keyword">repne</span> <span class="keyword">scasb</span>     <span class="comment">; 循环结束时，DI=1088h, CX=FFFF-8</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">cx</span></span><br><span class="line"><span class="keyword">not</span> <span class="built_in">cx</span>          <span class="comment">; CX=FFFF-CX=字符串长度(不含0)</span></span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="STOSB"> STOSB <code>存入字符串</code> </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">repe</span>] <span class="keyword">stosb</span></span><br></pre></td></tr></table></figure><p>stosb把AL的值保存到ES:DI所指向的内存单元中</p><ul><li>当DF==0时DI++，当DF==1时DI–</li></ul><p>设要把从地址1000:10A0开始共100h个字节内存单元全部填0<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">1000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span><span class="comment">; ES=1000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>, <span class="number">10A0h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">100h</span></span><br><span class="line"><span class="keyword">cld</span></span><br><span class="line"><span class="keyword">xor</span> <span class="built_in">al</span>, <span class="built_in">al</span></span><br><span class="line"><span class="keyword">rep</span> <span class="keyword">stosb</span></span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="LODSB"> LODSB <code>从字符串取字节或字</code> </h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lodsb</span></span><br></pre></td></tr></table></figure><p>AL = DS : [SI],  SI++</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><h3 id="JMP"> JMP </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[√] <span class="keyword">jmp</span> <span class="number">0108h</span></span><br><span class="line">[√] <span class="keyword">jmp</span> <span class="number">1234h</span>:<span class="number">5678h</span></span><br><span class="line">[√] <span class="keyword">jmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">10F0h</span>]</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="LOOP"> LOOP </h3><p>CX-1</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="CAL"> CALL，RETN，RETF <code>子程序调用与返回</code> </h3><p>retn表示近返回，可简写成ret;<br>retf表示远返回。<br>call既可以表示近调用，也可以表示远调用<br>retn [count]  ; <code>count</code>多出步骤：SP = SP + count</p><p><strong>堆栈传递</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">f:</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bp</span>, <span class="built_in">sp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="number">4</span>]<span class="comment">; 从堆栈中取得参数</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ax</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">3</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ax</span><span class="comment">; 参数压入到堆栈</span></span><br><span class="line">   <span class="keyword">call</span> f</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">sp</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>C语言函数调用y=f(2,3)求两数之和转化成汇编语言<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">f:</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">bp</span><span class="comment">;(4)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bp</span>, <span class="built_in">sp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="number">4</span>]</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="number">6</span>]</span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">bp</span><span class="comment">; (5)</span></span><br><span class="line">   <span class="keyword">ret</span><span class="comment">; (6)</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">3</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ax</span><span class="comment">; (1)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">2</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ax</span><span class="comment">; (2)</span></span><br><span class="line">   <span class="keyword">call</span> f<span class="comment">; (3)</span></span><br><span class="line"><span class="symbol">here:</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">sp</span>, <span class="number">4</span><span class="comment">;(7)</span></span><br></pre></td></tr></table></figure></p><p>上述程序运行过程中的堆栈布局如下:</p><blockquote><p>ss:1FF8 old bp &lt;- bp (4)<br>ss:1FFA here &lt;- (3)(5)<br>ss:1FFC 02   &lt;- (2)(6)<br>ss:1FFE 03   &lt;- (1)<br>ss:2000 ??   &lt;- (7)</p></blockquote><p>cx/dx可以随便用<br>ax一般用作返回值</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asm </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <content type="html"><![CDATA[<h2 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h2><p>浙江大学2015级生物科学专业，辅修竺可桢学院创新与创业管理强化班（ITP）。<br>（有空了慢慢写吧！）</p><table><thead><tr><th>技能</th><th>水平</th><th>备注</th></tr></thead><tbody><tr><td>Python</td><td><i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle-o"></i></td><td>个人首要编程语言，较熟练，写过爬虫、服务器等程序和部件。</td></tr><tr><td>C4D</td><td><i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle-o"></i>&nbsp;<i class="fa fa-circle-o"></i></td><td>建模渲染和简单动画，做过一些作品。</td></tr></tbody></table><p><br></p><p><strong>爱好</strong></p><ul><li>漫威忠实粉丝</li><li>科幻电影和谍战片（007/星际穿越）</li></ul><p><br></p><p><strong>个人公众号</strong></p><p><img src="/images/000.png" alt="file-list"></p><p><br></p><hr><p><span id="env"></span><br><br></p><h2 id="我使用的环境和工具"><a href="#我使用的环境和工具" class="headerlink" title="我使用的环境和工具"></a>我使用的环境和工具</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python_3.6.4_x64<br><strong>主要的包</strong></p><table><thead><tr><th>名称</th><th>版本</th><th>备注</th></tr></thead><tbody><tr><td>pip</td><td>9.0.1</td><td></td></tr><tr><td>wheel</td><td>0.30.0</td><td></td></tr><tr><td>beautifulsoup4</td><td>4.6.0</td><td></td></tr><tr><td>django</td><td>2.0.3</td><td></td></tr><tr><td>matplotlib</td><td>2.1.2</td><td></td></tr><tr><td>numpy</td><td>1.14.0</td><td></td></tr><tr><td>opencv-python</td><td>3.4.0.12</td><td></td></tr><tr><td>pandas</td><td>0.22.0</td><td></td></tr><tr><td>pyperclip</td><td>1.6.0</td><td></td></tr><tr><td>requests</td><td>2.18.4</td><td></td></tr><tr><td>scikit-learn</td><td>0.19.1</td><td></td></tr><tr><td>scipy</td><td>1.0.0</td><td></td></tr></tbody></table>]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
