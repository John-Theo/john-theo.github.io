<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Regularization 和 L1、L2 罚项</title>
      <link href="/2018/12/04/regularization/"/>
      <content type="html"><![CDATA[<p>疑惑了好久的术语，借机研究一下。</p><p>本文大部分翻译自“<a href="https://www.statisticshowto.datasciencecentral.com/regularization/" target="_blank" rel="noopener">Regularization: Simple Definition, L1 &amp; L2 Penalties</a>”。</p><p>另外参考：</p><ul><li><a href="https://www.zhihu.com/question/59939602" target="_blank" rel="noopener">如何理解Normalization，Regularization 和 standardization？</a></li><li><a href="http://sklearn.apachecn.org/cn/0.19.0/auto_examples/linear_model/plot_logistic_l1_l2_sparsity.html#sphx-glr-auto-examples-linear-model-plot-logistic-l1-l2-sparsity-py" target="_blank" rel="noopener">L1 Penalty and Sparsity in Logistic Regression</a></li></ul><a id="more"></a><p><br></p><h2 id="什么是正则化"><a href="#什么是正则化" class="headerlink" title="什么是正则化"></a>什么是正则化</h2><p>正则化是为了避免 <a href="https://www.statisticshowto.datasciencecentral.com/probability-and-statistics/regression-analysis/#overfitting" target="_blank" rel="noopener">过拟合（overfitting）</a> 采取的一种手段。它通过对回归系数中的较大值做罚项来实现。简单来说，它能够<strong>减少参数、缩小（简化）模型</strong>。这样更加流形化、更加 <a href="https://www.statisticshowto.datasciencecentral.com/parsimonious-model/" target="_blank" rel="noopener">简约（parsimonious）</a> 的模型往往会在实际预测的时候表现更加良好。正则化给更加复杂的模型加上罚项后，再将潜在模型从过拟合最轻到最严重排序，有最小“过拟合”得分的模型一般认为在预测能力上是最佳的。</p><p><br></p><h2 id="正则化为什么是必要的"><a href="#正则化为什么是必要的" class="headerlink" title="正则化为什么是必要的"></a>正则化为什么是必要的</h2><p>因为 <a href="https://www.statisticshowto.datasciencecentral.com/least-squares-regression-line/" target="_blank" rel="noopener">最小二乘法（least-squares-regression-line）</a> 中，<a href="https://www.statisticshowto.datasciencecentral.com/residual-sum-squares/" target="_blank" rel="noopener">平方残差和（residual-sum-squares）</a> 最小化的过程中会导致不稳定。这点在模型中存在 <a href="https://www.statisticshowto.datasciencecentral.com/multicollinearity/" target="_blank" rel="noopener">多重共线性（multicollinearity）</a> 时表现得尤为突出。但是仅仅在模型拟合的时候，就出现了明显的缺陷：任何数据集都可以在一个模型上拟合，即使它极其复杂。</p><p>例如，拿一个只具有两个点的数据集来说，最简单的模型是在两点间连线，或者一个一阶多项式。但是无数其他模型都可以在这个数据集上拟合：二阶多项式、三阶多项式等等。</p><p><img src="https://www.statisticshowto.datasciencecentral.com/wp-content/uploads/2016/10/l1-and-l2-regularization-300x148.png" alt="L1 &amp; L2 Regularization"></p><p>在小数据集上拟合往往会得到很复杂、过拟合的模型，而简单的模型则表现不佳。例子中的两个点在同一条直线上不代表新增的点也在这条直线上，而且大概率不在。所以简单来说，正则化对复杂模型进行罚项，而在不牺牲模型预测能力的情况下更偏好简单（回归系数更小）的模型。</p><p><br></p><h2 id="惩罚方法"><a href="#惩罚方法" class="headerlink" title="惩罚方法"></a>惩罚方法</h2><p>正则化的作用是将数据逐渐 <a href="https://www.statisticshowto.datasciencecentral.com/what-is-bias/" target="_blank" rel="noopener">逼近（biasing）</a> 某些特定值（例如接近于零的极小值）。这样的逼近是通过增加一个 _调整参数_ 来改变下式中的 <strong>R</strong> 实现的：</p><p><img src="https://www.zhihu.com/equation?tex=min%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7BJ%28x_%7Bi%7D%2Cy_%7Bi%7D%29%2B%5Clambda%7DR%28f%29" alt=""></p><ul><li><strong>L1 正则化</strong> 增加了一项大小等于系数<strong>离散程度绝对值</strong>的 L1 罚项。可以通过 L1 产生稀疏的模型（如系数很少的模型）；一些系数可以归零并去除。<strong>Lasso 回归</strong> 用的就是这个方法。</li><li><strong>L2 正则化</strong> 增加了一项大小等于系数离散程度平方的 L2 罚项。L2 <strong>不会</strong>产生稀疏模型，所有稀疏会被相同的因子缩小（但并不会剔除其中任意一个）。 <strong>岭回归</strong> 和 <strong>支持向量机（SVM）</strong> 使用这种方法。</li><li><strong>Elastic nets</strong> 综合了 L1 &amp; L2 方法，但是增加了一个超参数。（参见 <a href="http://web.stanford.edu/~hastie/Papers/B67.2%20%282005%29%20301-320%20Zou%20&amp;%20Hastie.pdf" target="_blank" rel="noopener">Zou and Hastie 的这篇文章</a>）</li></ul><p>也即分别的，<br>带 <strong>L1</strong> 罚项的 logistic 回归主要解决以下优化问题：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cunderset%7Bw%2Cc%7D%7Bmin%5C%2C%7D%5C%7Cw%5C%7C_1%2BC%5Csum_%7Bi%3D1%7D%5En%5Clog%28%5Cexp%28-y_i%28X_i%5ETw%2Bc%29%29%2B1%29." alt="\underset{w,c}{min\,}\|w\|_1+C\sum_{i=1}^n\log(\exp(-y_i(X_i^Tw+c))+1)."></p><p>而带 <strong>L2</strong> 罚项的 logistic 回归主要解决以下优化问题：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cunderset%7Bw%2Cc%7D%7Bmin%5C%2C%7D%5Cfrac%7B1%7D%7B2%7Dw%5ETw%2BC%5Csum_%7Bi%3D1%7D%5En%5Clog%28%5Cexp%28-y_i%28X_i%5ETw%2Bc%29%29%2B1%29." alt="\underset{w, c}{min\,} \frac{1}{2}w^T w + C \sum_{i=1}^n \log(\exp(- y_i (X_i^T w + c)) + 1) ."></p><p><br></p><h2 id="和-Normalization、Standardization-的区别"><a href="#和-Normalization、Standardization-的区别" class="headerlink" title="和 Normalization、Standardization 的区别"></a>和 Normalization、Standardization 的区别</h2><ol><li><p>normalization和standardization差不多，都是把数据进行前处理，从而<strong>使数值都落入到统一的数值范围</strong>，从而在建模过程中，各个特征量没差别对待。<strong>normalization</strong> 一般是把数据限定在需要的范围，比如一般都是 <strong>[0, 1]</strong>，从而<strong>消除了数据量纲对建模的影响</strong>。<strong>standardization</strong> 一般是指将数据<strong>正态化</strong>，使平均值0方差为1。因此normalization和standardization 是<strong>针对数据而言的</strong>，消除一些数值差异带来的特种重要性偏见。经过归一化的数据，能<strong>加快训练速度，促进算法的收敛</strong>。</p></li><li><p>而regularization是<strong>在cost function里面加罚项项，增加建模的模糊性</strong>，从而把捕捉到的趋势从局部细微趋势，调整到整体大概趋势。虽然一定程度上的放宽了建模要求，但是能<strong>有效防止over-fitting的问题</strong>，增加模型准确性。因此，regularization是<strong>针对模型而言</strong>。</p></li></ol><p><strong>normalization 的方法主要有：</strong></p><ol><li>最大最小值</li><li>对数</li><li>反正切</li></ol><p><br></p><h2 id="为什么-Regularization-有效"><a href="#为什么-Regularization-有效" class="headerlink" title="为什么 Regularization 有效"></a>为什么 Regularization 有效</h2><p>引用知乎某位答友的说法：</p><blockquote><p>不用深究其为何work，研究起来就是泛函分析。</p></blockquote><p>大佬请便。</p><p><br></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Authors: Alexandre Gramfort &lt;alexandre.gramfort@inria.fr&gt;</span></span><br><span class="line"><span class="comment">#          Mathieu Blondel &lt;mathieu@mblondel.org&gt;</span></span><br><span class="line"><span class="comment">#          Andreas Mueller &lt;amueller@ais.uni-bonn.de&gt;</span></span><br><span class="line"><span class="comment"># License: BSD 3 clause</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="comment"># Scaler 是 preprocessing 的步骤</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这句话使输出中不会有省略号</span></span><br><span class="line">np.set_printoptions(threshold=np.nan)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载了手写数字图片数据集（详见最下方链接），</span></span><br><span class="line"><span class="comment"># data   位图每个像素对应的向量</span></span><br><span class="line"><span class="comment"># target 图片对应的实际数字</span></span><br><span class="line">digits = datasets.load_digits()</span><br><span class="line">X, y = digits.data, digits.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有值正态分布到 μ=0，σ²=1 的空间</span></span><br><span class="line">X = StandardScaler().fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按标签是否大于 4 来做二分类（大于4的值为1否则为0）</span></span><br><span class="line">y = (y &gt; <span class="number">4</span>).astype(np.int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># L1、L2 算法的参数 C，分别取 (100, 1, 0.01) 试验</span></span><br><span class="line"><span class="keyword">for</span> i, C <span class="keyword">in</span> enumerate((<span class="number">100</span>, <span class="number">1</span>, <span class="number">0.01</span>)):</span><br><span class="line">    <span class="comment"># （各参数解释见下）</span></span><br><span class="line">    clf_l1_LR = LogisticRegression(C=C, penalty=<span class="string">'l1'</span>, tol=<span class="number">0.01</span>)</span><br><span class="line">    clf_l2_LR = LogisticRegression(C=C, penalty=<span class="string">'l2'</span>, tol=<span class="number">0.01</span>)</span><br><span class="line">    clf_l1_LR.fit(X, y)</span><br><span class="line">    clf_l2_LR.fit(X, y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># numpy.ravel() 见最下链接</span></span><br><span class="line">    <span class="comment"># 取得系数并打平</span></span><br><span class="line">    coef_l1_LR = clf_l1_LR.coef_.ravel()</span><br><span class="line">    coef_l2_LR = clf_l2_LR.coef_.ravel()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 因为 L1 正则化产生稀疏矩阵，coef_l1_LR 包含 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算两系数矩阵的稀疏度</span></span><br><span class="line">    sparsity_l1_LR = np.mean(coef_l1_LR == <span class="number">0</span>) * <span class="number">100</span></span><br><span class="line">    sparsity_l2_LR = np.mean(coef_l2_LR == <span class="number">0</span>) * <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># LogisticRegression.score() 返回经训练后的回归器在定特征和标签上的平均正确率</span></span><br><span class="line">    print(<span class="string">"C=%.2f"</span> % C)</span><br><span class="line">    print(<span class="string">"Sparsity with L1 penalty: %.2f%%"</span> % float(sparsity_l1_LR))</span><br><span class="line">    print(<span class="string">"score with L1 penalty: %.4f"</span> % clf_l1_LR.score(X, y))</span><br><span class="line">    print(<span class="string">"Sparsity with L2 penalty: %.2f%%"</span> % float(sparsity_l2_LR))</span><br><span class="line">    print(<span class="string">"score with L2 penalty: %.4f"</span> % clf_l2_LR.score(X, y))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 作图</span></span><br><span class="line">    l1_plot = plt.subplot(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span> * i + <span class="number">1</span>)</span><br><span class="line">    l2_plot = plt.subplot(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span> * (i + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        l1_plot.set_title(<span class="string">"L1 penalty"</span>)</span><br><span class="line">        l2_plot.set_title(<span class="string">"L2 penalty"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 把系数矩阵还原后显示为灰度图</span></span><br><span class="line">    l1_plot.imshow(np.abs(coef_l1_LR.reshape(<span class="number">8</span>, <span class="number">8</span>)), interpolation=<span class="string">'nearest'</span>,</span><br><span class="line">                   cmap=<span class="string">'binary'</span>, vmax=<span class="number">1</span>, vmin=<span class="number">0</span>)</span><br><span class="line">    l2_plot.imshow(np.abs(coef_l2_LR.reshape(<span class="number">8</span>, <span class="number">8</span>)), interpolation=<span class="string">'nearest'</span>,</span><br><span class="line">                   cmap=<span class="string">'binary'</span>, vmax=<span class="number">1</span>, vmin=<span class="number">0</span>)</span><br><span class="line">    plt.text(<span class="number">-8</span>, <span class="number">3</span>, <span class="string">"C = %.2f"</span> % C)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不显示坐标轴</span></span><br><span class="line">    l1_plot.set_xticks(())</span><br><span class="line">    l1_plot.set_yticks(())</span><br><span class="line">    l2_plot.set_xticks(())</span><br><span class="line">    l2_plot.set_yticks(())</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><blockquote><ul><li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/generated/sklearn.datasets.load_digits.html#sklearn.datasets.load_digits" target="_blank" rel="noopener">sklearn.datasets.load_digits()</a></li><li><a href="https://blog.csdn.net/lanchunhui/article/details/50354978" target="_blank" rel="noopener">numpy.ravel()</a></li><li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/generated/sklearn.datasets.load_digits.html#sklearn.datasets.load_digits" target="_blank" rel="noopener">sklearn.datasets.load_digits()</a></li><li><a href="https://blog.csdn.net/lanchunhui/article/details/50354978" target="_blank" rel="noopener">numpy.ravel()</a></li><li><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/generated/sklearn.linear_model.LogisticRegression.html#sklearn.linear_model.LogisticRegression" target="_blank" rel="noopener">sklearn.linear_model.LogisticRegression</a></li><li>LogisticRegression 主要参数：<ul><li>penalty : str, ‘l1’ or ‘l2’, default: ‘l2’<br>​    指定正则化罚项的方式。 ‘newton-cg’, ‘lbfgs’ 和 ‘sag’ 算法只能使用 L2 罚项。</li><li>tol : float, default: 1e-4<br>​    算法停止的边界，越大停止越快。</li><li>C : float, default: 1.0<br>​    正则化强度的逆（inverse），必须是正的浮点数。<br>​    正如支持向量机，越小的值代表越大的正则化强度。</li><li>solver : {‘newton-cg’, ‘lbfgs’, ‘liblinear’, ‘sag’, ‘saga’}, default: ‘liblinear’<br>​    用于问题优化的算法。</li></ul></li></ul></blockquote><p><strong>运行结果：</strong></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">C=<span class="number">100.00</span></span><br><span class="line">Sparsity <span class="keyword">with</span> L1 penalty: <span class="number">6.25</span>%</span><br><span class="line"><span class="built_in">score</span> <span class="keyword">with</span> L1 penalty: <span class="number">0.9110</span></span><br><span class="line">Sparsity <span class="keyword">with</span> L2 penalty: <span class="number">4.69</span>%</span><br><span class="line"><span class="built_in">score</span> <span class="keyword">with</span> L2 penalty: <span class="number">0.9098</span></span><br><span class="line"></span><br><span class="line">C=<span class="number">1.00</span></span><br><span class="line">Sparsity <span class="keyword">with</span> L1 penalty: <span class="number">9.38</span>%</span><br><span class="line"><span class="built_in">score</span> <span class="keyword">with</span> L1 penalty: <span class="number">0.9104</span></span><br><span class="line">Sparsity <span class="keyword">with</span> L2 penalty: <span class="number">4.69</span>%</span><br><span class="line"><span class="built_in">score</span> <span class="keyword">with</span> L2 penalty: <span class="number">0.9093</span></span><br><span class="line"></span><br><span class="line">C=<span class="number">0.01</span></span><br><span class="line">Sparsity <span class="keyword">with</span> L1 penalty: <span class="number">85.94</span>%</span><br><span class="line"><span class="built_in">score</span> <span class="keyword">with</span> L1 penalty: <span class="number">0.8631</span></span><br><span class="line">Sparsity <span class="keyword">with</span> L2 penalty: <span class="number">4.69</span>%</span><br><span class="line"><span class="built_in">score</span> <span class="keyword">with</span> L2 penalty: <span class="number">0.8915</span></span><br></pre></td></tr></table></figure><p><img src="http://sklearn.apachecn.org/cn/0.19.0/_images/sphx_glr_plot_logistic_l1_l2_sparsity_001.png" alt=""></p><p><strong>结果分析：</strong></p><ul><li>C 值代表正则化强度，必须为正值，且越接近零，正则化强度越大，指数级缩放。</li><li>无论正则化强度怎么变，L2 正则化的系数矩阵稀疏度不变，而 L1 正则化系数矩阵稀疏度和正则化强度呈正相关。</li><li>L2 正则化相比 L1 正则化能保留更多的细节信息，在正则化强度较大是相对表现更好一些。</li></ul><p><br></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>“liblinear” 应用了<strong>坐标下降算法</strong>（Coordinate Descent, <strong>CD</strong>），并基于 scikit-learn 内附的高性能 C++ 库 <a href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/" target="_blank" rel="noopener">LIBLINEAR library</a> 实现。不过 CD 算法训练的模型不是真正意义上的多分类模型，而是基于 “<strong>one-vs-rest</strong>” 思想分解了这个优化问题，为每个类别都训练了一个二元分类器。因为实现在底层，所以求解器的 <a href="http://sklearn.apachecn.org/cn/0.19.0/modules/generated/sklearn.linear_model.LogisticRegression.html#sklearn.linear_model.LogisticRegression" target="_blank" rel="noopener"><code>LogisticRegression</code></a> 实例对象表面上看是一个多元分类器。 <a href="http://sklearn.apachecn.org/cn/0.19.0/modules/generated/sklearn.svm.l1_min_c.html#sklearn.svm.l1_min_c" target="_blank" rel="noopener"><code>sklearn.svm.l1_min_c</code></a> 可以计算使用 L1 罚项时 C 的下界，以避免模型为空（即全部特征分量的权重为零）。</p><ul><li>对于<strong>小数据集</strong>，应该使用 ‘liblinear’，而在<strong>大（高维度）数据集</strong>上使用 ‘sag’ 或 ‘saga’ 会快一些；</li><li>对于<strong>多分类</strong>问题，<strong>‘liblinear’ 只能处理 one-vs-rest 的情形</strong>，只有 ‘newton-cg’, ‘sag’, ‘saga’ 和 ‘lbfgs’ 可以<strong>计算多项损失</strong>，这些求解器的参数 <a href="http://sklearn.apachecn.org/cn/0.19.0/modules/linear_model.html#id34" target="_blank" rel="noopener"><code>multi_class</code></a>设为 “multinomial” 即可训练一个<strong>真正的多项式</strong> logistic 回归 [<a href="http://sklearn.apachecn.org/cn/0.19.0/modules/linear_model.html#id39" target="_blank" rel="noopener">link</a>] ，其预测的概率比默认的 “one-vs-rest” 设定<strong>更为准确</strong>。</li><li>‘newton-cg’, ‘lbfgs’ 和 ‘sag’ 算法<strong>只能使用 L2 罚项</strong>，而 ‘liblinear’ 和 ‘saga’ 使用 L1 罚项。</li><li>“sag” 求解器基于<strong>平均随机梯度下降算法（Stochastic Average Gradient descent）</strong> [<a href="http://sklearn.apachecn.org/cn/0.19.0/modules/linear_model.html#id40" target="_blank" rel="noopener">link</a>]。在大数据集上的表现更快，大数据集指样本量大且特征数多。</li><li>“saga” 求解器 [<a href="http://sklearn.apachecn.org/cn/0.19.0/modules/linear_model.html#id41" target="_blank" rel="noopener">link</a>] 是 “sag” 的一类变体，它支持<strong>非平滑（non-smooth）</strong>的 L1 正则选项 <code>penalty=&quot;l1&quot;</code> 。因此对于<strong>稀疏</strong>多项式 logistic 回归 ，往往选用该求解器。</li><li><strong>“saga” 一般都是最佳的选择</strong>，但出于一些历史遗留原因默认的是 “liblinear” 。</li><li>请注意 ‘sag’ 和 ‘saga’ 快速收敛的性质仅在具有差不多大小的 feature 数值时得到保证（译者注：即<strong>所有 feature 差不多大</strong>）。你可以通过 sklearn.preprocessing 来对你的数据进行<strong>预处理</strong>。</li></ul><p>继续完善……</p><p><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/linear_model.html#logistic" target="_blank" rel="noopener">http://sklearn.apachecn.org/cn/0.19.0/modules/linear_model.html#logistic</a></p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性回归 </tag>
            
            <tag> sklearn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Boosting 和 XGBoost 和 LightGBM 和其他</title>
      <link href="/2018/12/02/lightbgm/"/>
      <content type="html"><![CDATA[<p>本文记录学习 Boosting 过程中的一些笔记。</p><a id="more"></a><h2 id="集成学习和回归树"><a href="#集成学习和回归树" class="headerlink" title="集成学习和回归树"></a>集成学习和回归树</h2><h3 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h3><p>Boosting 是集成学习中的一支，指的是由多个相关联的决策树联合决策，也就是说，<strong>下一棵决策树输入样本会与前面决策树的训练和预测相关</strong>，将弱学习器提升为强学习器的集成方法来提高预测精度。</p><p>与之对比的是Bagging（如 random foreast 随机森林）算法，即通过自助采样的方法生成众多并行式的分类器，通过“少数服从多数”的原则来确定最终的结果，<strong>各个决策树是独立的</strong>、每个决策树在样本堆里随机选一批样本，随机选一批特征进行独立训练，各个决策树之间没有关系。</p><h3 id="迭代策略"><a href="#迭代策略" class="headerlink" title="迭代策略"></a>迭代策略</h3><p><strong>贪心策略 + 二次最优化（损失函数不是二次函数泰勒展开）</strong>求回归树的参数：（1）选取哪个feature分裂节点；（2）节点的预测值。</p><h3 id="停止迭代策略"><a href="#停止迭代策略" class="headerlink" title="停止迭代策略"></a>停止迭代策略</h3><p>（1）当引入的<strong>分裂带来的增益小于一个阀值</strong>时，类似预剪枝；</p><p>（2）当树达到最大深度时，树太深容易过渡学习局部样本导致 <strong>过拟合</strong>；</p><p>（3）当样本权重和小于设定阈值时（一个叶子节点样本太少了），同样防止过拟合</p><h3 id="梯度提升"><a href="#梯度提升" class="headerlink" title="梯度提升"></a>梯度提升</h3><p>梯度提升（Gradient Boosting）。</p><p>首先需要明确，GB本身是一种理念而非一个具体的算法，其基本思想为：沿着<strong>梯度</strong>方向，构造一系列的弱分类器函数，<strong>并以一定权重组合起来</strong>，形成最终决策的强分类器。</p><p>那么这一系列的弱分类器是怎么样形成的呢？GBDT的做法是：每一棵树所学习的是之前所有树<strong>结论和的残差</strong>，这个残差就是一个加预测值后能得真实值的累加量。</p><h3 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h3><p>回归树（Regression Decistion Tree）的运行流程与分类树基本类似，但有以下两点不同之处：</p><ul><li>第一，回归树的每个节点得到的是一个<strong>预测值而非分类树式的样本计数</strong>，假设在某一棵树的某一节点使用了年龄进行分枝（并假设在该节点上人数&gt;1），那么这个预测值就是属于这个节点的所有人年龄的<strong>平均值</strong>。</li><li>第二，在分枝节点的选取上，回归树并<strong>没有选用最大熵值</strong>来作为划分标准，而是<strong>使用了最小化均方差</strong>，即<img src="http://www.zhihu.com/equation?tex=%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7B%7D+%28x_i-%5Cbar%7Bx%7D+%29%5E2%7D%7Bn%7D+" alt="\frac{\sum_{i=1}^{n}{} (x_i-\bar{x} )^2}{n}">。这很好理解，被预测出错的次数越多，错的越离谱，均方差就越大，通过最小化均方差也就能够找到最靠谱的分枝依据。</li></ul><h2 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h2><p>GB算法中最典型的基学习器是<strong>决策树</strong>，尤其是<strong>CART</strong>，正如名字的含义，GBDT是GB和DT的结合。要注意的是这里的决策树是<strong>回归树</strong>，GBDT中的决策树是个弱模型，深度较小一般不会超过5，叶子节点的数量也不会超过10，对于生成的每棵决策树乘上比较小的缩减系数（学习率&lt;0.1），有些GBDT的实现加入了随机抽样（subsample 0.5&lt;=f &lt;=0.8）<strong>提高模型的泛化能力</strong>。通过<strong>交叉验证</strong>的方法选择最优的参数。因此GBDT实际的核心问题变成怎么基于<img src="https://upload.wikimedia.org/math/2/b/b/2bbe4b0725baed85eae8dbbb20360ea6.png" alt="\{(x_i, r_{im})\}_{i=1}^n">使用CART回归树生成<img src="https://upload.wikimedia.org/math/7/f/d/7fd32efb7a21cc484be23d1015ee074e.png" alt="\! h_m(x)">？</p><h2 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h2><h3 id="XGBoost-1"><a href="#XGBoost-1" class="headerlink" title="XGBoost"></a>XGBoost</h3><p><strong>XGBoost</strong>是Gradient Boosting Machine的一个c++实现，并在原有的基础上加以改进，从而极大地提升了模型训练<strong>速度和预测精度</strong>。可以说，XGBoost是Gradient Boosting的高效实现。</p><h3 id="XGBoost-的主要优化"><a href="#XGBoost-的主要优化" class="headerlink" title="XGBoost 的主要优化"></a>XGBoost 的主要优化</h3><ul><li>在CART基分类器的基础上还<strong>支持线性分类器</strong>（gblinear），此时XGBoost相当于带<img src="https://www.zhihu.com/equation?tex=L_1" alt="L_1">和<img src="https://www.zhihu.com/equation?tex=L_2" alt="L_2">正则化项的Logistics回归（分类问题）或者线性回归（回归问题）</li><li>在目标函数里加入了<strong>正则项</strong>，用于控制模型的复杂度，防止过拟合。</li><li>传统的GBDT在优化时只用到一阶导数，XGBoost则<strong>对目标函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。</strong></li><li>XGBoost工具支持自定义代价函数，只要函数可一阶和二阶求导。</li><li><strong>支持并行化</strong>，选择最佳分裂点进行枚举的时候并行，<strong>同层级节点</strong>内选择最佳分裂点，候选分裂点计算增益用多线程并行。</li><li><p><strong>针对缺失数据的算法</strong>，分别假设特征缺失的样本属于右子树和左子树，而且<strong>只在不缺失的样本上迭代</strong>，分别计算缺失样本属于右子树和左子树的增益，选择增益最大的方向为缺失数据的默认方向。</p></li><li><p>可实现后剪枝</p></li><li><p>交叉验证，方便选择最好的参数，early stop，比如你发现30棵树预测已经很好了，不用进一步学习残差了，那么停止建树。</p></li><li><p><strong>列采样（column subsampling）</strong>，随机森林的套路，不仅能降低过拟合，还能减少计算。</p></li><li><p>Shrinkage（缩减），XGBoost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，<strong>让后面有更大的学习空间</strong>。实际应用中，一般把<strong>eta设置得小一点</strong>，然后<strong>迭代次数设置得大一点</strong>。</p></li><li>xgboost还支持设置<strong>样本权重</strong>，这个权重体现在梯度g和二阶梯度h上，是不是有点adaboost的意思，重点关注某些样本</li></ul><h2 id="LightGBM"><a href="#LightGBM" class="headerlink" title="LightGBM"></a>LightGBM</h2><p>LightGBM 是一个梯度 boosting 框架，使用基于学习算法的决策树。它可以说是分布式的，高效的，它有以下优势：</p><ul><li>更快的训练效率</li><li>低内存使用</li><li>更好的准确率</li><li>支持并行学习</li><li>可处理大规模数据</li></ul><p><a href="http://lightgbm.apachecn.org/cn/latest/Features.html" target="_blank" rel="noopener">LightGBM - 中文文档</a></p><p><a href="https://www.kaggle.com/mlisovyi/lightgbm-vs-xgboost-sklearn-api" target="_blank" rel="noopener">应用示例 - Kaggle</a></p><p><strong>其他参考资料：</strong></p><ul><li><a href="https://blog.csdn.net/github_38414650/article/details/76061893" target="_blank" rel="noopener">通俗、有逻辑的写一篇说下Xgboost的原理，供讨论参考</a></li><li><a href="https://blog.csdn.net/LegenDavid/article/details/78904353" target="_blank" rel="noopener">GBDT和XGboost介绍</a></li><li><a href="https://www.cnblogs.com/wxquare/p/5541414.html" target="_blank" rel="noopener">一步一步理解GB、GBDT、xgboost</a></li></ul>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集成学习 </tag>
            
            <tag> 决策树 </tag>
            
            <tag> Boosting </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多元线性回归基础</title>
      <link href="/2018/12/02/linear_model/"/>
      <content type="html"><![CDATA[<p>对应 “西瓜书” 3.1-3.3 内容。</p><a id="more"></a><p><br></p><h2 id="从线性回归开始讲起"><a href="#从线性回归开始讲起" class="headerlink" title="从线性回归开始讲起"></a>从线性回归开始讲起</h2><h3 id="构造误差函数"><a href="#构造误差函数" class="headerlink" title="构造误差函数"></a>构造误差函数</h3><p>线性回归优化目标：</p><p>$ f(x _ i) = w x _ i  + b $，使得 $f(x _ i)  \to y _ i $</p><p>用 $ w ^ { \star } $ , $ b ^ { \star } $ 表示 $ w $ 和 $ b $ 的解，有（$ x $ 上的差值平方为固定项）：</p><p>$\begin{aligned} \left( w ^ { \star } , b ^ { \star } \right) &amp; = \underset { ( w , b ) } { \arg \min } \sum _ { i = 1 } ^ { m } \left( f \left( x _ { i } \right) - y _ { i } \right) ^ { 2 } \\ &amp; = \underset { ( w , b ) } { \arg \min } \sum _ { i = 1 } ^ { m } \left( y _ { i } - w x _ { i } - b \right) ^ { 2 } \end{aligned}$</p><h3 id="偏导求解"><a href="#偏导求解" class="headerlink" title="偏导求解"></a>偏导求解</h3><p>基于<strong>均方误差（欧氏距离 Euclidean distance）</strong>最小化来进行模型求解的方法称为“<strong>最小二乘法</strong>”（least square method），求解过程称为模型的最小二乘<strong>参数估计</strong>（parameter estimation）。</p><p>求解通过将待优化的目标函数对两参数分别<strong>求偏导</strong>得到：</p><p>$\begin{aligned} \frac { \partial E _ { ( w , b ) } } { \partial w } &amp; = 2 \left( w \sum _ { i = 1 } ^ { m } x _ { i } ^ { 2 } - \sum _ { i = 1 } ^ { m } \left( y _ { i } - b \right) x _ { i } \right) \\ \frac { \partial E _ { ( w , b ) } } { \partial b } &amp; = 2 \left( m b - \sum _ { i = 1 } ^ { m } \left( y _ { i } - w x _ { i } \right) \right) \end{aligned}$</p><p>令以上两式为 0，可得 $w$ 和 $b$ 的<strong>最优闭式（closed-form）解</strong>：</p><p>$\begin{aligned} w &amp; = \frac { \sum _ { i = 1 } ^ { m } y _ { i } \left( x _ { i } - \overline { x } \right) } { \sum _ { i = 1 } ^ { m } x _ { i } ^ { 2 } - \frac { 1 } { m } \left( \sum _ { i = 1 } ^ { m } x _ { i } \right) ^ { 2 } }, \\ b &amp; = \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \left( y _ { i } - w x _ { i } \right) \end{aligned}$</p><blockquote><p><strong>解析解：</strong>因变量由自变量所表示的函数解析式，它是一个解析式，换句话说就是用参数表示的解。</p><p><strong>数值解：</strong>把各自的参数值自变量的值都带入到解析式中得到数值</p><p><strong>闭式解：</strong>解析解为一封闭形式（closed-form）的函数，因此对任一独立变量，我们皆可将其带入解析函数求得正确的相依变量。因此，解析解也被称为闭式解（closed-form solution）。</p></blockquote><p><br></p><h2 id="推广：多元线性回归"><a href="#推广：多元线性回归" class="headerlink" title="推广：多元线性回归"></a>推广：多元线性回归</h2><h3 id="同样的构造"><a href="#同样的构造" class="headerlink" title="同样的构造"></a>同样的构造</h3><p>多元线性回归（multivariate linear regression）的一般表达形式为：</p><p>$f \left( \boldsymbol { x } _ { i } \right) = \boldsymbol { w } ^ { \mathrm { T } } \boldsymbol { x } _ { i } + b$</p><p>类似地，用“最小二乘法”进行估计。</p><p>为便于讨论，我们把 $w$ 和 $b$ 吸收入向量形式 $\hat { \boldsymbol { w } } = ( \boldsymbol { w } ; b )$，相应的，把数据集 $D$ 表示为一个 <code>m×(d+1)</code>大小的矩阵 $\mathrm X$，其中每行对应于一个示例，该行前 d 个元素对应于示例的 d 个属性值，最后一个元素恒置为1，即：</p><p>$\mathbf { X } = \left( \begin{array} { c c c c c } { x _ { 11 } } &amp; { x _ { 12 } } &amp; { \dots } &amp; { x _ { 1 d } } &amp; { 1 } \\ { x _ { 21 } } &amp; { x _ { 22 } } &amp; { \dots } &amp; { x _ { 2 d } } &amp; { 1 } \\ { \vdots } &amp; { \vdots } &amp; { \ddots } &amp; { \vdots } &amp; { \vdots } \\ { x _ { m 1 } } &amp; { x _ { m 2 } } &amp; { \dots } &amp; { x _ { m d } } &amp; { 1 } \end{array} \right) = \left( \begin{array} { c c } { x _ { 1 } ^ { \mathrm { T } } } &amp; { 1 } \\ { x _ { 2 } ^ { \mathrm { T } } } &amp; { 1 } \\ { \vdots } &amp; { \vdots } \\ { x _ { m } ^ { \mathrm { T } } } &amp; { 1 } \end{array} \right)$</p><p>把标记也写成向量 $y = (y_1;y_2;…y_m)$ 的形式，于是有：</p><p>$\hat { \boldsymbol { w } } ^ { * } = \underset { \boldsymbol { \boldsymbol { w } } } { \arg \min } ( \boldsymbol { y } - \mathbf { X } \hat { \boldsymbol { w } } ) ^ { \mathrm { T } } ( \boldsymbol { y } - \mathbf { X } \hat { \boldsymbol { w } } )$</p><h3 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h3><blockquote><p> 一些矩阵求导相关资料：</p><ul><li><a href="https://blog.csdn.net/crazy_scott/article/details/80557814" target="_blank" rel="noopener">矩阵求导法则与性质</a></li><li><a href="https://blog.csdn.net/daaikuaichuan/article/details/80620518" target="_blank" rel="noopener">矩阵求导、几种重要的矩阵及常用的矩阵求导公式</a></li><li><a href="/downloads/matrix+vector+derivatives+for+machine+learning.pdf">机器学习中的矩阵微分</a></li><li><a href="https://www.youtube.com/watch?v=i6fqfH5hx60&amp;list=PL3Amm6NFidS54biorMUUSRHrT2kwYDXYF" target="_blank" rel="noopener">How to differentiate with respect to a vector（含推导过程）</a></li></ul></blockquote><p>令 $E _ { \hat { \boldsymbol { w } } } = ( \boldsymbol { y } - \mathbf { X } \hat { \boldsymbol { w } } ) ^ { \mathrm { T } } ( \boldsymbol { y } - \mathbf { X } \hat { \boldsymbol { w } } )$，</p><p>对 $\hat w$ 求导得到：</p><p>$\begin{aligned} \frac { \partial E _ { \hat { \boldsymbol { w } } } } { \partial \hat { \boldsymbol { w } } } = 2 \mathbf { X } ^ { \mathrm { T } } ( \mathbf { X } \hat { \boldsymbol { w } } - \boldsymbol { y } ) \end{aligned}$</p><p>令上式为零可得 $\hat w$ 的闭式最优解。</p><p>但是涉及<strong>矩阵逆</strong>的计算，需要讨论是否满秩的情形，讨论过程详见 “西瓜书” P56。</p><p>大量现实任务中矩阵 $X$ 是<strong>不满秩</strong>的（比如生物芯片数据，特征数远多于样本数），此时可以解出多个 $\hat w$，均能使均方误差最小化，输出值的选择将由算法确定。</p><p>常见的做法是<strong>引入正则（regularization）项</strong>。</p><p><br></p><h2 id="进一步推广：广义线性模型"><a href="#进一步推广：广义线性模型" class="headerlink" title="进一步推广：广义线性模型"></a>进一步推广：广义线性模型</h2><p>我们还可以将原线性回归方程的<strong>值域映射</strong>到另一个值空间，也即更一般地，考虑<strong>单调可微函数</strong> $g(·)$，令：</p><p> $y = g^{-1}(\mathbf { w}^ \mathrm { T } \mathbf { x}+b)$</p><p>这样得到的模型称为<strong>“广义线性模型”（generalized linear model）</strong>，其中，函数 g 称为<strong>“联系函数”（link function）</strong>。</p><h3 id="对数几率函数"><a href="#对数几率函数" class="headerlink" title="对数几率函数"></a>对数几率函数</h3><p>对于样例 $( \boldsymbol { x } , y ) , y \in \mathbb { R }$，</p><p>若将 $y$ 视为样本 $\boldsymbol x$ 作为正例的可能性，则 $1-y$ 是其范例概率，二者比值 $\frac {y} {1-y}$ 称为<strong>“几率”（odd）</strong>，其对数值 $ln \frac{y}{1-y}$ 为“对数几率”（亦称 <strong>logit</strong>）。</p><h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><blockquote><p>极大似然估计（Maximum likelihood estimation）[<a href="https://en.wikipedia.org/wiki/Maximum_likelihood_estimation" target="_blank" rel="noopener">wikipedia</a>]</p></blockquote><p>若将 $y$ 视为<strong>类后验概率估计</strong> $p(y=1|x)$，则有：</p><p>$\begin{aligned} ln \frac {p(y=1|x)}{p(y=0|x)} = \boldsymbol {w}^{ \mathrm T} \boldsymbol {x} + b \end{aligned} $</p><p>对于给定数据集 $\left\{ \left( \boldsymbol { x } _ { i } , y _ { i } \right) \right\} _ { i = 1 } ^ { m }$，有</p><p><strong>似然函数：</strong><br>$\ell ( \boldsymbol { w } , b ) = \sum _ { i = 1 } ^ { m } \ln p \left( y _ { i } | \boldsymbol { x } _ { i } ; \boldsymbol { w } , b \right)$</p><p><strong>限制条件：</strong><br>$p \left( y _ { i } | \boldsymbol { x } _ { i } ; \boldsymbol { w } , b \right) = y _ { i } p _ { 1 } \left( \hat { \boldsymbol { x } } _ { i } ; \boldsymbol { w } , b \right) + \left( 1 - y _ { i } \right) p _ { 0 } \left( \hat { \boldsymbol { x } } _ { i } ; \boldsymbol { w } , b \right)$</p><h3 id="凸优化"><a href="#凸优化" class="headerlink" title="凸优化"></a>凸优化</h3><p>令 $ \boldsymbol \beta = ( \boldsymbol w;b)$，</p><p>最大化原似然函数相当于最小化以下函数：</p><p>$\begin{aligned} \ell(\boldsymbol \beta) = \sum _ { i = 1 } ^ { m } (-y_i \boldsymbol \beta ^ {\mathrm T} \hat {\boldsymbol x} _ i + \ln (1+e^{\boldsymbol \beta ^ {\mathrm T} \hat {\boldsymbol x} _ i})) \end{aligned} $</p><p>上式是关于 $\boldsymbol \beta$  的高阶可导连续凸函数，根据<strong>凸优化理论</strong>[Boyd and Vandenberghe，2004]，经典的数值优化算法如梯度下降法（gradient descent method）、牛顿法（Newton method）等都可求得其最优解，于是就得到：</p><p>$\begin{aligned} \boldsymbol \beta ^ {\star} = \underset { \boldsymbol \beta } { \arg \min }  \ell ( \boldsymbol \beta) \end{aligned}$</p><p>并可求其一阶和二阶导数（详见 “西瓜书” P60）。</p><h2 id="伪代码算法描述"><a href="#伪代码算法描述" class="headerlink" title="伪代码算法描述"></a>伪代码算法描述</h2><p><strong>输入：</strong> </p><p>训练集 <img src="https://private.codecogs.com/gif.latex?D%3D%5Cleft%20%5C%7B%20%28x_%7Bi%7D%2Cy_%7Bi%7D%29%20%5Cright%20%5C%7D_%7Bi%3D1%7D%5E%7Bm%7D" alt="">，<img src="https://private.codecogs.com/gif.latex?x_%7Bi%7D%3D%28x_%7Bi1%7D%2Cx_%7Bi2%7D%2C...%2Cx_%7Bin%7D%29" alt="x_{i}=(x_{i1},x_{i2},...,x_{in})"> ，学习率<img src="https://private.codecogs.com/gif.latex?%5Calpha" alt="\alpha">。</p><p><strong>过程：</strong></p><p><strong>1.</strong>  由对数似然得到代价函数 $\ell(\boldsymbol \beta)$</p><p>（采用梯度下降等算法对代价函数进行多轮迭代）</p><p><strong>2.</strong>  初始化 $\boldsymbol w$ 和 $\boldsymbol \beta$（例如初始化为全1矩阵）<br><strong>3.</strong>  <strong>repeat:</strong><br><strong>4.</strong>         <strong>for random</strong>  <img src="https://private.codecogs.com/gif.latex?%28x_i%2Cy_i%29%5Cin%20D" alt="(x_i,y_i)\in D"> <strong>do</strong><br><strong>5.</strong>             数值优化（牛顿法<img src="C:\Users\Administrator\AppData\Local\Temp\1544108400421.png" alt="1544108400421">）<br><strong>6.</strong>  <strong>util:</strong> 迭代次数完成或下降幅度小于阈值</p><p><strong>输出：</strong></p><p>$\boldsymbol \beta$ 的有限次迭代下的最优解，同时也得到了 $\boldsymbol w$ 和 $\boldsymbol \beta$ 的最优解。</p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS/CSS 学习笔记</title>
      <link href="/2018/08/21/JS_CSS_stuff/"/>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="Advanced-CSS-selectors"><a href="#Advanced-CSS-selectors" class="headerlink" title="Advanced CSS selectors"></a>Advanced CSS selectors</h2><p><a href="https://codepen.io/kevinpowell/pen/MQYGwY" target="_blank" rel="noopener">https://codepen.io/kevinpowell/pen/MQYGwY</a></p>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自编码器、PCA和白化</title>
      <link href="/2018/08/07/data-washing/"/>
      <content type="html"><![CDATA[<blockquote><p>全文转自 <a href="https://blog.csdn.net/immcrr/article/details/80293146" target="_blank" rel="noopener"><a href="https://blog.csdn.net/immcrr" target="_blank" rel="noopener">immcrr的博客</a></a></p></blockquote><a id="more"></a><h2 id="自编码器-Autoencoder"><a href="#自编码器-Autoencoder" class="headerlink" title="自编码器 Autoencoder"></a>自编码器 Autoencoder</h2><p>自编码器就是一个全连接网络，就简单的三层，一个输入一个输出一个隐藏层。也可以把自编码器级联，形成多层的结构。自编码器的目的就是训练一个恒等映射，输入进去什么，就期望输出什么。简单的恒等映射没有意义，有意义的在于它的隐藏层神经元的个数往往和输入层不同。如果少于输入个数，这就相当于一个特征提取和重构的过程（降维）；如果隐藏层个数大于输入层个数，此时如果还能再加上稀疏性约束，则就相当于稀疏编码。</p><p>如果是前者，Loss直接是输入和输出的的差，比如平方误差之类。</p><p>如果是后者，得加上稀疏性约束（稀疏性即提取出来的特征中，大量系数为零，非零系数尽量少）。为约束稀疏性，手段可以如下（来自UFLDL教程）。先定义隐藏层第 $j$ 单元的平均激活（在训练集上取平均）如下，其中$x^i$是训练集第$i$个样本，一共有$m$个样本。</p><script type="math/tex; mode=display">\hat{\rho}_j = \frac{1}{m} \sum_{i=0}^{m}a_j^2(\boldsymbol{x}^i)</script><p>再引入一个接近于零的所谓的稀疏性参数$ρ$，约束为$\hat{ρ}_j$接近$ρ$。从而此时Loss可以定义为</p><script type="math/tex; mode=display">J(W,b)=J_0(W,b)+β \sum_{j}^{s_2}KL(ρ|\hatρ_j)</script><p>右边第一项代表重构误差，第二项代表稀疏惩罚。$KL(⋅)$是相对熵，$\hat{ρ}_j$ 离$ρ$越远则这个惩罚项越大；参数$β$用于权衡。 </p><h2 id="稀疏编码-Sparse-Coding"><a href="#稀疏编码-Sparse-Coding" class="headerlink" title="稀疏编码 Sparse Coding"></a>稀疏编码 Sparse Coding</h2><p>上面的自编码器，隐层单元数量大于输入层时，如果再有稀疏性的约束，则相当于稀疏编码。但是因为激活函数的非线性等等问题，总的来说，它不是线性的变换。而一般说的稀疏编码、稀疏表示，大多数都是线性变换。就线性变换而言，稀疏编码是在寻找超完备的一组基$\{ϕi\},i=1,2,⋯,k$，使得输入向量表示成基的线性组合（这里不要求基的正交性）。</p><script type="math/tex; mode=display">\boldsymbol{x}=\sum^ia_i\phi_i</script><p>这里$a_i$是稀疏表示稀疏，而非激活函数值。因为这组基是超完备的，所以基的个数大于输入信号的维数,$k&gt;n$。训练集样本容量设为$m$则问题表达为 </p><script type="math/tex; mode=display">\mathop{\text{argmin}}\limits_{a^{(j)}_i,\{\phi_i\}}\sum^{m}_{j=1}\left(\Big|\Big|\boldsymbol{x}^j-\sum^{k}_{i=1}a^{(j)}_j\phi_i\Big|\Big|^2+\lambda\sum^{k}_{i=1}S(a^{(j)}_i)\right)</script><p>其中$S(⋅)$是一个函数，负责惩罚明显大于零的系数，从而保证稀疏性，$λ$负责权衡。上面的形式有一个漏洞，即为了减小在新基上的分量（从而迎合稀疏惩罚），我可以把基变大，把其上的分量$a$减小，不改变最终结果而又使得上面目标函数变小。为了弥补，再加入约束来控制基，不让它太大，例如约束为$||ϕi||&lt;Ci$. </p><h2 id="PCA-主成分分析"><a href="#PCA-主成分分析" class="headerlink" title="PCA 主成分分析"></a>PCA 主成分分析</h2><p>PCA具体推导就不写了，也不说方差最大化，或者拉格朗日法求驻点的步骤。只简单总结一下，如果从协方差矩阵对角化的角度来看，事情会怎么样。</p><p>$n$维随机变量$x$每个元素的均值设为零。则其协方差矩阵的第$(i,j)$元为$Cov(xi,xj)$根据协方差定义，它等于$E(x_ix_j)-E(x_i)E(x_j)=E(x_ix_j)$，所以$m$个矩阵的平均$\frac{1}{m}\sum^\limits{i}\boldsymbol{x}^{(i)}\boldsymbol{x}^{(i)T}$正好是协方差矩阵的无偏估计。根据协方差矩阵的意义，如果其第$(i,j)$元素为零，则说明$x_i$和$x_j$不相关。PCA就是要让协方差矩阵的非对角元全部为零（对角元没法搞成零，那是方差），从而使得信号$\boldsymbol{x}$的任意两个维度都不相关，并在此基础上进行维度压缩。</p><p>要对角化一个矩阵，标准手段是求特征值和特征向量，然后在其特征空间中，这个矩阵就自动对角化了。PCA这里也一样，求协方差矩阵的特征分解，然后把特征向量作为新的一组基，把原来的信号空间变换到协方差矩阵的特征空间中，这时协方差矩阵是对角化的形式。</p><p>然后开始降维，利用一个结论：协方差矩阵的越大的特征值对应的特征向量指向的方向是数据弥散越厉害的方向。降维就是要剔除几个基，找到一个子空间，在这个子空间中数据尽可能地保留。所以如果要尽量保留原数据分布地降维，则优先丢弃特征值小的特征向量。剔除以后，得到子空间，降维的操作就是把原数据往这个子空间中投影。</p><h2 id="PCA白化"><a href="#PCA白化" class="headerlink" title="PCA白化"></a>PCA白化</h2><p>PCA白化目的就是得到对角的协方差矩阵后，进一步使其变成单位矩阵。注意到对角的协方差矩阵的对角元就是特征值的排列，所以要使其变成单位矩阵，只要每个对角元$λi$除以他自己（特征值）就可以了，但是一个矩阵的特征值是确定的，不能变，所以直接改变投影后的信号$\boldsymbol{x}$的每个分量，每个分量$xi$乘以$\frac{1}{\sqrt{\lambda_i}}$即可。</p><p>在UFLDL的教程中，使用了二维数据为例，形象一点，可以把二维数据弥散最大的方向与其正交方向视为一个椭圆的长轴方向与短轴方向。无降维的PCA相当于把这个斜着的椭圆旋转摆正。而PCA白化则相当于把这个椭圆两个轴进行缩放，使其变成圆。</p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 基础</title>
      <link href="/2018/08/05/JavaScript-1/"/>
      <content type="html"><![CDATA[<p>数据类型、对象从属的判断、类属性和实例属性、严格模式、属性读写、属性标签、数组、上下文管理、属性标签、函数属性、闭包、继承。</p><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>number</li><li>string</li><li>boolean</li><li>null</li><li>undefined</li><li>Object<ul><li>Function</li><li>Array</li><li>Date</li><li>Number</li><li>…</li></ul></li></ul><h2 id="对象从属的判断"><a href="#对象从属的判断" class="headerlink" title="对象从属的判断"></a>对象从属的判断</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">typeof</span> <span class="number">123</span></span><br><span class="line">- <span class="string">"number"</span></span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) <span class="keyword">instanceof</span> <span class="built_in">Number</span></span><br><span class="line">- <span class="literal">true</span></span><br><span class="line">&gt; <span class="number">123</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span></span><br><span class="line">- <span class="literal">false</span></span><br><span class="line">&gt; [<span class="number">1</span>,<span class="number">2</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span></span><br><span class="line">- <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>*. <code>instanceof</code> 不能跨 <code>window</code> 或  <code>iframe</code> 。</p><h3 id="Object-prototype-toString-apply"><a href="#Object-prototype-toString-apply" class="headerlink" title="Object.prototype.toString.apply()"></a>Object.prototype.toString.apply()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Object</span>.prototype.toString.apply([])</span><br><span class="line">- <span class="string">"[object Array]"</span></span><br></pre></td></tr></table></figure><h2 id="类属性和实例属性"><a href="#类属性和实例属性" class="headerlink" title="类属性和实例属性"></a>类属性和实例属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Foo.prototype.x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line">&gt; obj.x</span><br><span class="line">- <span class="number">1</span></span><br><span class="line">&gt; obj.hasOwnProperty(<span class="string">'x'</span>)</span><br><span class="line">- <span class="literal">false</span></span><br><span class="line">&gt; obj.__prototype__.hasOwnProperty(<span class="string">'x'</span>)</span><br><span class="line">- <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p><code>arguments</code>、<code>eval</code> 均为保留字</p><h2 id="属性读写"><a href="#属性读写" class="headerlink" title="属性读写"></a>属性读写</h2><h3 id="不同的属性读写方式"><a href="#不同的属性读写方式" class="headerlink" title="不同的属性读写方式"></a>不同的属性读写方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line">&gt; obj.x     <span class="comment">// method 1</span></span><br><span class="line">- <span class="number">1</span></span><br><span class="line">&gt; obj[<span class="string">"x"</span>]  <span class="comment">// method 2</span></span><br><span class="line">- <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="链式属性查找"><a href="#链式属性查找" class="headerlink" title="链式属性查找"></a>链式属性查找</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> yz = obj &amp;&amp; obj.y &amp;&amp; obj.y.z</span><br></pre></td></tr></table></figure><h3 id="继承属性和自有属性"><a href="#继承属性和自有属性" class="headerlink" title="继承属性和自有属性"></a>继承属性和自有属性</h3><p><strong>辨析：</strong> <code>in</code> 操作符、<code>hasOwnProperty</code> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">cat.legs = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">&gt; <span class="string">"legs"</span> <span class="keyword">in</span> cat</span><br><span class="line">- <span class="literal">true</span></span><br><span class="line">&gt; <span class="string">"toString"</span> <span class="keyword">in</span> cat</span><br><span class="line">- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历属性时，过滤原型链里的属性</span></span><br><span class="line">&gt; cat.hasOwnProperty(<span class="string">"legs"</span>)</span><br><span class="line">- <span class="literal">true</span></span><br><span class="line">&gt; cat.hasOwnProperty(<span class="string">"toString"</span>)</span><br><span class="line">- <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter() 和 setter()"></a>getter() 和 setter()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    wechat: <span class="string">'mywechat'</span>,</span><br><span class="line">    $age: <span class="literal">null</span>,</span><br><span class="line">    get age()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="number">1997</span>; <span class="comment">// 这一行的 new 非常关键！！</span></span><br><span class="line">    &#125;,</span><br><span class="line">    set age(value)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Property cannot be set.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; person.age</span><br><span class="line">- <span class="number">21</span></span><br><span class="line">&gt; person.age = <span class="number">100</span></span><br><span class="line">- <span class="string">'Property cannot be set.'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个只读对象</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(foo.prototype, <span class="string">'z'</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">1</span>&#125;&#125;);</span><br><span class="line"></span><br><span class="line">&gt; foo.z</span><br><span class="line">- <span class="number">1</span></span><br><span class="line">&gt; foo.z = <span class="number">5</span></span><br><span class="line">&gt; foo.z</span><br><span class="line">- <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="JSON-序列化"><a href="#JSON-序列化" class="headerlink" title="JSON 序列化"></a>JSON 序列化</h3><p><strong>正向序列化：</strong> JSON.stringify（注意奇怪的拼写）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="attr">nullVal</span>:<span class="literal">null</span>, <span class="attr">undefinedVal</span>:<span class="literal">undefined</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">x</span>:<span class="literal">NaN</span>, <span class="attr">y</span>:<span class="literal">Infinity</span>, <span class="attr">z</span>:<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">JSON</span>.stringify(obj1)</span><br><span class="line">- <span class="string">"&#123;"</span>x<span class="string">":1,"</span>y<span class="string">":[1,2,3],"</span>nullVal<span class="string">":null&#125;"</span>   <span class="comment">// 注意：undefine 变量已被删去</span></span><br><span class="line">&gt; <span class="built_in">JSON</span>.stringify(obj2)</span><br><span class="line">- <span class="string">"&#123;"</span>x<span class="string">":null,"</span>y<span class="string">":null,"</span>z<span class="string">":"</span><span class="number">2018</span><span class="number">-07</span><span class="number">-18</span>T16:<span class="number">51</span>:<span class="number">42.611</span>Z<span class="string">"&#125;"</span>   <span class="comment">// 注意：格式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 JSON 格式</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:&#123;</span><br><span class="line">    x:<span class="number">2</span>, <span class="attr">y</span>:<span class="number">3</span>, </span><br><span class="line">    toJSON:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y&#125;   <span class="comment">// 注意：this 的使用，不写有另外的效果</span></span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">JSON</span>.stringify(obj1)</span><br><span class="line">- <span class="string">"&#123;"</span>x<span class="string">":1,"</span>y<span class="string">":5&#125;"</span></span><br></pre></td></tr></table></figure><p><strong>反向序列化：</strong> JSON.parse</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json_string = <span class="string">'&#123;"x":1,"y":[1,2,3],"nullVal":null&#125;'</span></span><br><span class="line">obj = <span class="built_in">JSON</span>.parse(json_string)</span><br><span class="line"></span><br><span class="line">&gt; obj.x</span><br><span class="line">- <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="自定义强制转换规则"><a href="#自定义强制转换规则" class="headerlink" title="自定义强制转换规则"></a>自定义强制转换规则</h3><p><code>toString</code>  和  <code>valueOf</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">obj.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y&#125;  <span class="comment">// 同样需要注意 this 的用法</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="string">"Result"</span> + obj</span><br><span class="line">- <span class="string">"Result 3"</span></span><br><span class="line"></span><br><span class="line">obj.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y + <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line">&gt; +obj            <span class="comment">// 一元操作符强制转换为数字</span></span><br><span class="line">- <span class="number">103</span></span><br><span class="line">&gt; <span class="string">"Result"</span> + obj</span><br><span class="line">- <span class="string">"Result 103"</span>    <span class="comment">// 注意：这里有两次转换</span></span><br></pre></td></tr></table></figure><h2 id="属性标签"><a href="#属性标签" class="headerlink" title="属性标签"></a>属性标签</h2><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p>感觉是个大学问，日后完善</p><p><img src="/var/folders/k5/g9m9b2_x0lg8ttf7wswky1rr0000gn/T/abnerworks.Typora/image-20180719003417900.png" alt="image-20180719003417900"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'property'</span>, &#123;</span><br><span class="line">    value: <span class="number">123</span>, </span><br><span class="line">    configurable: <span class="literal">true</span>,  <span class="comment">// `true` as default =&gt; 决定属性是否可以被 `delete`</span></span><br><span class="line">    writeable: <span class="literal">false</span>,    <span class="comment">// `true` as default</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,    <span class="comment">// `true` as default =&gt; 决定 for in 循环，和是否出现在 Object.keys(obj) 中</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">1</span>&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.propertyIsEnumerable(<span class="string">"property"</span>)</span><br></pre></td></tr></table></figure><h3 id="属性标签探测"><a href="#属性标签探测" class="headerlink" title="属性标签探测"></a>属性标签探测</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;<span class="attr">pro</span>: <span class="literal">true</span>&#125;, <span class="string">'pro'</span>)</span><br><span class="line">- &#123;<span class="attr">value</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="属性标签固定"><a href="#属性标签固定" class="headerlink" title="属性标签固定"></a>属性标签固定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.preventExtenions(obj)</span><br><span class="line"><span class="built_in">Object</span>.seal(obj)</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj)</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="arr-length"><a href="#arr-length" class="headerlink" title="arr.length"></a>arr.length</h3><p>求长，<code>arr.length -= 1</code> 操作可以移除最后一个元素。</p><p>*. delete 操作使得某元素的位置变为 undefined，但数组长度不会变。</p><h3 id="arr-push-arr-pop"><a href="#arr-push-arr-pop" class="headerlink" title="arr.push() / arr.pop()"></a>arr.push() / arr.pop()</h3><p><code>arr.push()</code> 等价于 <code>arr[arr.length]=</code></p><h3 id="arr-unshift-arr-shift"><a href="#arr-unshift-arr-shift" class="headerlink" title="arr.unshift() / arr.shift()"></a>arr.unshift() / arr.shift()</h3><p>在数组头部插入 / 删除</p><h3 id="arr-join"><a href="#arr-join" class="headerlink" title="arr.join()"></a>arr.join()</h3><p>和 python 里的用法反一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeatString</span>(<span class="params">str, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).join(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; repeatString(<span class="string">'ab'</span>, <span class="number">3</span>)</span><br><span class="line">- <span class="string">'ababab'</span></span><br></pre></td></tr></table></figure><h3 id="arr-reverse"><a href="#arr-reverse" class="headerlink" title="arr.reverse()"></a>arr.reverse()</h3><p>同 python，略。</p><h3 id="arr-sort"><a href="#arr-sort" class="headerlink" title="arr.sort()"></a>arr.sort()</h3><p>如果 arr 内的元素是数字，会按照字符串来排序（并不是按大小）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;<span class="keyword">return</span> a-b&#125;)</span><br><span class="line"><span class="comment">// 通过这个方法可以实现数字大小比较（类比 python 的 cmp 函数）</span></span><br></pre></td></tr></table></figure><h3 id="arr-forEach"><a href="#arr-forEach" class="headerlink" title="arr.forEach()"></a>arr.forEach()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x, index, arr</span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="arr-slice"><a href="#arr-slice" class="headerlink" title="arr.slice()"></a>arr.slice()</h3><p>略</p><h3 id="arr-splice-a-b-args"><a href="#arr-splice-a-b-args" class="headerlink" title="arr.splice(a, b, *args)"></a>arr.splice(a, b, *args)</h3><p>从原数组第 a 位起挖去 b 位返回，并重新插入 *args 个元素。</p><h3 id="arr-map-arr-filter-arr-reduce"><a href="#arr-map-arr-filter-arr-reduce" class="headerlink" title="arr.map() / arr.filter() / arr.reduce()"></a>arr.map() / arr.filter() / arr.reduce()</h3><p>同 python，略。</p><h3 id="arr-every-arr-some"><a href="#arr-every-arr-some" class="headerlink" title="arr.every() / arr.some()"></a>arr.every() / arr.some()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">&gt; arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">10</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">- <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="arr-indexOf-a-b-lastIndexOf"><a href="#arr-indexOf-a-b-lastIndexOf" class="headerlink" title="arr.indexOf(a, b) / lastIndexOf()"></a>arr.indexOf(a, b) / lastIndexOf()</h3><p>原数组从左往右（/右往左）的第 b 个元素开始，查找第一个 a 元素的位置。</p><h2 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h2><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p><strong>注意：</strong> js 严格模式下禁用 <code>with</code> 块，可以使用变量来代替。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (<span class="built_in">document</span>.forms[<span class="number">0</span>])&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name.value)</span><br><span class="line">&#125; <span class="comment">// 这是干啥用的？</span></span><br></pre></td></tr></table></figure><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><strong>通常</strong> 指代容器所在的外层空间（爸爸的爸爸）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&gt; obj.func();</span><br><span class="line">- obj <span class="comment">//实际测试得到 &#123;func: ƒ&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;<span class="attr">f</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.a+<span class="keyword">this</span>.b&#125;&#125;</span><br><span class="line">p = <span class="built_in">Object</span>.create(o)</span><br><span class="line">p.a = <span class="number">2</span></span><br><span class="line">p.b = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">&gt; p.f()</span><br><span class="line">- <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="闭包中的-this-指向-window"><a href="#闭包中的-this-指向-window" class="headerlink" title="闭包中的 this 指向 window"></a>闭包中的 this 指向 window</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    a : <span class="number">5</span>,</span><br><span class="line">    b : <span class="number">6</span>,</span><br><span class="line">    sum : <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getA</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;         <span class="comment">// 在window上增加了一个全局变量a</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.a;     <span class="comment">// 此处this = window</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getB</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.b = b;         <span class="comment">//在window上增加了一个全局变量b</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.b;     <span class="comment">// 此处this = window</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getA(a) + getB(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(test.sum(<span class="number">4</span>,<span class="number">3</span>));  <span class="comment">// 7</span></span><br><span class="line">alert(a);              <span class="comment">// 4     </span></span><br><span class="line">alert(b);              <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>在这种情况下，我们希望 getA() 和 getB() 返回的值是 test.a 和 test.b ，但是此时闭包函数（即函数中的函数）getA 和 getB 中 this 并不指向 test 的实例，该怎么办呢？我们不妨试试下面的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    a : <span class="number">5</span>,</span><br><span class="line">    b : <span class="number">6</span>,</span><br><span class="line">    sum : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;    <span class="comment">// 此处this = test的实例</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> self.a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getB</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> self.b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getA() + getB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(test.sum());</span><br><span class="line">alert(a);     <span class="comment">// 此处报错：a is not defined</span></span><br><span class="line">alert(b);    <span class="comment">// 此处报错：a is not defined</span></span><br></pre></td></tr></table></figure><blockquote><p>在 test 对象的 sum 函数中用一个局部变量 self 来保存当前的 this 指针，这样在闭包函数 getA 和 getB 中就能通过 self 变量获取 test 实例的属性了。</p><p>看起来这样就能够解决闭包函数中 this 的问题了，但是，如果调用 sum 函数的并不是 test 的实例呢，这个时候 <code>var self=this</code> 还能起到作用，获取到 test 的实例吗？</p></blockquote><p>为了更方便地改变函数上下文（context）的空间，我们使用 <a href="./JavaScript-1/#call("><code>call()</code></a> / apply()) / <a href="./JavaScript-1/#call("><code>apply()</code></a> / apply()) / <code>bind()</code> 等函数（见下）。</p><h3 id="call-apply"><a href="#call-apply" class="headerlink" title="call() / apply()"></a>call() / apply()</h3><p>这两例中也需要格外注意 <a href="&#39;./JavaScript-1/#this&#39;"><code>this</code></a> 的用法。</p><p><strong>用法：</strong> 调用一个对象的一个方法，以另一个对象替换当前对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b + c + d &#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">2</span>, <span class="attr">b</span>:<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">&gt; add.call(o, <span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">- <span class="number">17</span></span><br><span class="line">&gt; add.apply(o, [<span class="number">5</span>, <span class="number">7</span>]);</span><br><span class="line">- <span class="number">17</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; bar.call(<span class="number">7</span>);</span><br><span class="line">- <span class="string">"[object Number]"</span></span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p><strong>定义：</strong> 将接受多个参数的函数变换成接受一个单一参数（定义时不传参，调用时再传参）。</p><p><strong>说明：</strong> bind() 方法所返回的函数的 length（形参数量）等于原函数的形参数量减去传入 bind() 方法中的实参数量（第一个参数以后的所有参数），因为传入 bind 中的实参都会绑定到原函数的形参。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.a &#125;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;<span class="attr">a</span>: <span class="string">"test"</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">37</span>, <span class="attr">f</span>: f, <span class="attr">g</span>: g&#125;;</span><br><span class="line"></span><br><span class="line">&gt; o.g();</span><br><span class="line">- <span class="string">"test"</span></span><br><span class="line">&gt; o.f();</span><br><span class="line">- <span class="number">37</span> <span class="string">"test"</span></span><br></pre></td></tr></table></figure><h3 id="扩展：高阶实例"><a href="#扩展：高阶实例" class="headerlink" title="*. 扩展：高阶实例"></a>*. 扩展：高阶实例</h3><blockquote><p>本实例以下内容来源：<a href="https://www.cnblogs.com/tingyu-blog/p/6212392.html" target="_blank" rel="noopener">使用call、apply和bind解决js中烦人的this，事件绑定时的this和传参问题</a></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>烦人的this<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> test = &#123;</span></span><br><span class="line"><span class="actionscript">        isSum: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">        sum: <span class="function"><span class="keyword">function</span> <span class="params">(event, a, b)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">this</span>.isSum) &#123; 　　<span class="comment">// this = button，这个时候不会执行alert（a+b）</span></span></span><br><span class="line"><span class="undefined">                alert(a + b);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span></span><br><span class="line"><span class="actionscript">    button.addEventListener(<span class="string">"click"</span>, test.sum, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里我们就能发现问题所在了，当ID为btn的按钮被点击时会触发test.sum函数，但是这个时候的this=button，而且参数a、b如何传入呢?</p><p>这里就能够使用bind函数了，将test.sum函数简化为另一个新的函数，同时传入参数a和b，我们再看看下面的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>this<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> test = &#123;</span></span><br><span class="line"><span class="actionscript">        isSum: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">        sum: <span class="function"><span class="keyword">function</span> <span class="params">(a, b,event)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">this</span>.isSum) &#123;　　<span class="comment">// 此处this=test，this.isSum = true</span></span></span><br><span class="line"><span class="actionscript">                alert(a + b);　　<span class="comment">// 9</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span></span><br><span class="line"><span class="actionscript">    button.addEventListener(<span class="string">"click"</span>, test.sum.bind(test,<span class="number">4</span>,<span class="number">5</span>), <span class="literal">false</span>);  <span class="comment">// 此处test.sum.bind(test,4,5)返回一个新的函数function(event),</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从上面的代码我们可以看到test.sum.bind(test,4,5)返回一个新的函数function(event),test、4、5分别被绑定到test.sum的上下文、参数a、参数b中。<br>当ID为btn的按钮被点击时会触发test.sum函数，此时改函数中的this=test，a=4,b=5。</p><p>这样就可以解决事件绑定时的this以及传参的问题了，包括现在常用js框架中的事件绑定，如jQuery、signals.min.js等等。</p><h3 id="扩展：this-的指向"><a href="#扩展：this-的指向" class="headerlink" title="*. 扩展：this 的指向"></a>*. 扩展：this 的指向</h3><blockquote><p>本实例以下内容来源：<a href="https://www.cnblogs.com/Medeor/p/4983597.html" target="_blank" rel="noopener">js: this,call,apply,bind 总结</a></p></blockquote><p>JavaScript 中的 this 总是指向一个对象，而具体指向那个对象是在运行时基于函数的执行环境动态绑定的，而非函数声明时的环境。实际应用中 this 的指向大致可以分为以下 4 种：</p><ol><li>作为对象的方法调用</li><li>作为普通函数掉用</li><li>构造器调用</li><li>Function.prototype.call 或 Function.prototype.apply 调用, 可以动态地改变出入函数的 this</li></ol><h4 id="作为对象的方法调用时，-this-指向该对象"><a href="#作为对象的方法调用时，-this-指向该对象" class="headerlink" title="作为对象的方法调用时， this 指向该对象"></a>作为对象的方法调用时， this 指向该对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    getA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="keyword">this</span> == obj ); <span class="comment">// true</span></span><br><span class="line">        <span class="built_in">console</span>.log( <span class="keyword">this</span>.a ); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure><h4 id="作为普通函数掉用，this-总是指向全局对象-window"><a href="#作为普通函数掉用，this-总是指向全局对象-window" class="headerlink" title="作为普通函数掉用，this 总是指向全局对象 window"></a>作为普通函数掉用，this 总是指向全局对象 window</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Windows</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">"globalName"</span>;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( getName() ); <span class="comment">// globalNamev</span></span><br></pre></td></tr></table></figure><h4 id="作为构造器调用，指向返回的新对象"><a href="#作为构造器调用，指向返回的新对象" class="headerlink" title="作为构造器调用，指向返回的新对象"></a>作为构造器调用，指向返回的新对象</h4><p>当用 new 运算符调用函数时，该函数总是会返回一个对象，通常情况下，构造函数里的 this 就指向返回的这个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"class"</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="built_in">console</span>.log( obj.name ); <span class="comment">// classv</span></span><br></pre></td></tr></table></figure><p>如果使用 new 调用构造器时，构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我么之前期待的 this。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"class"</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">"other"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// other</span></span><br></pre></td></tr></table></figure><h4 id="再扩展"><a href="#再扩展" class="headerlink" title="*. 再扩展"></a>*. 再扩展</h4><p>最后贴一个我还没看完的似乎很棒的长文：<a href="https://www.jb51.net/article/124024.htm" target="_blank" rel="noopener">详解JS中的this、apply、call、bind(经典面试题)</a></p><h2 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>)</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    </span><br><span class="line">    &gt; <span class="built_in">arguments</span>.length</span><br><span class="line">    - <span class="number">2</span>              <span class="comment">// _实参_ 的个数</span></span><br><span class="line">    &gt; <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line">    - <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    &gt; x</span><br><span class="line">    - <span class="number">0</span>              <span class="comment">// 非严格模式下可以这么改变</span></span><br><span class="line">    &gt; z</span><br><span class="line">    - <span class="string">"undefined"</span></span><br><span class="line">    </span><br><span class="line">    &gt; <span class="built_in">arguments</span>.callee</span><br><span class="line">    - <span class="built_in">Error</span>          <span class="comment">// 非严格模式下为 function foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&gt; foo.length</span><br><span class="line">- <span class="number">3</span>                  <span class="comment">// _实参_ 的个数</span></span><br><span class="line">&gt; foo.name</span><br><span class="line">- <span class="string">"foo"</span></span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>一个典型的错误例子：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">"&lt;div id=div1&gt; aaa &lt;/div&gt;"</span></span><br><span class="line">+<span class="string">"&lt;div id=div2&gt; aaa &lt;/div&gt;&lt;div id=div3&gt; aaa &lt;/div&gt;"</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>+i).</span><br><span class="line">    addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(i);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，控制台输出“1 ↙ 2 ↙ 3”，但点击div时，alert 的内容均为4。</p><p><strong>运用【立即执行】的匿名函数实现预期功能：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">"&lt;div id=div1&gt; aaa &lt;/div&gt;"</span></span><br><span class="line">+<span class="string">"&lt;div id=div2&gt; aaa &lt;/div&gt;&lt;div id=div3&gt; aaa &lt;/div&gt;"</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">    !<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>+i).</span><br><span class="line">        addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="立即执行（IIFE）"><a href="#立即执行（IIFE）" class="headerlink" title="立即执行（IIFE）"></a>立即执行（IIFE）</h3><ul><li>限定变量作用范围（私有属性的实现）；</li><li>避免污染全局变量；</li><li>闭包变量的固定；</li></ul><blockquote><p>以下内容摘自：<a href="https://www.jb51.net/article/127527.htm" target="_blank" rel="noopener">JavaScript中立即执行函数实例详解</a></p></blockquote><p>因为IIFE通常用于匿名函数，这里就用简单的匿名函数作为栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"f"</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>我们发现这里f只是这个匿名函数的一个引用变量，那么既然f()能够调用这个函数，我把f替换成函数本身可以么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"f"</span>); </span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>运行之后得到如下结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught <span class="built_in">SyntaxError</span>: Unexpected token (</span><br></pre></td></tr></table></figure><p>产生这个错误的原因是，Javascript引擎看到function关键字之后，认为后面跟的是函数声明语句，不应该以圆括号结尾。解决方法就是让引擎知道，圆括号前面的部分不是函数定义语句，而是一个表达式，可以对此进行运算，这里区分一下函数声明和函数表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用小括号把函数包裹起来</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"f"</span>);  </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>函数成功执行了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f <span class="comment">//控制台输出</span></span><br></pre></td></tr></table></figure><p>这种情况下Javascript引擎就会认为这是一个表达式，而不是函数声明，当然要让Javascript引擎认为这是一个表达式的方法还有很多：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;   <span class="comment">// 构造器也是立即执行的。</span></span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;() <span class="comment">// 只有传递参数时，才需要最后那个圆括号。</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>函数内层可以访问外层变量，外层不能访问内层。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">' says: hi!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, grade</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);  <span class="comment">// 沿伸原型链</span></span><br><span class="line">Student.prototype.constructor = Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重写</span></span><br><span class="line">Student.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Student '</span>+<span class="keyword">this</span>.name+<span class="string">' says: hi!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; John = <span class="keyword">new</span> Student(<span class="string">'John'</span>, <span class="number">21</span>, <span class="number">5</span>)</span><br><span class="line">&gt; John.sayHi()</span><br><span class="line">- <span class="string">'Student John says: hi!'</span></span><br></pre></td></tr></table></figure><h3 id="实现继承的几种方式"><a href="#实现继承的几种方式" class="headerlink" title="实现继承的几种方式"></a>实现继承的几种方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = Person.prototype;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line"><span class="comment">// 不完全实现</span></span><br><span class="line">Student.constructor = Person();</span><br></pre></td></tr></table></figure><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p><code>return this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassManager</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">ClassManager.prototype.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Class '</span> + str + <span class="string">' added!'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;        <span class="comment">// 非常关键！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">var</span> manager = <span class="keyword">new</span> ClassManager();</span><br><span class="line">&gt; manager.addClass(<span class="string">'class1'</span>).addClass(<span class="string">'class2'</span>).addClass(<span class="string">'class3'</span>);</span><br><span class="line">- Class class1 added!</span><br><span class="line">  Class class2 added!</span><br><span class="line">  Class class3 added!</span><br></pre></td></tr></table></figure><p>上面的代码改写如下，效果完全相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassManager</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Class '</span> + str + <span class="string">' added!'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;        <span class="comment">// 非常关键！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h3><ul><li>/\d\d\d/</li><li>RegExp(‘\d\d\d’)</li></ul><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="regexp">/\d\d\d/</span>.test(<span class="number">123</span>);</span><br><span class="line">- <span class="literal">true</span></span><br><span class="line">&gt; <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\d\d\d'</span>).test(<span class="number">6512345</span>);</span><br><span class="line">- <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="三个-flag"><a href="#三个-flag" class="headerlink" title="三个 flag"></a>三个 flag</h3><ul><li>g - global</li><li>i - ignoreCase</li><li>m - multiline</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\d\d\d/mgi.test(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\d\d\d'</span>, <span class="string">'gim'</span>).test(<span class="number">6512345</span>);</span><br></pre></td></tr></table></figure><h3 id="字符串用法"><a href="#字符串用法" class="headerlink" title="字符串用法"></a>字符串用法</h3><ul><li>search</li><li>test</li><li>replace</li><li>match</li><li>split</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">'aabbbccbbd'</span>.match(<span class="regexp">/b+/</span>);</span><br><span class="line">- [<span class="string">"bbb"</span>, <span class="attr">index</span>: <span class="number">2</span>, <span class="attr">input</span>: <span class="string">"aabbbccbbd"</span>, <span class="attr">groups</span>: <span class="literal">undefined</span>]</span><br><span class="line">&gt; <span class="string">'aabbbccbbd'</span>.match(<span class="regexp">/b+/g</span>);</span><br><span class="line">- [<span class="string">"bbb"</span>, <span class="string">"bb"</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二十三种设计模式及其python实现</title>
      <link href="/2018/06/26/design_pattern_of_python/"/>
      <content type="html"><![CDATA[<blockquote><p>转载自 《<a href="http://www.cnblogs.com/Liqiongyu/" target="_blank" rel="noopener">李琼羽的博客</a>》<br>原文链接：<a href="https://www.cnblogs.com/Liqiongyu/p/5916710.html" target="_blank" rel="noopener">https://www.cnblogs.com/Liqiongyu/p/5916710.html</a><br>我做部分修改和注解</p></blockquote><p>本文源码托管于github：<a href="https://github.com/w392807287/Design_pattern_of_python" target="_blank" rel="noopener">https://github.com/w392807287/Design_pattern_of_python</a></p><p><strong>参考文献：</strong></p><ol><li>《大话设计模式》——吴强</li><li>《Python设计模式》——pythontip.com</li><li>《23种设计模式》——<a href="http://www.cnblogs.com/beijiguangyong/" target="_blank" rel="noopener">http://www.cnblogs.com/beijiguangyong/</a></li></ol><h2 id="设计模式是什么？"><a href="#设计模式是什么？" class="headerlink" title="设计模式是什么？"></a>设计模式是什么？</h2><p>设计模式是经过总结、优化的，对我们经常会碰到的一些编程问题的可重用解决方案。一个设计模式并不像一个类或一个库那样能够直接作用于我们的代码。反之，设计模式更为高级，它是一种必须在特定情形下实现的一种方法模板。设计模式不会绑定具体的编程语言。一个好的设计模式应该能够用大部分编程语言实现(如果做不到全部的话，具体取决于语言特性)。最为重要的是，设计模式也是一把双刃剑，如果设计模式被用在不恰当的情形下将会造成灾难，进而带来无穷的麻烦。然而如果设计模式在正确的时间被用在正确地地方，它将是你的救星。</p><a id="more"></a><p>起初，你会认为“模式”就是为了解决一类特定问题而特别想出来的明智之举。说的没错，看起来的确是通过很多人一起工作，从不同的角度看待问题进而形成的一个最通用、最灵活的解决方案。也许这些问题你曾经见过或是曾经解决过，但是你的解决方案很可能没有模式这么完备。</p><p>虽然被称为“设计模式”，但是它们同“设计“领域并非紧密联系。设计模式同传统意义上的分析、设计与实现不同，事实上设计模式将一个完整的理念根植于程序中，所以它可能出现在分析阶段或是更高层的设计阶段。很有趣的是因为设计模式的具体体现是程序代码，因此可能会让你认为它不会在具体实现阶段之前出现(事实上在进入具体实现阶段之前你都没有意识到正在使用具体的设计模式)。</p><p>可以通过程序设计的基本概念来理解模式：增加一个抽象层。抽象一个事物就是隔离任何具体细节，这么做的目的是为了将那些不变的核心部分从其他细节中分离出来。当你发现你程序中的某些部分经常因为某些原因改动，而你不想让这些改动的部分引发其他部分的改动，这时候你就需要思考那些不会变动的设计方法了。这么做不仅会使代码可维护性更高，而且会让代码更易于理解，从而降低开发成本。</p><p>这里列举了三种最基本的设计模式：</p><ol><li>创建模式，提供实例化的方法，为适合的状况提供相应的对象创建方法。</li><li>结构化模式，通常用来处理实体之间的关系，使得这些实体能够更好地协同工作。</li><li>行为模式，用于在不同的实体建进行通信，为实体之间的通信提供更容易，更灵活的通信方法。</li></ol><p><strong>创建型</strong></p><ol><li>Factory Method（工厂方法）</li><li>Abstract Factory（抽象工厂）</li><li>Builder（建造者）</li><li>Prototype（原型）</li><li>Singleton（单例）</li></ol><p><strong>结构型</strong></p><ol><li>Adapter Class/Object（适配器）</li><li>Bridge（桥接）</li><li>Composite（组合）</li><li>Decorator（装饰）</li><li>Facade（外观）</li><li>Flyweight（享元）</li><li>Proxy（代理）</li></ol><p><strong>行为型</strong></p><ol><li>Interpreter（解释器）</li><li>Template Method（模板方法）</li><li>Chain of Responsibility（责任链）</li><li>Command（命令）</li><li>Iterator（迭代器）</li><li>Mediator（中介者）</li><li>Memento（备忘录）</li><li>Observer（观察者）</li><li>State（状态）</li><li>Strategy（策略）</li><li>Visitor（访问者）</li></ol><h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><h3 id="１．Factory-Method（工厂方法）"><a href="#１．Factory-Method（工厂方法）" class="headerlink" title="１．Factory Method（工厂方法）"></a>１．Factory Method（工厂方法）</h3><p><img src="/images/design-pattern/Factory Method.png" alt="img"></p><p><strong>意图：</strong></p><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使<strong>一</strong>个类的实例化延迟到其子类。</p><p><strong>适用性：</strong></p><p>当一个类不知道它所必须创建的对象的类的时候。</p><p>当一个类希望由它的子类来指定它所创建的对象的时候。</p><p>当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</p><p><strong>实现：</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Factory Method</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaGetter</span>:</span></span><br><span class="line">    <span class="string">"""A simple localizer a la gettext"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.trans = dict(dog=<span class="string">u"小狗"</span>, cat=<span class="string">u"小猫"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, msgid)</span>:</span></span><br><span class="line">        <span class="string">"""We'll punt if we don't have a translation"""</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.trans[msgid]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">return</span> str(msgid)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnglishGetter</span>:</span></span><br><span class="line">    <span class="string">"""Simply echoes the msg ids"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, msgid)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(msgid)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_localizer</span><span class="params">(language=<span class="string">"English"</span>)</span>:</span></span><br><span class="line">    <span class="string">"""The factory method"""</span></span><br><span class="line">    languages = dict(English=EnglishGetter, China=ChinaGetter)</span><br><span class="line">    <span class="keyword">return</span> languages[language]()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create our localizers</span></span><br><span class="line">e, g = get_localizer(<span class="string">"English"</span>), get_localizer(<span class="string">"China"</span>)</span><br><span class="line"><span class="comment"># Localize some text</span></span><br><span class="line"><span class="keyword">for</span> msgid <span class="keyword">in</span> <span class="string">"dog parrot cat bear"</span>.split():</span><br><span class="line">    print(e.get(msgid), g.get(msgid))</span><br></pre></td></tr></table></figure><h3 id="2-Abstract-Factory（抽象工厂）"><a href="#2-Abstract-Factory（抽象工厂）" class="headerlink" title="2. Abstract Factory（抽象工厂）"></a>2. Abstract Factory（抽象工厂）</h3><p><img src="https://images2015.cnblogs.com/blog/824579/201609/824579-20160928181031672-1073974804.gif" alt="img"></p><p><strong>意图：</strong></p><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 </p><p><strong>适用性：</strong></p><p>一个系统要独立于它的产品的创建、组合和表示时。<br>一个系统要由多个产品系列中的一个来配置时。<br>当你要强调一系列相关的产品对象的设计以便进行联合使用时。<br>当你提供一个产品类库，而只想显示它们的接口而不是实现时。</p><p><strong>实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Abstract Factory</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PetShop</span>:</span></span><br><span class="line">    <span class="string">"""A pet shop"""</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, animal_factory=None)</span>:</span></span><br><span class="line">        <span class="string">"""pet_factory is our abstract factory.</span></span><br><span class="line"><span class="string">        We can set it at will."""</span></span><br><span class="line"> </span><br><span class="line">        self.pet_factory = animal_factory</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_pet</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Creates and shows a pet using the</span></span><br><span class="line"><span class="string">        abstract factory"""</span></span><br><span class="line"> </span><br><span class="line">        pet = self.pet_factory.get_pet()</span><br><span class="line">        print(<span class="string">"This is a lovely"</span>, str(pet))</span><br><span class="line">        print(<span class="string">"It says"</span>, pet.speak())</span><br><span class="line">        print(<span class="string">"It eats"</span>, self.pet_factory.get_food())</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Stuff that our factory makes</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"woof"</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Dog"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"meow"</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Factory classes</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pet</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Dog()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_food</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"dog food"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CatFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pet</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Cat()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_food</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"cat food"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create the proper family</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_factory</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Let's be dynamic!"""</span></span><br><span class="line">    <span class="keyword">return</span> random.choice([DogFactory, CatFactory])()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Show pets with various factories</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    shop = PetShop()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        shop.pet_factory = get_factory()</span><br><span class="line">        shop.show_pet()</span><br><span class="line">        print(<span class="string">"="</span> * <span class="number">20</span>)</span><br></pre></td></tr></table></figure><h3 id="3-Builder（建造者）"><a href="#3-Builder（建造者）" class="headerlink" title="3. Builder（建造者）"></a>3. Builder（建造者）</h3><p><strong>意图：</strong></p><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>适用性：</strong></p><p>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</p><p>当构造过程必须允许被构造的对象有不同的表示时。</p><p><img src="https://images2015.cnblogs.com/blog/824579/201609/824579-20160928195334656-2085921203.gif" alt="img"></p><p><strong>实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"> </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    Builder</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Director</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.builder = <span class="keyword">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_building</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.builder.new_building()</span><br><span class="line">        self.builder.build_floor()</span><br><span class="line">        self.builder.build_size()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_building</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.builder.building</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Abstract Builder</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.building = <span class="keyword">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_building</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.building = Building()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Concrete Builder</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuilderHouse</span><span class="params">(Builder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_floor</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.building.floor = <span class="string">'One'</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_size</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.building.size = <span class="string">'Big'</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuilderFlat</span><span class="params">(Builder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_floor</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.building.floor = <span class="string">'More than One'</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_size</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.building.size = <span class="string">'Small'</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Product</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.floor = <span class="keyword">None</span></span><br><span class="line">        self.size = <span class="keyword">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Floor: %s | Size: %s'</span> % (self.floor, self.size)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Client</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    director = Director()</span><br><span class="line">    director.builder = BuilderHouse()</span><br><span class="line">    director.construct_building()</span><br><span class="line">    building = director.get_building()</span><br><span class="line">    print(building)</span><br><span class="line">    director.builder = BuilderFlat()</span><br><span class="line">    director.construct_building()</span><br><span class="line">    building = director.get_building()</span><br><span class="line">    print(building)</span><br></pre></td></tr></table></figure><h3 id="4-Prototype（原型）"><a href="#4-Prototype（原型）" class="headerlink" title="4. Prototype（原型）"></a>4. Prototype（原型）</h3><p><strong>意图：</strong></p><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p><strong>适用性：</strong></p><p>当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者为了避免创建一个与产品类层次平行的工厂类层次时；或者当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p><p><img src="https://images2015.cnblogs.com/blog/824579/201609/824579-20160928194103188-1537654983.gif" alt="img"></p><p><strong>实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Prototype</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._objects = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register_object</span><span class="params">(self, name, obj)</span>:</span></span><br><span class="line">        <span class="string">"""Register an object"""</span></span><br><span class="line">        self._objects[name] = obj</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unregister_object</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""Unregister an object"""</span></span><br><span class="line">        <span class="keyword">del</span> self._objects[name]</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clone</span><span class="params">(self, name, **attr)</span>:</span></span><br><span class="line">        <span class="string">"""Clone a registered object and update inner attributes dictionary"""</span></span><br><span class="line">        obj = copy.deepcopy(self._objects.get(name))</span><br><span class="line">        obj.__dict__.update(attr)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"I am A"</span></span><br><span class="line"> </span><br><span class="line">    a = A()</span><br><span class="line">    prototype = Prototype()</span><br><span class="line">    prototype.register_object(<span class="string">'a'</span>, a)</span><br><span class="line">    b = prototype.clone(<span class="string">'a'</span>, a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">    print(a)</span><br><span class="line">    print(b.a, b.b, b.c)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="5-Singleton（单例）"><a href="#5-Singleton（单例）" class="headerlink" title="5. Singleton（单例）"></a>5. Singleton（单例）</h3><p><strong>意图：</strong></p><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>适用性：</strong></p><p>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</p><p>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</p><p><img src="https://images2015.cnblogs.com/blog/824579/201609/824579-20160928194345281-610274391.gif" alt="img"></p><p><strong>实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Singleton</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">''''' A python style singleton '''</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            org = super(Singleton, cls)</span><br><span class="line">            cls._instance = org.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SingleSpam</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, s)</span>:</span></span><br><span class="line">            self.s = s</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self.s</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    s1 = SingleSpam(<span class="string">'spam'</span>)</span><br><span class="line">    <span class="keyword">print</span> id(s1), s1</span><br><span class="line">    s2 = SingleSpam(<span class="string">'spa'</span>)</span><br><span class="line">    <span class="keyword">print</span> id(s2), s2</span><br><span class="line">    <span class="keyword">print</span> id(s1), s1</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码均为 Python 2，我一边验证一边更新代码和文章</p><p>（庄心昊）</p></blockquote>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-cv2 Contour 属性</title>
      <link href="/2018/06/01/cv2_contour/"/>
      <content type="html"><![CDATA[<p><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_features/py_contour_features.html" target="_blank" rel="noopener">Contour Features</a></p>]]></content>
      
      <categories>
          
          <category> 包特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进阶 </tag>
            
            <tag> cv2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python进阶函数和功能_#3（Collections）</title>
      <link href="/2018/05/17/python-collections/"/>
      <content type="html"><![CDATA[<p>collections 是 Python 内建的一个集合模块，提供了许多有用的集合类。</p><blockquote><p>参考资料：<a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001411031239400f7181f65f33a4623bc42276a605debf6000" target="_blank" rel="noopener">collections - 廖雪峰的官方网站</a></p><div id="content"></div><p><strong>下面是快捷方式</strong>（点击直达）<br><a href="/2018/05/17/python-collections/#tuple 和 NamedTuple"><code>tuple 和 NamedTuple</code></a>、<a href="/2018/05/17/python-collections/#DefaultDict"><code>DefaultDict</code></a>、<a href="/2018/05/17/python-collections/#Counter"><code>Counter</code></a></p></blockquote><a id="more"></a><h2 id="tuple-和-NamedTuple"><a href="#tuple-和-NamedTuple" class="headerlink" title="tuple 和 NamedTuple"></a>tuple 和 NamedTuple</h2><h3 id="tuple-不可变的相对性"><a href="#tuple-不可变的相对性" class="headerlink" title="tuple 不可变的相对性"></a>tuple 不可变的相对性</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">t</span> = ('<span class="built_in">text</span>', [<span class="number">11</span>, <span class="number">22</span>])</span><br><span class="line"><span class="built_in">t</span>[<span class="number">1</span>].append(<span class="number">33</span>)</span><br><span class="line">print(<span class="built_in">t</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><pre><code>(&#39;text&#39;, [11, 22, 33])</code></pre><h3 id="immutable-的优势"><a href="#immutable-的优势" class="headerlink" title="immutable 的优势"></a>immutable 的优势</h3><ol><li>性能优化：在编译时作为常量确定（python是解释型语言）</li><li>线程安全</li><li>可哈希（list 对象不可以）</li></ol><blockquote><p><strong>可哈希（hashable）和不可改变性（immutable）</strong></p><ul><li>如果一个对象在自己的生命周期中有一哈希值（hash value）是不可改变的，那么它就是可哈希的（hashable）的，因为这些数据结构内置了哈希值，每个可哈希的对象都内置了 <code>__hash__</code> 方法.</li><li>所以可哈希的对象可以 <strong>通过哈希值进行对比</strong> ，也可以 <strong>作为字典的键值</strong> 和 <strong>作为 <code>set</code> 函数的参数</strong> 。Python 中所有不可改变的的对象（imutable objects）都是可哈希的，比如 <code>字符串</code>，<code>元组</code>，也就是说可改变的容器如 <code>字典</code>，<code>列表</code> 不可哈希（unhashable）。我们用户所定义的 <code>类的实例对象</code> 默认是可哈希的（hashable），它们都是唯一的，而 hash 值也就是它们的id。</li><li>因为哈希键一定是不可改变的，所以它们对应的哈希值也不改变。如果允许它们改变，那么它们在数据结构如哈希表中的存储位置也会改变，因此会与哈希的概念违背，<strong>效率</strong> 会大打折扣。</li></ul></blockquote><h3 id="tuple-拆包"><a href="#tuple-拆包" class="headerlink" title="tuple 拆包"></a>tuple 拆包</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = (<span class="string">'John Theo'</span>, <span class="number">21</span>, <span class="number">176</span>, <span class="string">'Zhejiang University'</span>)</span><br><span class="line">name, *others = info</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(name)</span></span></span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><pre><code>John Theo</code></pre><p>结果包含了 <strong>位置对应</strong> 信息</p><h3 id="NamedTuple"><a href="#NamedTuple" class="headerlink" title="NamedTuple"></a>NamedTuple</h3><p>NamedTuple 相对 class 节省空间，因为少了很多魔术方法</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from collections import namedtuple</span><br><span class="line"></span><br><span class="line">User = namedtuple('User', ['name', 'age', 'height'])</span><br><span class="line">user_tuple = ('John_Theo', <span class="number">21</span>)</span><br><span class="line">user = User(<span class="name">*user_tuple</span>, <span class="number">176</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="name">user</span>.name, user.age, user.height)</span><br><span class="line">print(<span class="name">user</span>._asdict())</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><pre><code>John_Theo 21 176OrderedDict([(&#39;name&#39;, &#39;John_Theo&#39;), (&#39;age&#39;, 21), (&#39;height&#39;, 176)])</code></pre><blockquote><p>NamedTuple 继承 tuple，也支持拆包。</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="DefaultDict"><a href="#DefaultDict" class="headerlink" title="DefaultDict"></a>DefaultDict</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default_generator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">info_dict = defaultdict(default_generator)</span><br><span class="line"></span><br><span class="line">user_list = [<span class="string">'John'</span>, <span class="string">'Jack'</span>, <span class="string">'John'</span>, <span class="string">'Jack'</span>, <span class="string">'Jay'</span>]</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> user_list:</span><br><span class="line">    info_dict[user] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(info_dict)</span><br><span class="line"></span><br><span class="line">target_users = [<span class="string">'John'</span>, <span class="string">'Jack'</span>, <span class="string">'Jay'</span>, <span class="string">'Jessy'</span>]</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> target_users:</span><br><span class="line">    print(info_dict[user], end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><pre><code>defaultdict(&lt;function default_generator at 0x0000020AB6FA2EA0&gt;, {&#39;John&#39;: 2, &#39;Jack&#39;: 2, &#39;Jay&#39;: 1})2 2 1 0 </code></pre><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line">texts = [<span class="string">'a'</span>, <span class="string">'s'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'s'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'s'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>]</span><br><span class="line">letter_counter = Counter(texts)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(letter_counter)</span></span></span><br><span class="line"></span><br><span class="line">letter_counter.update(<span class="string">'dwqsadadwa'</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(letter_counter)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(letter_counter.most_common(<span class="number">2</span>)</span></span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><pre><code>Counter({&#39;a&#39;: 3, &#39;s&#39;: 3, &#39;d&#39;: 3, &#39;c&#39;: 1})Counter({&#39;a&#39;: 6, &#39;d&#39;: 6, &#39;s&#39;: 4, &#39;w&#39;: 2, &#39;c&#39;: 1, &#39;q&#39;: 1})[(&#39;a&#39;, 6), (&#39;d&#39;, 6)]</code></pre><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pandas 实用手记（concat/merge）</title>
      <link href="/2018/05/03/pandas-merge/"/>
      <content type="html"><![CDATA[<p>在使用 pandas 的过程中，经常用到 merge 或者 concat 操作，今小小补习，作笔记于此。<br>索引：<a href="/2018/05/03/pandas-merge/#merge"><code>merge</code></a> / <a href="/2018/05/03/pandas-merge/#concat"><code>concat</code></a></p><div id="content"></div><blockquote><p>参考资料：<a href="https://my.oschina.net/lionets/blog/279785?fromerr=Z1jmQb0L" target="_blank" rel="noopener">pandas 数据规整</a></p></blockquote><a id="more"></a><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a><strong>merge</strong></h2><p>merge 函数通过 <strong>一个或多个键</strong> 来将数据集的 <strong>行</strong> 连接起来。该函数的主要应用场景是针对同一个 <code>主键</code> 存在两张包含不同特征的表，通过该主键的连接，将两张表进行合并。合并之后，两张表的行数没有增加，列数是两张表的列数之和减一。<br>函数的具体参数为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">merge</span>(<span class="keyword">left</span>,<span class="keyword">right</span>,how=<span class="string">'inner'</span>,<span class="keyword">on</span>=<span class="keyword">None</span>,left_on=<span class="keyword">None</span>,right_on=<span class="keyword">None</span>,</span><br><span class="line">left_index=<span class="literal">False</span>,right_index=<span class="literal">False</span>,<span class="keyword">sort</span>=<span class="literal">False</span>,suffixes=(<span class="string">'_x'</span>,<span class="string">'_y'</span>),copy=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li><code>on=None</code> 指定连接的列名，若两列希望连接的列名不一样，可以通过 <code>left_on</code> 和 <code>right_on</code> 来具体指定</li><li><code>how=&#39;inner&#39;</code> 参数指的是左右两个表主键那一列中存在不重合的行时，取结果的方式：inner表示交集，outer 表示并集，left 和right 表示取某一边。 </li></ul><p>举例如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">df1 = pd.DataFrame([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">3</span>,<span class="number">9</span>,<span class="number">0</span>],[<span class="number">8</span>,<span class="number">0</span>,<span class="number">3</span>]], columns=['x1','x2','x3'])</span><br><span class="line">df2 = pd.DataFrame([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">9</span>]], columns=['x1','x4'])</span><br><span class="line"></span><br><span class="line">df3 = pd.merge(df1, df2, how='left', on='x1')</span><br><span class="line">print(df3)</span><br></pre></td></tr></table></figure><ul><li><code>on=&#39;x1&#39;</code>，即以两个表中的x1为主键进行连接，</li><li><code>how=&#39;left&#39;</code>，即是以两个表中 <code>merge</code> 函数中左边那个表的行为准，保持左边表行数不变，拿右边的表与之合并。</li></ul><p>df3 结果如下：</p><blockquote><p>  x1  x2  x3   x4<br>0   1   2   3  2.0<br>1   5   6   7  NaN<br>2   3   9   0  9.0<br>3   8   0   3  NaN</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a><strong>concat</strong></h2><p>concat 与其说是连接，更准确的说是拼接。就是把两个表直接合在一起。于是有一个突出的问题，是 <strong>横向拼接</strong> 还是 <strong>纵向拼接</strong>，所以 concat 函数的关键参数是 <code>axis</code> 。<br>函数的具体参数是：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat<span class="params">(objs,<span class="attr">axis</span>=0,<span class="attr">join</span>='outer',<span class="attr">join_axes</span>=None,<span class="attr">ignore_index</span>=False,<span class="attr">keys</span>=None,<span class="attr">levels</span>=None,<span class="attr">names</span>=None,<span class="attr">verigy_integrity</span>=False)</span></span><br></pre></td></tr></table></figure><ul><li><code>objs</code> 是需要拼接的对象集合，一般为列表或者字典</li><li><code>axis=0</code> 是 <strong>行拼接</strong>，拼接之后行数增加，列数也根据 <code>join</code> 来定，<code>join=&#39;outer&#39;</code> 时，列数是两表并集。同理<code>join=&#39;inner&#39;</code>，列数是两表交集。</li></ul><p>在默认情况下，<code>axis=0</code> 为纵向拼接，此时有：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">concat</span><span class="params">([df1,df2])</span></span>  &lt;=&gt;  df1.append(df2)</span><br></pre></td></tr></table></figure><p>在axis=1 时为横向拼接 ，此时有</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat([df1,df2],<span class="attribute">axis</span>=1)  &lt;=&gt;  merge(df1,df2,<span class="attribute">left_index</span>=<span class="literal">True</span>,right_index=True,how='outer')</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>], <span class="string">'data1'</span>: range(<span class="number">4</span>)&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'c'</span>], <span class="string">'data2'</span>: range(<span class="number">4</span>)&#125;)</span><br><span class="line"></span><br><span class="line">print(pd.concat([df1, df2],axis=<span class="number">1</span>))</span><br><span class="line">print(pd.merge(df1, df2, left_index=<span class="keyword">True</span>, right_index=<span class="keyword">True</span>, how=<span class="string">'outer'</span>))</span><br></pre></td></tr></table></figure><p>输出如下：</p><blockquote><p>   data1 key  data2 key<br>0      0   a      0   b<br>1      1   a      1   b<br>2      2   b      2   c<br>3      3   b      3   c</p><p>  data1 key_x  data2 key_y<br>0      0     a      0     b<br>1      1     a      1     b<br>2      2     b      2     c<br>3      3     b      3     c</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 版本区别翻译</title>
      <link href="/2018/03/28/python-translation/"/>
      <content type="html"><![CDATA[<p>有言曰：</p><blockquote><p>了解一门语言最好的方法是了解它的历史沿革。</p></blockquote><p>本着这一宗旨，同时也为了目前 Python 学习和例程中不同版本写法不同带来的诸多困扰，我开始着手翻译 <a href="https://docs.python.org/3/whatsnew/3.0.html" target="_blank" rel="noopener"><code>What’s New In Python 3.0</code></a> 。如果你同样有兴趣，欢迎加入翻译工作。</p><p>为了协作方便，本项目就托管在github上了，完成的工作会定期迁移到本文。</p><p><strong><a href="https://github.com/John-Theo/PythonDocTranslation" target="_blank" rel="noopener"><code>Repo 传送门</code></a></strong></p><a id="more"></a><hr><blockquote><p>原文链接：<a href="https://docs.python.org/3/whatsnew/3.0.html" target="_blank" rel="noopener">https://docs.python.org/3/whatsnew/3.0.html</a><br>  原作者：Guido van Rossum<br>责任翻译：庄心昊</p></blockquote><p><strong>！ 注意：本文对比版本为 3.0 和 2.6，如果你关心最新版本的变化，请在</strong> <a href="https://docs.python.org/3/whatsnew/changelog.html#changelog" target="_blank" rel="noopener">这里</a> <strong>查看 change log。</strong></p><p><strong>另外，如果你发现本文的机制在最新的版本中不适用，请提交issue。</strong></p><p><strong>（以下为作者正文）</strong></p><hr><p>本文简述了 Python 3.0 相对于 2.6 版本的新功能。 Python 3.0 也被称为 “Python 3000” 或 “Py3K”，是有史以来第一个 _特意向后兼容_  的Python版本。比普通的发行版本有更多的变化，且对于所有Python用户来说更重要。尽管如此，在充分了解了这些变化之后，你会发现 Python 其实并没有改变太多 —— 总的来说，我们主要修复了广为提及的小问题，并去除了很多无用的设计。</p><p>本文的目的不是提供所有新功能的详细说明，而是试图给出一个简便的概述。有关完整的详细信息，请参阅 Python 3.0 的文档和/或文中引用的许多PEP。如果您想了解特定功能的完整实施和设计原理，PEP通常比常规文档具有更多的细节；但请注意，一旦功能完全实施，PEP通常不会保持在最新状态。</p><blockquote><p><strong>译者注：PEP (Python Enhancement Proposals) 是一份为Python社区提供各种增强功能的技术规格，也是提交新特性，以便让社区指出问题，精确化技术文档的提案。<a href="https://www.python.org/dev/peps/" target="_blank" rel="noopener"><code>传送门</code></a></strong></p></blockquote><p>由于时间限制，这个文件并不像它应该呈现的那样完整。与新的发行版本一样，源代码中的 <code>Misc/NEWS</code> 文件包含大量有关已更改的每个小细节的详细信息。</p><h2 id="常见的绊脚石"><a href="#常见的绊脚石" class="headerlink" title="常见的绊脚石"></a>常见的绊脚石</h2><p>如果您已经习惯于使用 Python 2.5，本节列出了最有可能困住您的一些变化。</p><h3 id="print-是一个函数"><a href="#print-是一个函数" class="headerlink" title="print 是一个函数"></a>print 是一个函数</h3><p><code>print</code> 语句已被 <a href="https://docs.python.org/3/library/functions.html#print" target="_blank" rel="noopener">print()</a> 函数替代，其中的关键字参数替换了原先 <code>print</code> 语句的大部分特殊语法（<a href="https://www.python.org/dev/peps/pep-3105" target="_blank" rel="noopener"><strong>PEP 3105</strong></a>）。 例程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Old: <span class="keyword">print</span> <span class="string">"The answer is"</span>, <span class="number">2</span>*<span class="number">2</span></span><br><span class="line">New: print(<span class="string">"The answer is"</span>, <span class="number">2</span>*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Old: <span class="keyword">print</span> x,           <span class="comment"># 结尾的逗号使输出结束后不换行</span></span><br><span class="line">New: print(x, end=<span class="string">" "</span>)  <span class="comment"># 每行结束后连接上end关键字传入的字符（译者注：本例中是一个空格）</span></span><br><span class="line"></span><br><span class="line">Old: <span class="keyword">print</span>              <span class="comment"># 输出新的一行</span></span><br><span class="line">New: print()            <span class="comment"># 你必须调用函数！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 译者注：输出重定向</span></span><br><span class="line">Old: <span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">"fatal error"</span></span><br><span class="line">New: print(<span class="string">"fatal error"</span>, file=sys.stderr)</span><br><span class="line"></span><br><span class="line">Old: <span class="keyword">print</span> (x, y)       <span class="comment"># 输出 repr((x, y))（译者注：__repr__是魔术功能）</span></span><br><span class="line">New: print((x, y))      <span class="comment"># 和 print(x, y)不完全相同！（译者注：新旧表达作用一致）</span></span><br></pre></td></tr></table></figure></p><p>您也可以自定义元素之间的分隔符，例如：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">print</span>(<span class="string">"There are &lt;"</span>, 2*<span class="number">*32</span>, <span class="string">"&gt; possibilities!"</span>, <span class="attribute">sep</span>=<span class="string">""</span>)</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There are <span class="tag">&lt;<span class="name">4294967296</span>&gt;</span> possibilities!</span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong></p><ul><li><a href="https://docs.python.org/3/library/functions.html#print" target="_blank" rel="noopener">print()</a> 函数不支持旧 <code>print</code> 申明的 <code>softspace</code> 特征。例如在 Python 2.x 中，<code>print &quot;A\n&quot;, &quot;B&quot;</code> 会输出 <code>&quot;A\nB\n&quot;</code>；但是，在 Python 3.x 中，<code>print &quot;A\n&quot;, &quot;B&quot;</code> 输出 <code>&quot;A\n B\n&quot;</code>。</li><li>刚开始在交互模式中，你会发现自己码上很多旧的 <code>print x</code> 表达。是时候训练你的手指猛戳新的 <code>print(x)</code> 了！</li><li>在使用 <code>2to3</code> source-to-source 转换工具的时候，所有的 <code>print</code> 表达会自动转化成 <a href="https://docs.python.org/3/library/functions.html#print" target="_blank" rel="noopener">print()</a> 函数调用，所以这对比较大的项目不是特别大的麻烦。</li></ul><h3 id="返回-Views-对象-和-迭代器-而不再是-Lists"><a href="#返回-Views-对象-和-迭代器-而不再是-Lists" class="headerlink" title="返回 Views 对象 和 迭代器 而不再是 Lists"></a>返回 Views 对象 和 迭代器 而不再是 Lists</h3><p>一些著名的 API 接口不再返回列表（list）：</p><ul><li><a href="https://docs.python.org/3/library/stdtypes.html#dict" target="_blank" rel="noopener">dict</a> 方法 <a href="https://docs.python.org/3/library/stdtypes.html#dict.keys" target="_blank" rel="noopener">dict.keys()</a>，<a href="https://docs.python.org/3/library/stdtypes.html#dict.items" target="_blank" rel="noopener">dict.items()</a> 和 <a href="https://docs.python.org/3/library/stdtypes.html#dict.values" target="_blank" rel="noopener">dict.values()</a> 不再返回 list，而返回 view 对象 [<a href="#q1">1</a>]。例如，这样的表达不再生效：<code>k = d.keys(); k.sort()</code>。需要使用 <code>k = sorted(d)</code> 来代替（这在 Python 2.5 中一样适用，且一样快捷）。</li><li>同时，<code>dict.iterkeys()</code>，<code>dict.iteritems()</code> 和 <code>dict.itervalues()</code> 方法也不再受支持。</li><li><a href="https://docs.python.org/3/library/functions.html#map" target="_blank" rel="noopener">map()</a> 和 <a href="https://docs.python.org/3/library/functions.html#filter" target="_blank" rel="noopener">filter()</a> 返回迭代器（iterators）。如果你确实需要 list 对象，且传入序列全部等长，一个便捷的解决方案是把 <a href="https://docs.python.org/3/library/functions.html#map" target="_blank" rel="noopener">map()</a> 嵌套在 <a href="https://docs.python.org/3/library/stdtypes.html#list" target="_blank" rel="noopener">list()</a> 里，例如 <code>list(map(...))</code>，但是，一个更好的解决方案是尽量使用 list comprehension（尤其当原始代码使用了 <a href="https://docs.python.org/3/reference/expressions.html#lambda" target="_blank" rel="noopener">lambda</a> 时），或者重写代码，使其不需要用到 list（译者注：耿直了老铁）。一个特别的小技巧： <a href="https://docs.python.org/3/library/functions.html#map" target="_blank" rel="noopener">map()</a> 作为函数的 side effects 调用；正确的变形是使用普通的 <a href="https://docs.python.org/3/reference/compound_stmts.html#for" target="_blank" rel="noopener">for</a> 循环（因为创建一个 list 也是浪费）。<br>如果传入序列并不等长，<a href="https://docs.python.org/3/library/functions.html#map" target="_blank" rel="noopener">map()</a> 会在最短序列的末端停止 [<a href="#q2">2</a>]。若希望和 Python 2.x 中的 <a href="https://docs.python.org/3/library/functions.html#map" target="_blank" rel="noopener">map()</a> 完全兼容，同样可以把序列嵌套在 <code>itertools.zip_longest()</code> 中，例如：<code>map(func, *sequences)</code> 将写为 <code>list(map(func, itertools.zip_longest(*sequences)))</code>。</li><li>现在，<a href="https://docs.python.org/3/library/stdtypes.html#range" target="_blank" rel="noopener">range()</a> 函数的使用和 <code>xrange()</code> 函数曾经的用法类似，但是前者可以处理任意大小的值，后者不再存在。</li><li><a href="https://docs.python.org/3/library/functions.html#zip" target="_blank" rel="noopener">zip()</a> 现在也返回迭代器。</li></ul><div class="q1"></div><blockquote><p>[1] 译者注：关于更好理解 views 的概念，请看下例：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dishes = &#123;<span class="string">'eggs'</span>: <span class="number">2</span>, <span class="string">'sausage'</span>: <span class="number">1</span>, <span class="string">'bacon'</span>: <span class="number">1</span>, <span class="string">'spam'</span>: <span class="number">500</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys = dishes.keys()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = dishes.values()  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># iteration（译者注：更像是枚举？）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">0</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> val <span class="keyword">in</span> values:  </span><br><span class="line"><span class="meta">... </span>    n += val  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(n)  </span><br><span class="line"><span class="number">504</span>  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># keys 和 values 以相同的顺序被遍历</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(keys)</span><br><span class="line">[<span class="string">'eggs'</span>, <span class="string">'bacon'</span>, <span class="string">'sausage'</span>, <span class="string">'spam'</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(values)  </span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">500</span>]  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># view 对象动态反映 dict 的变化（译者注：从这个定义来看，view 也许可以翻译为“快照”）  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> dishes[<span class="string">'eggs'</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> dishes[<span class="string">'sausage'</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(keys)  </span><br><span class="line">[<span class="string">'spam'</span>, <span class="string">'bacon'</span>]  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 集合操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys &amp; &#123;<span class="string">'eggs'</span>, <span class="string">'bacon'</span>, <span class="string">'salad'</span>&#125;  </span><br><span class="line">&#123;<span class="string">'bacon'</span>&#125;</span><br></pre></td></tr></table></figure><div class="q2"></div><blockquote><p>[2] 译者注：原文对“会在最短序列的末端停止”的解释是：<br>With multiple iterables, the iterator stops when the shortest iterable is exhausted. For cases where the function inputs are already arranged into argument tuples, see <a href="https://docs.python.org/3/library/itertools.html#itertools.starmap" target="_blank" rel="noopener">itertools.starmap()</a>.</p></blockquote><h3 id="大小比较"><a href="#大小比较" class="headerlink" title="大小比较"></a>大小比较</h3><p>Python 3.0 简化了大小比较的流程：</p><ul><li>当表达式没有天然可比的标度时，顺序比较操作符 (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code>) 会抛出一个 TypeError exception。因此，诸如 <code>1 &lt; &#39;&#39;</code>，<code>0 &gt; None</code> 或 <code>len &lt;= len</code> 这样的表达式不再合法，而对于比如 <code>None &lt; None</code> 这样的表达，则会抛出一个 <a href="https://docs.python.org/3/library/exceptions.html#TypeError" target="_blank" rel="noopener">TypeError</a> 而不是返回 <code>False</code>。这就意味着对一个异质的 list 排序不再可行——所有元素必须互相之间可比。值得注意的是，这一限制对 <code>==</code> 和 <code>!=</code> 操作符并不存在：不同类型的对象比较结果总是不同。</li><li>builtin.sorted() 和 <a href="https://docs.python.org/3/library/stdtypes.html#list.sort" target="_blank" rel="noopener">list.sort()</a> 不再接受 _cmp_ 参数指定的比较函数，而使用键值对指定。注意：_key_ 和 _reverse_ 参数现在只能通过键值对指定。</li><li>cmp() 函数应该被视为不存在了，而 __cmp__() 魔术方法也不再受支持。现在使用 <a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__" target="_blank" rel="noopener">__lt__()</a> 来排序， <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener">__eq__()</a> 配合 <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener">__hash__()</a> 使用，以及其他所需的比较操作符。（如果你真的很想实现 cmp() 的功能，你可以使用如下表达式 <code>(a &gt; b) - (a &lt; b)</code> ，它的效果和 <code>cmp(a, b)</code> 相同。）</li></ul><blockquote><p>__cmp__() 魔术方法在目前的 python 3.6.4 中依然受到支持，但 cmp() 函数确实不见了。</p></blockquote><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><ul><li><a href="https://www.python.org/dev/peps/pep-0237" target="_blank" rel="noopener"><strong>PEP 237</strong></a>：事实上，long （译者注：长整型）被重命名为 <a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener">int</a>。这就意味着，只有一个內建（built-in）的叫做 <a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener">int</a> 的整形，但是从表现来看，它和原先的 long 差不多。</li><li><a href="https://www.python.org/dev/peps/pep-0238" target="_blank" rel="noopener"><strong>PEP 238</strong></a>：一个诸如 <code>1/2</code> 的表达式返回一个 float。而使用 <code>1//2</code> 来得到截尾（取整）的结果。（后面的表达形式已经存在了数年，至少从 Python 2.2 开始就有了。）</li><li>因为对整形的值不再有限制， <code>sys.maxint</code> 常量被取消。但是 <code>sys.maxsize</code> 可以被用作一个大于任何 practical list 和 string index（译者注：字符串索引？） 的整数。它符合现实的“自然”整数的大小，并且和上一次同一平台中发布版本中的 <code>sys.maxint</code> 相同（如果编译环境完全相同的话）。</li><li>长整数的 <a href="https://docs.python.org/3/library/functions.html#repr" target="_blank" rel="noopener">repr()</a> 函数不需要再尾随一个 <code>L</code> 了，所以无条件 strip 该对象的代码将会删去最后一位数字。（使用 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str()</a> 替代。）</li><li>八进制表示不再写作 <code>0720</code> 这样的形式；而使用例如 <code>0o720</code> 的形式来代替。</li></ul><h3 id="Text-Vs-Data-取代-Unicode-Vs-8-bit"><a href="#Text-Vs-Data-取代-Unicode-Vs-8-bit" class="headerlink" title="Text Vs. Data 取代 Unicode Vs. 8-bit"></a>Text Vs. Data 取代 Unicode Vs. 8-bit</h3><p>你此前关于 二进制数据 和 Unicode 的 认识被全部改变了。</p><ul><li>Python 3.0 使用 _text_ 和 （二进制）数据 的概念来取代 Unicode 字符串 和 8位字符串。所有的 text 都是 Unicode；而已编码的 Unicode（数据）则被作为 二进制数据。用来存放 text 的类型是 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a>，用来存放数据（data）的数据类型是字节（byte）。Python 3.0 和 2.x 之间最大的区别是任何企图混淆 text 和 data 的做法都会引发 <a href="https://docs.python.org/3/library/exceptions.html#TypeError" target="_blank" rel="noopener">TypeError</a>；而如果你要在 Python 2.x 中将 Unicode 和 8位字符串 混合使用，当 8位字符串 正好只有7位（ASCII）时，是没问题的；但当其中包含非ASCII值时，就会引发 <a href="https://docs.python.org/3/library/exceptions.html#UnicodeDecodeError" target="_blank" rel="noopener">UnicodeDecodeError</a> 错误。这样针对数值的做法在近几年引起了众多的不满。</li><li>因为这一点原则性的变化，几乎所有使用Unicode，编码或二进制数据的代码都需要更改。这项改变是有建设性的，因为在 2.x 版本中，由编码和非编码字符混合使用导致了非常多的bug。 要在 Python 2.x 中准备好，请对所有未编码的 text 使用 Unicode，并且对二进制或已编码数据使用 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a>。 然后 <code>2to3</code> 工具将为您完成大部分工作。</li><li>以后，您不需要再对 Unicode 文本使用 <code>u&quot;...&quot;</code> 这样的表达了。然而，您仍然需要对二进制数据使用 <code>b&quot;...&quot;</code> 这样的表达。</li><li>因为 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a> 和 <a href="https://docs.python.org/3/library/stdtypes.html#bytes" target="_blank" rel="noopener">bytes</a> 类型不能混用，您必须明确声明两者之间的转换。使用 <a href="https://docs.python.org/3/library/stdtypes.html#str.encode" target="_blank" rel="noopener">str.encode()</a> 来将 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a> 转换为 <a href="https://docs.python.org/3/library/stdtypes.html#bytes" target="_blank" rel="noopener">bytes</a>，<a href="https://docs.python.org/3/library/stdtypes.html#bytes.decode" target="_blank" rel="noopener">bytes.decode()</a> 反之。你也可以分别使用 <code>bytes(s, encoding=...)</code> 和 <code>str(b, encoding=...)</code>。</li><li>和 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a> 一样，<a href="https://docs.python.org/3/library/stdtypes.html#bytes" target="_blank" rel="noopener">bytes</a> 类型也是不可变的。有一个单独的 _可变_ 类型来保存缓冲（buffered）的二进制数据，<a href="https://docs.python.org/3/library/stdtypes.html#bytearray" target="_blank" rel="noopener">bytearray</a>。几乎所有接受 <a href="https://docs.python.org/3/library/stdtypes.html#bytes" target="_blank" rel="noopener">bytes</a> 的接口也接受 <a href="https://docs.python.org/3/library/stdtypes.html#bytearray" target="_blank" rel="noopener">bytearray</a>。可变的 API 基于 collections.MutableSequence。</li><li>所有在原始（raw）字符串里的反斜杠都会被编译为它字面的意思。这意味着 <code>&#39;\U&#39;</code> 和 <code>&#39;\u&#39;</code> 在原始（raw）字符串中的转义不会被专门处理。比如，<code>r&#39;\u20ac&#39;</code> 在 Python 3.0 中是一个含有6个字符的字符串；而在 2.6 版本中，<code>ur&#39;\u20ac&#39;</code> 则表示一个单独的“欧元”符号。（当然，这项改变仅仅影响原始字符串书面形式，在 Python 3.0 中，欧元符号用 <code>&#39;\u20ac&#39;</code> 表示。）</li><li>內建（built-in）的 basestring 抽象类型被移去了。取而代之的是 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a>。<a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a> 和 <a href="https://docs.python.org/3/library/stdtypes.html#bytes" target="_blank" rel="noopener">bytes</a> 类型没有足够多的共同功能来共享同一个基类。 <code>2to3</code> 工具（见下文）会将所有出现的 basestring 替换成 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a>。</li><li>以文本文件（text files）打开的文件（目前作为 <a href="https://docs.python.org/3/library/functions.html#open" target="_blank" rel="noopener">open()</a> 函数的默认模式）通常使用一种编码方式将（内存中的）字符串和（硬盘上的）字节进行映射。以二进制文件（binary files）打开的文件（打开时在 mode 参数处为 <code>&#39;b&#39;</code>）通常在内存中使用字节存储。这意味着，如果一个文件以错误的模式或编码被打开，I/O 会报错，而不是安静地对错误数据进行处理。这也意味着即使是 Unix 的用户也需要在打开文件时制定正确的模式（text 或 binary）。有一种依赖平台（操作系统）的默认编码，在 Unix 系的平台上可以通过环境变量 <code>LANG</code> 设置（个别情况下需要通过对平台特异性本地环境相关的环境变量进行设置）。在大多数情况下，但不是全部情形，系统的默认编码是 UTF-8；你永远不要指望这个默认值派大用场（译者注：谁说的！明明很多乱码问题设成 utf-8 就好了，你骗人）。任何读写非纯 ASCII 文本的应用推荐覆写编码。所以再也没有必要在 codecs 模块里，使用需要关注编码的数据流了。</li></ul>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习资源链接汇总</title>
      <link href="/2018/03/28/ML-terms/"/>
      <content type="html"><![CDATA[<p><strong>快速链接</strong><br><a href="/2018/03/28/ML-terms/#课程"><code>课程</code></a>、<a href="/2018/03/28/ML-terms/#术语表"><code>术语表</code></a>、<a href="/2018/03/28/ML-terms/#三个月入门"><code>三个月入门</code></a></p><a id="more"></a><hr><h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><h3 id="Google-Crash-Course"><a href="#Google-Crash-Course" class="headerlink" title="Google Crash Course"></a>Google Crash Course</h3><p><i class="fa fa-arrow-circle-right"></i>&ensp;<a href="https://developers.google.cn/machine-learning/crash-course/?hl=zh-CN" target="_blank" rel="noopener"><code>转到</code></a></p><hr><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><h3 id="Google-×-TensorFlow"><a href="#Google-×-TensorFlow" class="headerlink" title="Google × TensorFlow"></a>Google × TensorFlow</h3><p><i class="fa fa-arrow-circle-right"></i>&ensp;<a href="https://developers.google.cn/machine-learning/crash-course/glossary?hl=zh-CN" target="_blank" rel="noopener"><code>转到</code></a></p><hr><h2 id="公共数据集"><a href="#公共数据集" class="headerlink" title="公共数据集"></a>公共数据集</h2><p><a href="https://github.com/awesomedata/awesome-public-datasets/blob/master/README.rst" target="_blank" rel="noopener">awesomedata - public datasets</a></p><h2 id="机器学习中的范数规则化"><a href="#机器学习中的范数规则化" class="headerlink" title="机器学习中的范数规则化"></a>机器学习中的范数规则化</h2><h3 id="L0、L1、L2-正则化"><a href="#L0、L1、L2-正则化" class="headerlink" title="L0、L1、L2 正则化"></a>L0、L1、L2 正则化</h3><p><a href="https://blog.csdn.net/zouxy09/article/details/24971995" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/24971995</a></p><h3 id="核范数与规则项参数选择"><a href="#核范数与规则项参数选择" class="headerlink" title="核范数与规则项参数选择"></a>核范数与规则项参数选择</h3><p><a href="https://blog.csdn.net/zouxy09/article/details/24972869" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/24972869</a></p><h2 id="三个月入门"><a href="#三个月入门" class="headerlink" title="三个月入门"></a>三个月入门</h2><p><br></p><blockquote><p>Author: Siraj Raval @ Youtube<br>Original Link <a href="https://www.youtube.com/watch?v=Cr6VqTRO1v0" target="_blank" rel="noopener">Here</a></p></blockquote><h3 id="Month-1"><a href="#Month-1" class="headerlink" title="Month 1"></a>Month 1</h3><ul><li><strong>Week 1</strong> - <a href="https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/" target="_blank" rel="noopener"><code>Linear Algebra</code></a></li><li><strong>Week 2</strong> - <a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDMsr9K-rj53DwVRMYO3t5Yr" target="_blank" rel="noopener"><code>Calculus</code></a></li><li><strong>Week 3</strong> - <a href="https://www.edx.org/course/introduction-probability-science-mitx-6-041x-2" target="_blank" rel="noopener"><code>Probability</code></a></li><li><strong>Week 4</strong> - <a href="https://www.coursera.org/courses?languages=en&amp;query=Algorithm%20design%20and%20analysis" target="_blank" rel="noopener"><code>Algorithms</code></a></li></ul><h3 id="Month-2"><a href="#Month-2" class="headerlink" title="Month 2"></a>Month 2</h3><ul><li><strong>Week 1</strong><ul><li><a href="https://www.youtube.com/watch?v=T5pRlIbr6gg" target="_blank" rel="noopener">learn <code>python</code> for data science</a></li><li><a href="https://www.youtube.com/watch?v=xRJCOz3AfYY" target="_blank" rel="noopener"><code>Math</code> of Intelligence</a></li><li><a href="https://www.youtube.com/watch?v=2FmcHiLCwTU" target="_blank" rel="noopener">Intro to <code>Tensorflow</code></a><br><br></li></ul></li><li><strong>Week 2</strong><ul><li><a href="https://eu.udacity.com/course/intro-to-machine-learning--ud120" target="_blank" rel="noopener">Intro to <code>ML</code> (Udacity)</a><br><br></li></ul></li><li><strong>Week 3-4</strong><ul><li><a href="https://github.com/NirantK/awesome-project-ideas" target="_blank" rel="noopener">ML <code>Project</code> Ideas</a></li></ul></li></ul><h3 id="Month-3-Deep-Learning"><a href="#Month-3-Deep-Learning" class="headerlink" title="Month 3 (Deep Learning)"></a>Month 3 (Deep Learning)</h3><ul><li><strong>Week 1</strong> <ul><li><a href="https://www.youtube.com/watch?v=vOppzHpvTiQ" target="_blank" rel="noopener">Intro to <code>Deep Learning</code></a><br><br></li></ul></li><li><strong>Week 2</strong> <ul><li><a href="http://course.fast.ai/" target="_blank" rel="noopener">Deep Learning by <code>Fast.AI</code></a><br><br></li></ul></li><li><strong>Week 3-4</strong><ul><li><a href="https://github.com/llSourcell?tab=repositories" target="_blank" rel="noopener"><code>Re-implement</code> DL projects from my github</a></li></ul></li></ul><h3 id="For-the-future"><a href="#For-the-future" class="headerlink" title="For the future"></a>For the future</h3><ul><li><a href="https://www.quora.com/Who-should-I-follow-on-Twitter-to-get-useful-and-reliable-machine-learning-information" target="_blank" rel="noopener">ML <code>people to follow</code> on Twitter</a></li></ul><hr>]]></content>
      
      <categories>
          
          <category> 学习路径 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 链接 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python进阶函数和功能_#2（杂记）</title>
      <link href="/2018/03/28/python-adv-2/"/>
      <content type="html"><![CDATA[<p>本文是近期学习中零散的一些知识点，主要是面向对象，记于此。</p><div id="content"></div><blockquote><p><strong>下面是快捷方式</strong>（点击直达）<br><a href="/2018/03/28/python-adv-2/#导入模块"><code>导入模块</code></a>、<a href="/2018/03/28/python-adv-2/#导入模块"><code>导入模块</code></a>、<a href="/2018/03/28/python-adv-2/#面向对象文法"><code>面向对象文法</code></a>、<a href="/2018/03/28/python-adv-2/#属性优先级"><code>属性优先级</code></a>、<a href="/2018/03/28/python-adv-2/#类方法"><code>类方法</code></a>、<a href="/2018/03/28/python-adv-2/#类的继承"><code>类的继承</code></a>、<a href="/2018/03/28/python-adv-2/#面相对象比较"><code>面相对象比较</code></a>、<a href="/2018/03/28/python-adv-2/#不定参数的传递"><code>不定参数的传递</code></a>、<a href="/2018/03/28/python-adv-2/#关于Python版本和函数使用"><code>关于Python版本和函数使用</code></a>、</p></blockquote><a id="more"></a><h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尝试导入较老版本模块</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> simplejson <span class="keyword">as</span> json</span><br><span class="line"></span><br><span class="line">print(json.dumps(&#123;<span class="string">'python'</span>:<span class="number">3.6</span>&#125;))</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="面向对象文法"><a href="#面向对象文法" class="headerlink" title="面向对象文法"></a>面向对象文法</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(name, gender, birth)</span></span><span class="symbol">:</span></span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">xiaoming = Person(<span class="string">'Xiao Ming'</span>, <span class="string">'Male'</span>, <span class="string">'1990-1-1'</span>)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">TypeError:</span> __init_<span class="number">_</span>() takes exactly <span class="number">3</span> arguments (<span class="number">4</span> given)</span><br></pre></td></tr></table></figure><p>这会导致创建失败或运行不正常，因为第一个参数name被Python解释器传入了实例的引用，从而导致整个方法的调用参数位置全部没有对上。</p><p><strong>正确写法：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 第一个参数一定要是self！</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, birth)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><blockquote><p>第一个参数一定要是 <code>self</code>！</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="属性优先级"><a href="#属性优先级" class="headerlink" title="属性优先级"></a>属性优先级</h2><p>当实例属性和类属性重名时，实例属性优先级高，它将屏蔽掉对类属性的访问。</p><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    address = <span class="string">'Earth'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line">p2 = Person(<span class="string">'Alice'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Person.address = '</span> + Person.address)</span><br><span class="line"></span><br><span class="line">p1.address = <span class="string">'China'</span></span><br><span class="line">print(<span class="string">'p1.address = '</span> + p1.address)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Person.address = '</span> + Person.address)</span><br><span class="line">print(<span class="string">'p2.address = '</span> + p2.address)</span><br></pre></td></tr></table></figure></p><pre><code>Person.address = Earthp1.address = ChinaPerson.address = Earthp2.address = Earth</code></pre><p>我们发现，在设置了 p1.address = ‘China’ 后，p1访问 address 确实变成了 ‘China’，但是，Person.address和p2.address仍然是’Earch’，怎么回事？</p><blockquote><p>原因是 p1.address = ‘China’并 <strong>没有改变 Person 的 address</strong> ，而是给 p1这个实例绑定了<code>实例属性</code>address ，对p1来说，它有一个实例属性address（值是’China’），而它所属的类Person也有一个<code>类属性</code>address，所以:</p></blockquote><ul><li>访问 p1.address 时，优先查找实例属性，返回’China’。</li><li>访问 p2.address 时，p2没有实例属性address，但是有类属性address，因此返回’Earth’。</li></ul><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p><code>@classmethod</code> 装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    __count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">how_many</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.__count</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        Person.__count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(Person.how_many())</span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line">print(Person.how_many())</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>函数 <code>super(子类, self)</code> 将返回当前类继承的父类，然后调用<strong>init</strong>()方法，注意self参数已在super()中传入，在<strong>init</strong>()中将隐式传递，不需要写出（也不能写）。</p><p><strong>例如</strong>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, gender)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.gender = gender</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">Person</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, gender, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">super</span>(Student, <span class="keyword">self</span>).__init_<span class="number">_</span>(name, gender)</span><br><span class="line">        <span class="keyword">self</span>.score = score</span><br></pre></td></tr></table></figure><blockquote><p>一定要用 super(Student, self).<strong>init</strong>(name, gender) 去初始化父类，否则，继承自 Person 的 Student 将没有 name 和 gender。</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="面相对象比较"><a href="#面相对象比较" class="headerlink" title="面相对象比较"></a>面相对象比较</h2><p>使用魔术方法，这里有一种巧妙的表达：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">object</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'(%s: %s)'</span> % (<span class="keyword">self</span>.name, <span class="keyword">self</span>.score)</span><br><span class="line"></span><br><span class="line">    __repr_<span class="number">_</span> = __str_<span class="number">_</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__cmp__</span><span class="params">(<span class="keyword">self</span>, s)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> False == isinstance(s, Student)<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -cmp(<span class="keyword">self</span>.score, s.score) <span class="keyword">or</span> cmp(<span class="keyword">self</span>.name, s.name)</span><br><span class="line"></span><br><span class="line">L = [Student(<span class="string">'Tim'</span>, <span class="number">99</span>), Student(<span class="string">'Bob'</span>, <span class="number">88</span>), Student(<span class="string">'Alice'</span>, <span class="number">99</span>)]</span><br><span class="line"></span><br><span class="line">print(sorted(L))</span><br></pre></td></tr></table></figure></p><blockquote><p>需要特别注意的是，python 3.x 中不再支持 cmp() 函数，取而代之使用：<br><strong>lt</strong>() for sorting, <strong>eq</strong>() with <strong>hash</strong>(), and other rich comparisons as needed. (If you really need the cmp() functionality, you could use the expression (a &gt; b) - (a &lt; b) as the equivalent for cmp(a, b).</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="不定参数的传递"><a href="#不定参数的传递" class="headerlink" title="不定参数的传递"></a>不定参数的传递</h2><p>对于Person类的定义：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, gender)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.gender = gender</span><br></pre></td></tr></table></figure></p><p>希望除了 name和gender 外，可以提供任意额外的关键字参数，并绑定到实例，请修改 Person 的 <strong>init</strong>() 定 义，完成该功能。</p><p><strong>例程</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, **kw)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        <span class="comment"># Python 2.7 中 iteritems 独立封装，返回一个迭代器；但是3.*版本整合进了字典内建函数 items。</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> kw.items():</span><br><span class="line">            setattr(self, k, v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">'Bob'</span>, <span class="string">'Male'</span>, age=<span class="number">18</span>, course=<span class="string">'Python'</span>)</span><br><span class="line">print(p.age)</span><br><span class="line">print(p.course)</span><br><span class="line"><span class="comment"># Python 2.7 中 filter 对象可以直接输出，但是在3.*版本需要强制转化成 list 对象，否则输出 &lt;filter object at ...&gt;</span></span><br><span class="line">print(list(filter(<span class="keyword">lambda</span> x: x[<span class="number">0</span>] != <span class="string">'_'</span>, dir(p))))</span><br></pre></td></tr></table></figure></p><blockquote><ul><li><code>**kw</code> 以字典的形式接受参数表</li><li><code>*args</code> 以元组的方式接受参数表</li><li>关于Python版本和函数使用（<code>链接</code>）</li></ul></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p><code>__repr__</code>：调试时输出的字符串<br><code>__str__</code>：用户使用时输出的字符串<br><code>__cmp__</code>：sorted等函数调用时返回结果，可以配合 <code>cmp()</code> 函数等使用<br><code>__len__</code>：（略）<br><code>__add__</code>、<code>__sub__</code>、<code>__mul__</code>、<code>__div__</code></p><h3 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h3><p>由于Python是动态语言，任何实例在运行期都可以动态地添加属性。</p><p>如果要限制添加的属性，例如，Student类只允许添加 name、gender和score 这3个属性，就可以利用Python的一个特殊的 <code>__slots__</code> 来实现。</p><p>顾名思义，<code>__slots__</code> 是指一个类允许的属性列表：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">object</span>):</span></span><br><span class="line">    __slots_<span class="number">_</span> = (<span class="string">'name'</span>, <span class="string">'gender'</span>, <span class="string">'score'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, gender, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.gender = gender</span><br><span class="line">        <span class="keyword">self</span>.score = score</span><br></pre></td></tr></table></figure></p><p>现在，对实例进行操作：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; s = Student(<span class="string">'Bob'</span>, <span class="string">'male'</span>, <span class="number">59</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s.name = <span class="string">'Tim'</span> <span class="comment"># OK</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s.score = <span class="number">99</span> <span class="comment"># OK</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s.grade = <span class="string">'A'</span></span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">  ...</span><br><span class="line"><span class="symbol">AttributeError:</span> <span class="string">'Student'</span> object has no attribute <span class="string">'grade'</span></span><br></pre></td></tr></table></figure></p><p><code>__slots__</code>的目的是限制当前类所能拥有的属性，如果不需要添加任意动态的属性，使用<strong>slots</strong>也能节省内存。</p><h4 id="在继承中使用slot"><a href="#在继承中使用slot" class="headerlink" title="在继承中使用slot"></a>在继承中使用<strong>slot</strong></h4><p>假设Person类通过<strong>slots</strong>定义了name和gender，请在派生类Student中通过<strong>slots</strong>继续添加score的定义，使Student类可以实现name、gender和score 3个属性。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="title">object</span>):</span></span><br><span class="line"></span><br><span class="line">    __slots_<span class="number">_</span> = (<span class="string">'name'</span>, <span class="string">'gender'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, gender)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.gender = gender</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">Person</span>):</span></span><br><span class="line"></span><br><span class="line">    __slots_<span class="number">_</span> = (<span class="string">'score'</span>,)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, gender, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">super</span>(Student, <span class="keyword">self</span>).__init_<span class="number">_</span>(name, gender)</span><br><span class="line">        <span class="keyword">self</span>.score = score</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">'Bob'</span>, <span class="string">'male'</span>, <span class="number">59</span>)</span><br><span class="line">s.name = <span class="string">'Tim'</span></span><br><span class="line">s.score = <span class="number">99</span></span><br><span class="line">print(s.score)</span><br></pre></td></tr></table></figure></p><h3 id="call"><a href="#call" class="headerlink" title="call"></a><strong>call</strong></h3><p>在Python中，函数其实是一个对象：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; f = abs</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; f.__name_<span class="number">_</span></span><br><span class="line"><span class="string">'abs'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; f(-<span class="number">123</span>)</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></p><p>由于 f 可以被调用，所以，f 被称为可调用对象。</p><p>所有的函数都是可调用对象。</p><p>一个类实例也可以变成一个可调用对象，只需要实现一个特殊方法<strong>call</strong>()。</p><p>我们把 Person 类变成一个可调用对象：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, gender)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(<span class="keyword">self</span>, friend)</span></span><span class="symbol">:</span></span><br><span class="line">        print(<span class="string">'My name is %s...'</span> % <span class="keyword">self</span>.name)</span><br><span class="line">        print(<span class="string">'My friend is %s...'</span> % friend)</span><br></pre></td></tr></table></figure></p><p>现在可以对 Person 实例直接调用：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; p = Person(<span class="string">'Bob'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; p(<span class="string">'Tim'</span>)</span><br><span class="line">My name is Bob...</span><br><span class="line">My friend is Tim...</span><br></pre></td></tr></table></figure></p><p>单看 p(‘Tim’) 你无法确定 p 是一个函数还是一个类实例，所以，在Python中，函数也是对象，对象和函数的区别并不显著。</p><p><strong>例程（打印斐波那契数列）：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,num)</span>:</span></span><br><span class="line">        L = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">        i = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; num:</span><br><span class="line">            L.append(L[i<span class="number">-2</span>]+L[i<span class="number">-1</span>])</span><br><span class="line">            i=i+<span class="number">1</span>     </span><br><span class="line">        <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line">f = Fib()</span><br><span class="line"><span class="keyword">print</span> f(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="get-set-及-property-装饰器"><a href="#get-set-及-property-装饰器" class="headerlink" title="get()/set() 及 @property 装饰器"></a>get()/set() 及 @property 装饰器</h2><p>考察 Student 类：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.score = score</span><br></pre></td></tr></table></figure></p><p>当我们想要修改一个 Student 的 scroe 属性时，可以这么写：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Student(<span class="string">'Bob'</span>, <span class="number">59</span>)</span><br><span class="line">s<span class="selector-class">.score</span> = <span class="number">60</span></span><br></pre></td></tr></table></figure></p><p>但是也可以这么写：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s<span class="selector-class">.score</span> = <span class="number">1000</span></span><br></pre></td></tr></table></figure></p><p>显然，直接给属性赋值无法检查分数的有效性。</p><p>如果利用两个方法：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.__score = score</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.__score</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(<span class="keyword">self</span>, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> score &lt; <span class="number">0</span> <span class="keyword">or</span> score &gt; <span class="number">100</span><span class="symbol">:</span></span><br><span class="line">            raise ValueError(<span class="string">'invalid score'</span>)</span><br><span class="line">        <span class="keyword">self</span>.__score = score</span><br></pre></td></tr></table></figure></p><p>这样一来，s.set_score(1000) 就会报错。</p><p>这种使用 get/set 方法来封装对一个属性的访问在许多面向对象编程的语言中都很常见。</p><p>但是写 s.get_score() 和 s.set_score() 没有直接写 s.score 来得直接。</p><p>有没有两全其美的方法？——有。</p><p>因为Python支持高阶函数，在函数式编程中我们介绍了装饰器函数，可以用装饰器函数把 get/set 方法“装饰”成属性调用：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.__score = score</span><br><span class="line">    @property</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.__score</span><br><span class="line">    @score.setter</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(<span class="keyword">self</span>, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> score &lt; <span class="number">0</span> <span class="keyword">or</span> score &gt; <span class="number">100</span><span class="symbol">:</span></span><br><span class="line">            raise ValueError(<span class="string">'invalid score'</span>)</span><br><span class="line">        <span class="keyword">self</span>.__score = score</span><br></pre></td></tr></table></figure></p><blockquote><p>注意: 第一个score(self)是get方法，用@property装饰，第二个score(self, score)是set方法，用@score.setter装饰，@score.setter是前一个@property装饰后的副产品。</p></blockquote><p>现在，就可以像使用属性一样设置score了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; s = Student(<span class="string">'Bob'</span>, 59)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; s.score = 60</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span> s.score</span></span><br><span class="line">60</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; s.score = 1000</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: invalid score</span><br></pre></td></tr></table></figure></p><p>说明对 score 赋值实际调用的是 set方法。</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="关于Python版本和函数使用"><a href="#关于Python版本和函数使用" class="headerlink" title="关于Python版本和函数使用"></a>关于Python版本和函数使用</h2><p><strong>map、filter 和 reduce</strong><br>这三个函数号称是函数式编程的代表。在 Python3.x 和 Python2.x 中也有了很大的差异。</p><p>首先我们先简单的在 Python2.x 的交互下输入 map 和 filter,看到它们两者的类型是 <code>built-in function</code> (内置函数):</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; map</span><br><span class="line">&lt;built-in function map&gt;</span><br><span class="line">&gt;&gt;&gt; filter</span><br><span class="line">&lt;built-in function filter&gt;</span><br></pre></td></tr></table></figure><p>它们输出的结果类型都是列表:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">map</span>(lambda <span class="attribute">x</span>:x *<span class="number">2</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="selector-attr">[2, 4, 6]</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">filter</span>(lambda <span class="attribute">x</span>:x %<span class="number">2</span> ==<span class="number">0</span>,range(<span class="number">10</span>))</span><br><span class="line"><span class="selector-attr">[0, 2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>但是在Python 3.x中它们却不是这个样子了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; map</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">map</span>'&gt;</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; map(print,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">&lt;map object at <span class="number">0x10d8bd400</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; filter</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">filter</span>'&gt;</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; filter(lambda <span class="symbol">x:</span>x % <span class="number">2</span> == <span class="number">0</span>, range(<span class="number">10</span>))</span><br><span class="line">&lt;filter object at <span class="number">0x10d8bd3c8</span>&gt;</span><br></pre></td></tr></table></figure><p>首先它们从函数变成了类，其次，它们的返回结果也从当初的列表成了一个可迭代的对象, 我们尝试用 next 函数来进行手工迭代:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f =filter(<span class="name">lambda</span> x<span class="symbol">:x</span> %<span class="number">2</span> ==0, range(<span class="number">10</span>))</span><br><span class="line">&gt;&gt;&gt; next(<span class="name">f</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt;&gt;&gt; next(<span class="name">f</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt; next(<span class="name">f</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt; next(<span class="name">f</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>对于比较高端的 reduce 函数，它在 Python 3.x 中已经不属于 built-in 了，被挪到 functools 模块当中。</p><blockquote><p>另外，关于更多 Python 2.x 和 Python 3.x 中的不同，可以参看 <a href="/2018/03/28/python-translation/#"><code>这里</code></a>，希望有时间我可以仔细翻译一下。</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python进阶函数和功能_#1（函数式编程）</title>
      <link href="/2018/03/19/python-adv/"/>
      <content type="html"><![CDATA[<p>最开始接触 Python 是因为女票选了 Python 的课，为了秀一下“男友力”，我花了2个钟头读完 Python 3.6 的文档，做了她一学期的私人答疑。嗯，一点点秀。</p><p>在使用Python的过程中，其 <strong>解释性的语言</strong>，<strong>众多彩蛋语法糖</strong>，<strong>优雅的数据结构</strong>，<strong>优秀的包管理工具</strong>，<strong>大量的例程和学习资料</strong>，让我一直把 Python 作为我的 <strong>首要编程语言</strong>。</p><p>本文是我在研究 Python 语言本身 <strong>高级特性</strong> 时所做的笔记，会慢慢更新。<br>如果你恰好也和我一样喜欢 Python。希望本文能对你的学习有所帮助！</p><div id="content"></div><blockquote><p><strong>下面是快捷方式</strong>（点击直达）<br><a href="/2018/03/19/python-adv/#map"><code>map()</code></a>、<a href="/2018/03/19/python-adv/#reduce"><code>reduce()</code></a>、<a href="/2018/03/19/python-adv/#filter"><code>filter()</code></a>、<a href="/2018/03/19/python-adv/#sorted"><code>sorted()</code></a>、<a href="/2018/03/19/python-adv/#Python中返回函数"><code>返回函数</code></a>、<a href="/2018/03/19/python-adv/#闭包"><code>闭包</code></a>、<a href="/2018/03/19/python-adv/#匿名函数"><code>匿名函数</code></a>、<a href="/2018/03/19/python-adv/#装饰器"><code>装饰器</code></a>、<a href="/2018/03/19/python-adv/#偏函数"><code>偏函数</code></a></p></blockquote><a id="more"></a><h2 id="map"><a href="#map" class="headerlink" title="map()"></a><strong>map()</strong></h2><p>map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。</p><p>例如，对于list [1, 2, 3, 4, 5, 6, 7, 8, 9]</p><p>如果希望把list的每个元素都作平方，就可以用map()函数：</p><p><img src="http://img.mukewang.com/54c8a7e40001327303410245.png" alt="file-list"></p><p>因此，我们只需要传入函数f(x)=x*x，就可以利用map()函数完成这个计算：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line">print(map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure></p><p><strong>输出结果：</strong>[1, 4, 9, 10, 25, 36, 49, 64, 81]</p><p><code>注意：map()函数不改变原有的 list，而是返回一个新的 list。</code></p><p>利用map()函数，可以把一个 list 转换为另一个 list，只需要传入转换函数。</p><p>由于list包含的元素可以是任何类型，因此，map() 不仅仅可以处理只包含数值的 list，事实上它可以处理包含任意类型的 list，只要传入的函数f可以处理这种数据类型。</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a><strong>reduce()</strong></h2><p>reduce()函数也是Python内置的一个高阶函数。reduce()函数接收的参数和 map()类似，<code>一个函数 f</code>，<code>一个list</code>，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。</p><p>例如，编写一个f函数，接收x和y，返回x和y的和：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p><p>调用 reduce(f, [1, 3, 5, 7, 9])时，reduce函数将做如下计算：</p><blockquote><ol><li>先计算头两个元素：f(1, 3)，结果为4； </li><li>再把结果和第3个元素计算：f(4, 5)，结果为9； </li><li>再把结果和第4个元素计算：f(9,7)，结果为16； </li><li>再把结果和第5个元素计算：f(16, 9)，结果为25；</li><li>由于没有更多的元素了，计算结束，返回结果25。</li></ol></blockquote><p>上述计算实际上是对 list的所有元素求和。虽然Python内置了求和函数sum()，但是，利用reduce()求和也很简单。</p><p>reduce()还可以接收第3个可选参数，作为计算的初始值。如果把初始值设为100，计算：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], <span class="number">100</span>)</span><br></pre></td></tr></table></figure></p><p>结果将变为<code>125</code>，因为第一轮计算是：</p><p>计算初始值和第一个元素：<code>f(100, 1)</code>，结果为<code>101</code>。</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a><strong>filter()</strong></h2><p>filter()函数是 Python 内置的另一个有用的高阶函数，filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，<strong>filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。</strong></p><p>例如，要从一个list [1, 4, 6, 7, 9, 12, 17]中删除偶数，保留奇数，首先，要编写一个判断奇数的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>然后，利用filter()过滤掉偶数：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(is_odd, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">17</span>])</span><br></pre></td></tr></table></figure></p><p><strong>结果:</strong> [1, 7, 9, 17]</p><p>利用filter()，可以完成很多有用的功能，例如，删除 None 或者空字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_not_empty</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> len(s.strip()) &gt; <span class="number">0</span></span><br><span class="line">filter(is_not_empty, [<span class="string">'test'</span>, <span class="keyword">None</span>, <span class="string">''</span>, <span class="string">'str'</span>, <span class="string">'  '</span>, <span class="string">'END'</span>])</span><br></pre></td></tr></table></figure></p><p><strong>结果：</strong>[‘test’, ‘str’, ‘END’]</p><p><code>注意: s.strip(rm) 删除 s 字符串中开头、结尾处的 rm 序列的字符。</code></p><p>当rm为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)，如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> = <span class="string">'     123'</span></span><br><span class="line"><span class="selector-tag">a</span>.strip()</span><br></pre></td></tr></table></figure></p><p><strong>结果：</strong> ‘123’<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a='<span class="symbol">\t</span><span class="symbol">\t</span>123<span class="symbol">\r</span><span class="symbol">\n</span>'</span><br><span class="line">a.strip()</span><br></pre></td></tr></table></figure></p><p><strong>结果：</strong>‘123’</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a><strong>sorted()</strong></h2><p>Python内置的 sorted()函数可对list进行排序：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">21</span>])</span><br><span class="line"></span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">21</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure></p><p>但 sorted()也是一个高阶函数，它可以接收一个比较函数来实现自定义排序，比较函数的定义是，传入两个待比较的元素 x, y，<strong>如果 x 应该排在 y 的前面，返回 -1，如果 x 应该排在 y 的后面，返回 1。如果 x 和 y 相等，返回 0。</strong></p><p>因此，如果我们要实现倒序排序，只需要编写一个reversed_cmp函数：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversed_cmp</span><span class="params">(x, y)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="symbol">y:</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="symbol">y:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>这样，调用 sorted() 并传入 reversed_cmp 就可以实现倒序排序：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">21</span>], reversed_cmp)</span><br><span class="line">[<span class="number">36</span>, <span class="number">21</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><p>sorted()也可以对字符串进行排序，字符串默认按照ASCII大小来比较：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>])</span><br><span class="line">[<span class="string">'Credit'</span>, <span class="string">'Zoo'</span>, <span class="string">'about'</span>, <span class="string">'bob'</span>]</span><br></pre></td></tr></table></figure></p><p>‘Zoo’排在’about’之前是因为’Z’的ASCII码比’a’小。</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>sort()是<code>list内置</code>的方法，也可以和python内置的全局sorted()方法一样来对可迭代的序列排序生成新的序列。</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="key参数-函数"><a href="#key参数-函数" class="headerlink" title="key参数/函数"></a>key参数/函数</h3><p>从python2.4开始，list.sort()和sorted()函数增加了key参数来指定一个函数，此函数将在每个元素比较前被调用。 例如通过key指定的函数来忽略字符串的大小写：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted(<span class="string">"This is a test string from Andrew"</span>.<span class="built_in">split</span>(), <span class="built_in">key</span>=<span class="built_in">str</span>.lower)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'Andrew'</span>, <span class="string">'from'</span>, <span class="string">'is'</span>, <span class="string">'string'</span>, <span class="string">'test'</span>, <span class="string">'This'</span>]</span><br></pre></td></tr></table></figure></p><p>key参数的值为一个函数，此函数只有一个参数且返回一个值用来进行比较。这个技术是快速的因为key指定的函数将准确地对每个元素调用。</p><p>更广泛的使用情况是用复杂对象的某些值来对复杂对象的序列排序，例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; student_tuples = [</span><br><span class="line">        (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>),</span><br><span class="line">        (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>),</span><br><span class="line">        (<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>),</span><br><span class="line">]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(student_tuples, key=lambda <span class="symbol">student:</span> student[<span class="number">2</span>])   <span class="comment"># sort by age</span></span><br><span class="line">[(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</span><br></pre></td></tr></table></figure><p>对对象的属性进行索引：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, grade, age)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.name = name</span><br><span class="line">            <span class="keyword">self</span>.grade = grade</span><br><span class="line">            <span class="keyword">self</span>.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> repr((<span class="keyword">self</span>.name, <span class="keyword">self</span>.grade, <span class="keyword">self</span>.age))</span><br><span class="line"></span><br><span class="line">student_objects = [</span><br><span class="line">    Student(<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>),</span><br><span class="line">    Student(<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>),</span><br><span class="line">    Student(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sorted(student_objects, key=lambda <span class="symbol">student:</span> student.age)   <span class="comment"># sort by age</span></span><br></pre></td></tr></table></figure></p><pre><code>结果：[(&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;john&#39;, &#39;A&#39;, 15)]</code></pre><p>key函数不仅可以访问需要排序元素的内部数据，还可以访问外部的资源，例如，如果学生的成绩是存储在dictionary中的，则 <strong>可以使用此dictionary来对学生名字的list排序</strong> ，如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; students = [<span class="string">'dave'</span>, <span class="string">'john'</span>, <span class="string">'jane'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; newgrades = &#123;<span class="string">'john'</span>: <span class="string">'F'</span>, <span class="string">'jane'</span><span class="symbol">:<span class="string">'A'</span></span>, <span class="string">'dave'</span>: <span class="string">'C'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(students, key=newgrades.__getitem_<span class="number">_</span>)</span><br><span class="line">[<span class="string">'jane'</span>, <span class="string">'dave'</span>, <span class="string">'john'</span>]</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="Operator-模块函数"><a href="#Operator-模块函数" class="headerlink" title="Operator 模块函数"></a>Operator 模块函数</h3><p>上面的key参数的使用非常广泛，因此python提供了一些方便的函数来使得访问方法更加容易和快速。<code>operator模块</code>有<code>itemgetter</code>，<code>attrgetter</code>，从2.6开始还增加了<code>methodcaller方法</code>。使用这些方法，上面的操作将变得更加简洁和快速：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; from operator import itemgetter, attrgetter</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(student_tuples, key=itemgetter(<span class="number">2</span>))</span><br><span class="line">[(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(student_objects, key=attrgetter(<span class="string">'age'</span>))</span><br><span class="line">[(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</span><br></pre></td></tr></table></figure><p>operator模块还允许 <strong>多级</strong> 的排序，例如，先以grade，然后再以age来排序：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(student_tuples, key=itemgetter(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">[(<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>), (<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(student_objects, key=attrgetter(<span class="string">'grade'</span>, <span class="string">'age'</span>))</span><br><span class="line">[(<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>), (<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="升序和降序"><a href="#升序和降序" class="headerlink" title="升序和降序"></a>升序和降序</h3><p>list.sort()和sorted()都接受一个<code>参数reverse</code>（True or False）来表示升序或降序排序。例如对上面的student降序排序如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(<span class="number">2</span>), <span class="keyword">reverse</span>=<span class="literal">True</span>)</span><br><span class="line">[(<span class="symbol">'john</span>', <span class="string">'A'</span>, <span class="number">15</span>), (<span class="symbol">'jane</span>', <span class="string">'B'</span>, <span class="number">12</span>), (<span class="symbol">'dave</span>', <span class="string">'B'</span>, <span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; sorted(student_objects, key=attrgetter(<span class="symbol">'age</span>'), <span class="keyword">reverse</span>=<span class="literal">True</span>)</span><br><span class="line">[(<span class="symbol">'john</span>', <span class="string">'A'</span>, <span class="number">15</span>), (<span class="symbol">'jane</span>', <span class="string">'B'</span>, <span class="number">12</span>), (<span class="symbol">'dave</span>', <span class="string">'B'</span>, <span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="排序的稳定性和复杂排序"><a href="#排序的稳定性和复杂排序" class="headerlink" title="排序的稳定性和复杂排序"></a>排序的稳定性和复杂排序</h3><p>从python2.2开始，排序被保证为稳定的。意思是说多个元素如果有相同的key，则排序前后他们的先后顺序不变。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; data = [(<span class="string">'red'</span>, <span class="number">1</span>), (<span class="string">'blue'</span>, <span class="number">1</span>), (<span class="string">'red'</span>, <span class="number">2</span>), (<span class="string">'blue'</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(data, key=itemgetter(<span class="number">0</span>))</span><br><span class="line">[(<span class="string">'blue'</span>, <span class="number">1</span>), (<span class="string">'blue'</span>, <span class="number">2</span>), (<span class="string">'red'</span>, <span class="number">1</span>), (<span class="string">'red'</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure></p><p>注意在排序后’blue’的顺序被保持了，即（’blue’, 1）在（’blue’, 2）的前面。<br>更复杂地你可以构建<code>多个步骤</code>来进行更复杂的排序，例如对student数据先以grade降序排列，然后再以age升序排列。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = sorted(student_objects, <span class="built_in">key</span>=attrgetter(<span class="string">'age'</span>))     # <span class="built_in">sort</span> on secondary <span class="built_in">key</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; sorted(s, <span class="built_in">key</span>=attrgetter(<span class="string">'grade'</span>), <span class="built_in">reverse</span>=True)       # now <span class="built_in">sort</span> on primary <span class="built_in">key</span>, descending</span><br><span class="line">[(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="最老土的排序方法-DSU"><a href="#最老土的排序方法-DSU" class="headerlink" title="最老土的排序方法-DSU"></a>最老土的排序方法-DSU</h3><p>我们称其为DSU（Decorate-Sort-Undecorate）,原因为排序的过程需要下列三步：</p><ol><li>对原始的list进行装饰，使得新list的值可以用来控制排序；</li><li>对装饰后的list排序；</li><li>将装饰删除，将排序后的装饰list重新构建为原来类型的list；</li></ol><p>例如，使用DSU方法来对student数据根据grade排序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>decorated = [(student.grade, i, student) <span class="keyword">for</span> i, student <span class="keyword">in</span> enumerate(student_objects)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>decorated.sort()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[student <span class="keyword">for</span> grade, i, student <span class="keyword">in</span> decorated]               <span class="comment"># undecorate</span></span><br><span class="line">[(<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>)]</span><br></pre></td></tr></table></figure></p><p>上面的比较能够工作，原因是 <code>__tuples是可以用来比较的__</code></p><blockquote><p>tuples间的比较首先比较tuples的第一个元素，如果第一个相同再比较第二个元素，以此类推。</p></blockquote><p>并不是所有的情况下都需要在以上的tuples中包含索引，但是包含索引可以有以下好处：</p><ul><li>排序是<code>稳定的</code>，如果两个元素有相同的key，则他们的原始先后顺序保持不变；</li><li>原始的元素不必用来做比较，因为tuples的第一和第二元素用来比较已经是足够了。</li></ul><p>此方法被RandalL.在perl中广泛推广后，他的另一个名字为也被称为Schwartzian transform。</p><p>对大的list或list的元素计算起来太过复杂的情况下，在python2.4前，DSU很可能是最快的排序方法。但是在2.4之后，上面解释的key函数提供了类似的功能。</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="其他语言普遍使用的排序方法-cmp函数"><a href="#其他语言普遍使用的排序方法-cmp函数" class="headerlink" title="其他语言普遍使用的排序方法-cmp函数"></a>其他语言普遍使用的排序方法-cmp函数</h3><p>在python2.4前，sorted()和list.sort()函数没有提供key参数，但是提供了cmp参数来让用户指定比较函数。此方法在其他语言中也普遍存在。</p><p>在python3.0中，cmp参数被彻底的移除了，从而简化和统一语言，减少了高级比较和<strong>cmp</strong>方法的冲突。</p><p>在python2.x中cmp参数指定的函数用来进行元素间的比较。此函数需要2个参数，然后返回负数表示小于，0表示等于，正数表示大于。例如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">numeric_compare</span><span class="params">(x, y)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> x - y</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted([<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>], cmp=numeric_compare)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><p>或者你可以反序排序：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">reverse_numeric</span><span class="params">(x, y)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> y - x</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted([<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>], cmp=reverse_numeric)</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><blockquote><p>当我们将现有的2.x的代码移植到3.x时， <strong>需要将cmp函数转化为key函数</strong><br>以下的wrapper很有帮助：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmp_to_key</span><span class="params">(mycmp)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="string">'Convert a cmp= function into a key= function'</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">K</span>(<span class="title">object</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, obj, *args)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.obj = obj</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(<span class="keyword">self</span>, other)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(<span class="keyword">self</span>.obj, other.obj) &lt; <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(<span class="keyword">self</span>, other)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(<span class="keyword">self</span>.obj, other.obj) &gt; <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(<span class="keyword">self</span>, other)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(<span class="keyword">self</span>.obj, other.obj) == <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__le__</span><span class="params">(<span class="keyword">self</span>, other)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(<span class="keyword">self</span>.obj, other.obj) &lt;= <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__ge__</span><span class="params">(<span class="keyword">self</span>, other)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(<span class="keyword">self</span>.obj, other.obj) &gt;= <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__ne__</span><span class="params">(<span class="keyword">self</span>, other)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(<span class="keyword">self</span>.obj, other.obj) != <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> K</span><br></pre></td></tr></table></figure></p><p>当需要将cmp转化为key时，只需要：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>], <span class="type">key</span>=cmp_to_key(reverse_numeric))</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p></blockquote><p>从python2.7，cmp_to_key()函数被增加到了functools模块中。</p><p>其实排序在内部是调用元素的<strong>cmp</strong>来进行的，所以我们可以为元素类型增加<strong>cmp</strong>方法使得元素可比较，例如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; Student.__lt_<span class="number">_</span> = lambda self, <span class="symbol">other:</span> self.age &lt; other.age</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(student_objects)</span><br><span class="line">[(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a><strong>返回函数</strong></h2><p>Python的函数不但可以返回int、str、list、dict等数据类型，还可以返回函数！</p><p>例如，定义一个函数 f()，我们让它返回一个函数 g，可以这样写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'call f()...'</span>)</span><br><span class="line">    <span class="comment"># 定义函数g:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'call g()...'</span>)</span><br><span class="line">    <span class="comment"># 返回函数g:</span></span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure></p><p>仔细观察上面的函数定义，我们在函数 f 内部又定义了一个函数 g。由于函数 g 也是一个对象，函数名 g 就是指向函数 g 的变量，所以，最外层函数 f 可以返回变量 g，也就是函数 g 本身。</p><p>调用函数 f，我们会得到 f 返回的一个函数：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; x = f()   <span class="comment"># 调用f()</span></span><br><span class="line">call f()...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x   <span class="comment"># 变量x是f()返回的函数：</span></span><br><span class="line">&lt;function g at <span class="number">0x1037bf320</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x()   <span class="comment"># x指向函数，因此可以调用</span></span><br><span class="line">call g()...   <span class="comment"># 调用x()就是执行g()函数定义的代码</span></span><br></pre></td></tr></table></figure></p><p>请注意区分返回函数和返回值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myabs</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> abs   <span class="comment"># 返回函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myabs2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> abs(x)   <span class="comment"># 返回函数调用的结果，返回值是一个数值</span></span><br></pre></td></tr></table></figure></p><p>返回函数可以把一些计算延迟执行。例如，如果定义一个普通的求和函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(lst)</span><br></pre></td></tr></table></figure></p><p>调用calc_sum()函数时，将立刻计算并得到结果：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>但是，如果返回一个函数，就可以“延迟计算”：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum(lst)</span><br><span class="line">    <span class="keyword">return</span> lazy_sum</span><br><span class="line"><span class="comment"># 调用calc_sum()并没有计算出结果，而是返回函数:</span></span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; f = calc_sum([1, 2, 3, 4])</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; f</span></span><br><span class="line">&lt;function lazy_sum at 0x1037bfaa0&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 对返回的函数进行调用时，才计算出结果:</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; f()</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>由于可以返回函数，我们在后续代码里就可以决定到底要不要调用该函数。</p><p>编写一个函数calc_prod(lst)，它接收一个list，返回一个函数，返回函数可以计算参数的乘积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_prod</span><span class="params">(lst)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方法一：</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prod</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x * y, lst)</span><br><span class="line">    <span class="keyword">return</span> prod</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方法二：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> :reduce(<span class="keyword">lambda</span> x, y: x * y, lst)</span><br><span class="line"></span><br><span class="line">f = calc_prod([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(f())</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><strong>闭包</strong></h2><p>在函数内部定义的函数和外部定义的函数是一样的，只是他们无法被外部访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'g()...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f()...'</span>)</span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure><p>将 g 的定义移入函数 f 内部，防止其他代码调用 g：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f()...'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'g()...'</span>)</span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure><p>但是，考察上一小节定义的 calc_sum 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum(lst)</span><br><span class="line">    <span class="keyword">return</span> lazy_sum</span><br></pre></td></tr></table></figure><p><code>注意: 发现没法把 lazy_sum 移到 calc_sum 的外部，因为它引用了 calc_sum 的参数 lst。</code></p><p>像这种内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为闭包（Closure）。</p><p>闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。举例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 希望一次返回3个函数，分别计算1x1,2x2,3x3:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">             <span class="keyword">return</span> i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br></pre></td></tr></table></figure><p>你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果全部都是 9（请自己动手验证）。</p><p>原因就是当count()函数返回了3个函数时，这3个函数所引用的<code>变量 i</code> 的值已经变成了3。由于f1、f2、f3并没有被调用，所以，此时他们并未计算 i*i，当 f1 被调用时：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; f1()</span><br><span class="line"><span class="number">9</span>     <span class="comment"># 因为f1现在才计算i*i，但现在i的值已经变为3</span></span><br></pre></td></tr></table></figure><p>因此，返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p><blockquote><p><strong>返回闭包不能引用循环变量，请改写count()函数，让它正确返回能计算1x1、2x2、3x3的函数。</strong></p></blockquote><p>考察下面的函数 f:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> j*j</span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure></p><p>它可以正确地返回一个闭包g，g所引用的变量j不是循环变量，因此将正常执行。<br>在count函数的循环内部，如果借助f函数，就可以避免引用循环变量i。</p><p><strong>参考代码:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    ---</span><br><span class="line">        <span class="comment"># 写法一：</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">                <span class="keyword">return</span> j*j</span><br><span class="line">            <span class="keyword">return</span> g</span><br><span class="line">        r = f(i)</span><br><span class="line">        fs.append(r)</span><br><span class="line">    ---</span><br><span class="line">        <span class="comment"># 写法二：</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">lambda</span> : i*i</span><br><span class="line">        fs.append(f(i))</span><br><span class="line">    ---</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line">print(f1(), f2(), f3())</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><strong>匿名函数</strong></h2><p>高阶函数可以接收函数做参数，有些时候，我们不需要显式地定义函数，直接传入匿名函数更方便。</p><p>在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算 f(x)=x2 时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">map</span>(lambda <span class="attribute">x</span>: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="selector-attr">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure><p>通过对比可以看出，匿名函数 <code>lambda x: x * x</code> 实际上就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br></pre></td></tr></table></figure><p>关键字<code>lambda</code>表示匿名函数，冒号前面的 x 表示<code>函数参数</code>。</p><blockquote><p>匿名函数有个限制，就是只能有一个表达式，不写return，返回值就是该表达式的结果。</p></blockquote><p>使用匿名函数，可以<code>不必定义函数名</code>，直接创建一个函数对象，很多时候可以简化代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">sorted</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">0</span>], lambda x,<span class="attribute">y</span>: -cmp(x,y))</span><br><span class="line"><span class="selector-attr">[9, 5, 3, 1, 0]</span></span><br></pre></td></tr></table></figure><p>返回函数的时候，也可以返回匿名函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; myabs = lambda x: -x <span class="keyword">if</span> x &lt; 0 <span class="keyword">else</span> x </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; myabs(-1)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; myabs(1)</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>不改变函数本身，但是改变函数功能。</p><p>使用高阶函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_f1</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(<span class="string">'call'</span> + f.__name__ + <span class="string">'()'</span>)</span><br><span class="line">        <span class="keyword">return</span> f(x)</span><br><span class="line">    <span class="keyword">return</span> fn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始调用</span></span><br><span class="line">g1 = new_f1(f1)</span><br><span class="line">print(g1(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐藏原始函数的调用</span></span><br><span class="line">f1 = new_f1(f1)</span><br><span class="line">print(f1(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>decorator</code> 用Python提供的 <code>@</code> 语法，这样可以避免手动编写 <code>f = decorate(f)</code> 这样的代码。</p></blockquote><p>装饰器的作用：</p><ul><li>打印日志：@log</li><li>检测性能：@performance</li><li>数据库失误：@transaction</li><li>URL路由：@post(‘/register’)</li></ul><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="无参数decorator"><a href="#无参数decorator" class="headerlink" title="无参数decorator"></a>无参数decorator</h3><p>考察一个@log的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(<span class="string">'call '</span> + f.__name__ + <span class="string">'()...'</span>)</span><br><span class="line">        <span class="keyword">return</span> f(x)</span><br><span class="line">    <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure><p>对于阶乘函数，@log工作得很好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line">print(factorial(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">call</span></span> factorial()...</span><br><span class="line"><span class="number">3628800</span></span><br></pre></td></tr></table></figure><p>但是，对于参数不是一个的函数，调用将报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">"test.py"</span>, <span class="built_in">line</span> <span class="number">15</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    <span class="keyword">print</span>(<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">TypeError: fn() takes exactly <span class="number">1</span> <span class="keyword">argument</span> (<span class="number">2</span> given)</span><br></pre></td></tr></table></figure><p>因为 add() 函数需要传入两个参数，但是 @log 写死了只含一个参数的返回函数。</p><p>要让 @log 自适应任何参数定义的函数，可以利用Python的 <em>args 和 *</em>kw，保证任意个数的参数总是能正常调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call '</span> + f.__name__ + <span class="string">'()...'</span>)</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure><p>现在，对于任意函数，@log 都能正常工作。</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="带参数decorator"><a href="#带参数decorator" class="headerlink" title="带参数decorator"></a>带参数decorator</h3><p>考察上一节的 @log 装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(<span class="string">'call '</span> + f.__name__ + <span class="string">'()...'</span>)</span><br><span class="line">        <span class="keyword">return</span> f(x)</span><br><span class="line">    <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure><p>发现对于被装饰的函数，log打印的语句是不能变的（除了函数名）。</p><p>如果有的函数非常重要，希望打印出’[INFO] call xxx()…’，有的函数不太重要，希望打印出’[DEBUG] call xxx()…’，这时，log函数本身就需要传入’INFO’或’DEBUG’这样的参数，类似这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log('DEBUG')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>把上面的定义翻译成高阶函数的调用，就是：</p><p><code>my_func = log(&#39;DEBUG&#39;)(my_func)</code></p><p>上面的语句看上去还是比较绕，再展开一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log_decorator = log(<span class="string">'DEBUG'</span>)</span><br><span class="line">my_func = log_decorator(my_func)</span><br></pre></td></tr></table></figure><p>上面的语句又相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_decorator = log(<span class="string">'DEBUG'</span>)</span><br><span class="line"><span class="meta">@log_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>所以，带参数的log函数首先返回一个decorator函数，再让这个decorator函数接收my_func并返回新函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(prefix)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log_decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            print(<span class="string">'[%s] %s()...'</span> % (prefix, f.__name__))</span><br><span class="line">            <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> log_decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@log('DEBUG')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">print(test())</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="builtin-name">DEBUG</span>] test()<span class="built_in">..</span>.</span><br><span class="line">None</span><br></pre></td></tr></table></figure><p>对于这种3层嵌套的decorator定义，你可以先把它拆开：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准decorator:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'[%s] %s()...'</span> % (prefix, f.__name__))</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="keyword">return</span> log_decorator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回decorator:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(prefix)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> log_decorator(f)</span><br></pre></td></tr></table></figure><p>拆开以后会发现，调用会失败，因为在3层嵌套的decorator定义中，最内层的wrapper引用了最外层的参数prefix，所以，把一个闭包拆成普通的函数调用会比较困难。不支持闭包的编程语言要实现同样的功能就需要更多的代码。</p><p><strong>例程：函数运行时间打印</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">performance</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">per_dec</span><span class="params">(f)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            start = time.time()</span><br><span class="line">            ans = f(*args, **kw)</span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'call '</span>+f.__name__+<span class="string">'() in '</span>+ str(end-start) + s)</span><br><span class="line">            <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> fn</span><br><span class="line">    <span class="keyword">return</span> per_dec</span><br><span class="line"></span><br><span class="line"><span class="meta">@performance('s')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> factorial(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="完善decorator"><a href="#完善decorator" class="headerlink" title="完善decorator"></a>完善decorator</h3><p>@decorator可以动态实现函数功能的增加，但是，经过@decorator“改造”后的函数，和原函数相比，除了功能多一点外，有没有其它不同的地方？</p><p>在没有decorator的情况下，打印函数名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">print</span> f1.__name__</span><br></pre></td></tr></table></figure><pre><code>输出： f1</code></pre><p>有decorator的情况下，再打印函数名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call...'</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">print</span> f2.__name__</span><br></pre></td></tr></table></figure><pre><code>输出： wrapper</code></pre><p>可见，由于decorator返回的新函数函数名已经不是’f2’，而是@log内部定义的’wrapper’。 <strong>这对于那些依赖函数名的代码就会失效。</strong> decorator还改变了函数的<code>__doc__</code>等其它属性。如果要让调用者看不出一个函数经过了@decorator的“改造”，就需要把原函数的一些属性复制到新函数中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call...'</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">    wrapper.__name__ = f.__name__</span><br><span class="line">    wrapper.__doc__ = f.__doc__</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>这样写decorator很不方便，因为我们也很难把原函数的所有必要属性都一个一个复制到新函数上，所以Python内置的<code>functools</code>可以用来自动化完成这个“复制”的任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call...'</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>最后需要指出，由于我们把原函数签名改成了(<em>args, *</em>kw)，因此， <strong>无法获得原函数的原始参数信息</strong> 。即便我们采用固定参数来装饰只有一个参数的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call...'</span></span><br><span class="line">        <span class="keyword">return</span> f(x)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>也可能改变原函数的参数名，因为新函数的参数名始终是 ‘x’，原函数定义的参数名不一定叫 ‘x’。</p><p><strong>例程：函数运行时间打印</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动复制原函数的__doc__等其它属性(新增部分)</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">performance</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">per_dec</span><span class="params">(f)</span>:</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 自动复制原函数的__doc__等其它属性(新增部分)</span></span><br><span class="line"><span class="meta">        @functools.wraps(f)</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            start = time.time()</span><br><span class="line">            ans = f(*args, **kw)</span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'call '</span>+f.__name__+<span class="string">'() in '</span>+ str(end-start) + s)</span><br><span class="line">            <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> fn</span><br><span class="line">    <span class="keyword">return</span> per_dec</span><br><span class="line"></span><br><span class="line"><span class="meta">@performance('s')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">print(factorial(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>当一个函数有很多参数时，调用者就需要提供多个参数。如果减少参数个数，就可以简化调用者的负担。</p><p>比如，int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; int(<span class="string">'12345'</span>)</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>但int()函数还提供额外的<code>base参数</code>，默认值为10。如果传入base参数，就可以做 N 进制的转换：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; int(<span class="string">'12345'</span>, base=<span class="number">8</span>)</span><br><span class="line"><span class="number">5349</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; int(<span class="string">'12345'</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">74565</span></span><br></pre></td></tr></table></figure><p>假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到， <strong>可以定义一个int2()的函数，默认把base=2传进去</strong> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int2</span><span class="params">(x, base=<span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(x, base)</span><br></pre></td></tr></table></figure><p>这样，我们转换二进制就非常方便了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; int2(<span class="string">'1000000'</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; int2(<span class="string">'1010101'</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure><p><code>functools.partial</code> 就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import functools</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; int2 = functools.partial(int, base=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; int2(<span class="string">'1000000'</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; int2(<span class="string">'1010101'</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure><blockquote><p>所以，functools.partial可以把一个参数多的函数变成一个参数少的新函数，少的参数需要在创建时指定默认值，这样，新函数调用的难度就降低了。</p></blockquote><p><strong>例程：用functools.partial简化自定义排序函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line">sorted_ignore_case = functools.partial(sorted, key = str.lower)</span><br><span class="line">print(sorted_ignore_case([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>]))</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World !</title>
      <link href="/2018/03/18/new/"/>
      <content type="html"><![CDATA[<p><code>本文置顶。</code></p><p>这是庄心昊的 <strong>个人博客</strong> ，旨在分享个人学习路径中的所获所得，避免后生走弯路。<br>本博客中 <strong>所有代码均经过本人调试</strong> ，关于 <strong>调试环境</strong> 若无特殊说明请参看 <a href="/about/#env"><code>代码环境</code></a> 。</p><p>点 <strong><a href="/archives/"><code>这里</code></a></strong> 查看我的文章列表</p><blockquote><p><strong>注意：</strong>本博客内的所有文章采用&ensp; <strong><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></strong> &ensp;进行许可，转载请勿用于商业目的，并请著名原作者（若不是本人我会特别注明）及原文链接。</p></blockquote><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Happy coding !</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
    </entry>
    
    <entry>
      <title>汇编指令简析</title>
      <link href="/2017/10/09/asm/"/>
      <content type="html"><![CDATA[<p>本文是上学期学习汇编语言时候的课堂笔记。</p><div id="content"></div><blockquote><p><strong>分类索引</strong>（单击命令直接索引）</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">分类</th><th>命令</th></tr></thead><tbody><tr><td style="text-align:center">符号数相关</td><td><a href="/2017/10/09/asm/#1"><code>JG</code></a>、<a href="/2017/10/09/asm/#1"><code>JL</code></a>、<a href="/2017/10/09/asm/#2"><code>IMUL</code></a></td></tr><tr><td style="text-align:center">通用数据传送指令</td><td><a href="/2017/10/09/asm/#3"><code>MOV</code></a>、<a href="/2017/10/09/asm/#4"><code>POP</code></a>、<a href="/2017/10/09/asm/#4"><code>PUSH</code></a>、<a href="/2017/10/09/asm/#5"><code>XCHG</code></a>、<a href="/2017/10/09/asm/#6"><code>IN</code></a>、<a href="/2017/10/09/asm/#6"><code>OUT</code></a></td></tr><tr><td style="text-align:center">地址传送指令</td><td><a href="/2017/10/09/asm/#LEA"><code>LEA</code></a>、<a href="/2017/10/09/asm/#LDS"><code>LDS</code></a>、<a href="/2017/10/09/asm/#LES"><code>LES</code></a>、<a href="/2017/10/09/asm/#PUS"><code>PUSHF</code></a>、<a href="/2017/10/09/asm/#PUS"><code>POPF</code></a></td></tr><tr><td style="text-align:center">转换指令</td><td><a href="/2017/10/09/asm/#CBW"><code>CBW</code></a>、<a href="/2017/10/09/asm/#CBW"><code>CWD</code></a>、<a href="/2017/10/09/asm/#XLAT"><code>XLAT</code></a></td></tr><tr><td style="text-align:center">加减乘除</td><td><a href="/2017/10/09/asm/#PLU"><code>ADD</code></a>、<a href="/2017/10/09/asm/#PLU"><code>INC</code></a>、<a href="/2017/10/09/asm/#PLU"><code>ADC</code></a>、<a href="/2017/10/09/asm/#MIN"><code>SUB</code></a>、<a href="/2017/10/09/asm/#MIN"><code>DEC</code></a>、<a href="/2017/10/09/asm/#MIN"><code>NEG</code></a>、<a href="/2017/10/09/asm/#TIM"><code>MUL</code></a>、<a href="/2017/10/09/asm/#DIV"><code>DIV</code></a></td></tr><tr><td style="text-align:center">逻辑运算</td><td><a href="/2017/10/09/asm/#A"><code>AND</code></a>、<a href="/2017/10/09/asm/#A"><code>OR</code></a>、<a href="/2017/10/09/asm/#A"><code>XOR</code></a>、<a href="/2017/10/09/asm/#A"><code>NOT</code></a>、<a href="/2017/10/09/asm/#A"><code>TEST</code></a></td></tr><tr><td style="text-align:center">移位指令</td><td><a href="/2017/10/09/asm/#B"><code>SHL</code></a>、<a href="/2017/10/09/asm/#B"><code>SHR</code></a>、<a href="/2017/10/09/asm/#B"><code>SAL</code></a>、<a href="/2017/10/09/asm/#B"><code>SAR</code></a>、<a href="/2017/10/09/asm/#C"><code>ROL</code></a>、<a href="/2017/10/09/asm/#C"><code>ROR</code></a>、<a href="/2017/10/09/asm/#C"><code>RCL</code></a>、<a href="/2017/10/09/asm/#C"><code>RCR</code></a></td></tr><tr><td style="text-align:center">字符串操作</td><td><a href="/2017/10/09/asm/#MOV"><code>MOV</code></a>、<a href="/2017/10/09/asm/#CMPSB"><code>CMPSB</code></a>、<a href="/2017/10/09/asm/#SCASB"><code>SCASB</code></a>、<a href="/2017/10/09/asm/#STOSB"><code>STOSB</code></a>、<a href="/2017/10/09/asm/#LODSB"><code>LODSB</code></a></td></tr><tr><td style="text-align:center">控制转移指令</td><td><a href="/2017/10/09/asm/#JMP"><code>JMP</code></a>、<a href="/2017/10/09/asm/#LOOP"><code>LOOP</code></a>、<a href="/2017/10/09/asm/#CAL"><code>CALL</code></a>、<a href="/2017/10/09/asm/#CAL"><code>RETN</code></a>、<a href="/2017/10/09/asm/#CAL"><code>RETF</code></a></td></tr></tbody></table></div><a id="more"></a><p><br></p><hr><p><br></p><h2 id="符号数相关"><a href="#符号数相关" class="headerlink" title="符号数相关"></a>符号数相关</h2><h3 id="1">jg/jl大小比较</h3> <p>jg 符号数大于<br>jl 符号数小于</p><blockquote><p>跳转依据：</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th>依据</th></tr></thead><tbody><tr><td style="text-align:center">a &lt; b</td><td>SF！=OF</td></tr><tr><td style="text-align:center">a==b</td><td>ZF=0</td></tr><tr><td style="text-align:center">a &gt; b</td><td>SF=OF且ZF=0</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ah=0FFh, bh=1</span><br><span class="line">cmp ah, bh</span><br><span class="line">jg ah_is_larger; </span><br><span class="line">//跳转不发生（0FF作为符号数为-1）</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="2">imul 符号数乘法</h3><ul><li><strong>imul eax<code>只寄存器</code>, ebx<code>寄存器或变量</code>, 1234h<code>只常数</code></strong><br>eax = ebx * 1234h</li><li><strong>imul eax, ebx</strong><br>eax自乘ebx</li></ul><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="通用数据传送指令"><a href="#通用数据传送指令" class="headerlink" title="通用数据传送指令"></a>通用数据传送指令</h2><h3 id="3">MOV 指令</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[√] <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">bx</span>], <span class="number">ah</span></span><br><span class="line">[×] <span class="keyword">mov</span>              <span class="built_in">ax</span> , <span class="number">bh</span> <span class="comment">;左右操作数宽度必须相等</span></span><br></pre></td></tr></table></figure><ul><li><code>DS</code> / <code>CS</code> / <code>IP</code> 不能被mov改变</li></ul><p><strong>mov 的变体</strong></p><ul><li><code>movzx</code> : move by zero extention</li><li><code>movsx</code> : move by sign extention</li><li><code>[rep] movsb</code>  ; 以字节为单位移动CX个字符</li></ul><blockquote><p>DS : SI 指向源字符串<br>ES : DI 指向目标字符串<br>若 DF=0 即正方向则SI++，DI++，否则反之。</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="4">POP / PUSH 指令</h3><ul><li>不能对8位值进行push/pop:</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[×] <span class="keyword">push</span> <span class="number">ah</span></span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="5"> XCHG 指令 </h3><p>（略）</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="6"> IN / OUT 指令 </h3><p>基本格式：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>, <span class="number">21h</span></span><br></pre></td></tr></table></figure></p><p>从21h号端口读取一个字节存放到AL中</p><blockquote><ul><li>端口地址&gt;=100h，必须存放到DX</li><li>端口地址的范围是：[0000h, 0FFFFh]，共65536个端口。</li></ul></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h2><h3 id="LEA"> LEA  `取变量的偏移地址`</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lea</span> <span class="built_in">eax</span>, [<span class="built_in">ebp</span>-<span class="number">64</span>]</span><br></pre></td></tr></table></figure><p>EAX = EBP-64</p><blockquote><ul><li>lea dx, ds:[1000h] ; DX=1000h</li><li>设BX=1000h, SI=2<br>lea ax, ds:[bx+si+3]; AX=bx+si+3=1005h</li></ul></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="LDS"> LDS `把远指针装到DS:DEST` </h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lds</span> dest, src</span><br></pre></td></tr></table></figure><p>把 <code>src</code> 指向的地址，高位存放在<code>DS</code>中，低位存放在<code>dest</code>中。</p><blockquote><p>16位时，<br>比如当前DS=1000H, BX=0100H.<br>当前内存:<br>1000:0100 01<br>1000:0101 02<br>1000:0102 03<br>1000:0103 04<br>而有一条指令:LDS BX,[BX]<br>[BX]指向1000:0100,执行后BX存低位的内容,也就是BX=0201H,<br>而DS则存高位的内容,也就是[BX+2]的内容,DS=0403H</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="LES"> LES `把远指针装到ES:DEST` </h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">les</span> dest, src</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="PUS"> PUSHF，POPF `标志寄存器传送指令` </h3><p>（把FL压入/弹出ax）<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pushf</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ax</span> <span class="comment">; AX=FL</span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">ax</span>, <span class="number">1</span><span class="comment">; 第0位变1，其它位不变</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">popf</span>    <span class="comment">; FL=AX</span></span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="转换指令"><a href="#转换指令" class="headerlink" title="转换指令"></a>转换指令</h2><h3 id="CBW"> CBW，CWD `符号扩充指令` </h3><blockquote><p><strong>CBW:</strong> convert byte to word<br><strong>CWD:</strong> convert word to double word<br><strong>CDQ:</strong> convert double word to quadruple word(32位扩充为64位)</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">7Fh</span></span><br><span class="line"><span class="keyword">cbw</span>         <span class="comment">; AX=007F</span></span><br></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">0F9h</span></span><br><span class="line"><span class="keyword">cbw</span>         <span class="comment">; AX=0FFF9h</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 8000h</span><br><span class="line">cwd         ; <span class="attribute">DX</span>=0FFFFh, <span class="attribute">AX</span>=8000h</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, <span class="number">0</span>FFFFFFFFh</span><br><span class="line">cdq         ; EDX=<span class="number">0</span>FFFFFFFFh, EAX=<span class="number">0</span>FFFFFFFFh</span><br><span class="line">                  高<span class="number">32</span>位           低<span class="number">32</span>位</span><br></pre></td></tr></table></figure><ul><li><code>movzx</code> : move by zero extention</li><li><code>movsx</code> : move by sign extention</li></ul><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="XLAT"> XLAT `换码指令` </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 设 char t[]="0123456789ABCDEF";</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, offset t</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">10</span></span><br><span class="line"><span class="keyword">xlat</span><span class="comment">; 结果AL='A'</span></span><br><span class="line">     实际<span class="built_in">AL</span>=<span class="built_in">DS</span>:[<span class="built_in">BX</span>+<span class="built_in">AL</span>]</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h2><h3 id="PLU"> 加 </h3><div class="table-container"><table><thead><tr><th>指令</th><th>用法</th></tr></thead><tbody><tr><td>add</td><td></td></tr><tr><td>inc</td><td>不影响CF位</td></tr><tr><td>adc</td><td>带进位加法。当进行32位以上运算时，要求低位字节相加，而高位字节再相加时就要考虑低位相加的进位，即CF</td></tr></tbody></table></div><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="MIN"> 减 </h3><div class="table-container"><table><thead><tr><th>指令</th><th>用法</th></tr></thead><tbody><tr><td>sub</td><td></td></tr><tr><td>dec</td><td>自减</td></tr><tr><td>neg</td><td>求相反数</td></tr></tbody></table></div><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="TIM"> 乘 `非符号` </h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mul </span>src</span><br></pre></td></tr></table></figure><p>src <code>不能是立即数，寄存器和地址均可</code></p><div class="table-container"><table><thead><tr><th>src字节数</th><th>操作对象</th><th>结果存放</th></tr></thead><tbody><tr><td>8字节</td><td>al</td><td>ax</td></tr><tr><td>16字节</td><td>ax</td><td>dx : ax</td></tr><tr><td>32字节</td><td>eax</td><td>edx : eax</td></tr></tbody></table></div><p><code>即 AX = AL * src</code></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="DIV"> 除 `非符号` </h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> op</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>op字节数</th><th>操作对象</th><th>结果存放</th></tr></thead><tbody><tr><td>8字节</td><td>ax</td><td>al（整除）；ah（余数）</td></tr><tr><td>16字节</td><td>dx : ax</td><td>ax（整除）；dx（余数）</td></tr><tr><td>32字节</td><td>edx : eax</td><td>eax（整除）；edx（余数）</td></tr></tbody></table></div><blockquote><p>语句比较</p><ul><li><code>test</code> / <code>and</code>（<code>cmp</code> / <code>sub</code>）<br>运算结果不影响操作数，<strong>只影响标志位</strong>。<br><strong>影响标志：</strong> C,O,P,Z,S(其中C与O两个标志会被设为0)</li><li><code>neg</code> / <code>not</code><br><code>neg</code> 求相反数，<code>not</code> 逐位求反</li><li><code>inc</code> / <code>add</code><br>是否影响flag</li><li><code>jc</code> 与 <code>jb</code> 指令完全等价。<br><code>jz</code> 与 <code>je</code> 指令完全等价。</li></ul></blockquote><h4 id="比较方法"><a href="#比较方法" class="headerlink" title="比较方法"></a>比较方法</h4><ol><li>非符号数：CF / ZF</li><li>符号数：SF / OF / ZF<blockquote><p>OF=1 即结果溢出（有错），否定SF得到的符号结果</p></blockquote></li></ol><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="逻辑运算和移位"><a href="#逻辑运算和移位" class="headerlink" title="逻辑运算和移位"></a>逻辑运算和移位</h2><p><br></p><h3 id="A"> 逻辑运算指令 </h3><p><code>AND</code>，<code>OR</code>，<code>XOR</code>，<code>NOT</code>，<code>TEST</code></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h3><p><code>SHL</code>，<code>SHR</code>，<code>SAL</code>，<code>SAR</code>，<br><code>ROL</code>，<code>ROR</code>，<code>RCL</code>，<code>RCR</code><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shl</span> <span class="number">ah</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h4 id="B"> **单向** </h4><div class="table-container"><table><thead><tr><th>符号</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td>SHL</td><td>逻辑左移</td><td>低位补0, 高位进CF</td></tr><tr><td>SHR</td><td>逻辑右移</td><td>低位进CF, 高位补0</td></tr><tr><td>SAL</td><td>算术左移</td><td>（同SHL）</td></tr><tr><td>SAR</td><td>算术右移</td><td>每位右移, 低位进CF, 高位不变</td></tr></tbody></table></div><p><code>它们的结果影响 OF、SF、ZF、PF、CF</code></p><h4 id="C"> **循环** </h4><div class="table-container"><table><thead><tr><th>符号</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td>ROL</td><td>循环左移</td><td>高位到低位并送CF</td></tr><tr><td>ROR</td><td>循环右移</td><td>低位到高位并送CF</td></tr><tr><td>RCL</td><td>带进位循环左移</td><td>进位值(原CF)到低位, 高位进CF</td></tr><tr><td>RCR</td><td>带进位循环右移</td><td>进位值(原CF)到高位, 低位进CF</td></tr></tbody></table></div><p><code>它们的结果影响 OF、CF</code></p><blockquote><p>8086中，当次数&gt;=2时，移位次数应先赋值给 <strong>cl</strong></p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="MOV"> MOVSB `字符串传送` </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">rep</span>] <span class="keyword">movsb</span></span><br></pre></td></tr></table></figure><p>以字节为单位，从 <strong>DS:SI</strong> 到 <strong>ES:DI</strong> 移动CX个字符</p><ul><li>DF控制方向。若DF=0即正方向则SI++，DI++。</li></ul><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="CMPSB"> CMPSB `字符串比较` </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">repe</span> | <span class="keyword">repne</span>] <span class="keyword">cmpsb</span></span><br></pre></td></tr></table></figure><p>若本次比较 <code>相等</code> / <code>不等</code> 则继续比较下一个</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="SCASB"> SCASB `字符串查找` </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">repe</span> | <span class="keyword">repne</span>] <span class="keyword">scasb</span></span><br></pre></td></tr></table></figure><p>设ES:DI → 以’\0’结束的字符串，要求该字符串长度<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">1000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>, <span class="number">1080h</span>   <span class="comment">; ES:DI → "ABC..."</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">0FFFFh</span>  <span class="comment">; ES:DI → "ABC",0,[]...</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">0</span>       <span class="comment">; AL=待查找的字符</span></span><br><span class="line"><span class="keyword">cld</span></span><br><span class="line"><span class="keyword">repne</span> <span class="keyword">scasb</span>     <span class="comment">; 循环结束时，DI=1088h, CX=FFFF-8</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">cx</span></span><br><span class="line"><span class="keyword">not</span> <span class="built_in">cx</span>          <span class="comment">; CX=FFFF-CX=字符串长度(不含0)</span></span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="STOSB"> STOSB `存入字符串` </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">repe</span>] <span class="keyword">stosb</span></span><br></pre></td></tr></table></figure><p>stosb把AL的值保存到ES:DI所指向的内存单元中</p><ul><li>当DF==0时DI++，当DF==1时DI—</li></ul><p>设要把从地址1000:10A0开始共100h个字节内存单元全部填0<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">1000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span><span class="comment">; ES=1000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>, <span class="number">10A0h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">100h</span></span><br><span class="line"><span class="keyword">cld</span></span><br><span class="line"><span class="keyword">xor</span> <span class="built_in">al</span>, <span class="built_in">al</span></span><br><span class="line"><span class="keyword">rep</span> <span class="keyword">stosb</span></span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="LODSB"> LODSB `从字符串取字节或字` </h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lodsb</span></span><br></pre></td></tr></table></figure><p>AL = DS : [SI],  SI++</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><h3 id="JMP"> JMP </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[√] <span class="keyword">jmp</span> <span class="number">0108h</span></span><br><span class="line">[√] <span class="keyword">jmp</span> <span class="number">1234h</span>:<span class="number">5678h</span></span><br><span class="line">[√] <span class="keyword">jmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">10F0h</span>]</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="LOOP"> LOOP </h3><p>CX-1</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="CAL"> CALL，RETN，RETF `子程序调用与返回` </h3><p>retn表示近返回，可简写成ret;<br>retf表示远返回。<br>call既可以表示近调用，也可以表示远调用<br>retn [count]  ; <code>count</code>多出步骤：SP = SP + count</p><p><strong>堆栈传递</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">f:</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bp</span>, <span class="built_in">sp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="number">4</span>]<span class="comment">; 从堆栈中取得参数</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ax</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">3</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ax</span><span class="comment">; 参数压入到堆栈</span></span><br><span class="line">   <span class="keyword">call</span> f</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">sp</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>C语言函数调用y=f(2,3)求两数之和转化成汇编语言<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">f:</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">bp</span><span class="comment">;(4)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bp</span>, <span class="built_in">sp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="number">4</span>]</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="number">6</span>]</span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">bp</span><span class="comment">; (5)</span></span><br><span class="line">   <span class="keyword">ret</span><span class="comment">; (6)</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">3</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ax</span><span class="comment">; (1)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">2</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ax</span><span class="comment">; (2)</span></span><br><span class="line">   <span class="keyword">call</span> f<span class="comment">; (3)</span></span><br><span class="line"><span class="symbol">here:</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">sp</span>, <span class="number">4</span><span class="comment">;(7)</span></span><br></pre></td></tr></table></figure></p><p>上述程序运行过程中的堆栈布局如下:</p><blockquote><p>ss:1FF8 old bp &lt;- bp (4)<br>ss:1FFA here &lt;- (3)(5)<br>ss:1FFC 02   &lt;- (2)(6)<br>ss:1FFE 03   &lt;- (1)<br>ss:2000 ??   &lt;- (7)</p></blockquote><p>cx/dx可以随便用<br>ax一般用作返回值</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asm </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <content type="html"><![CDATA[<h2 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h2><p>浙江大学2015级生物科学专业，辅修竺可桢学院创新与创业管理强化班（ITP）。<br>（有空了慢慢写吧！）</p><div class="table-container"><table><thead><tr><th>技能</th><th>水平</th><th>备注</th></tr></thead><tbody><tr><td>Python</td><td><i class="fa fa-circle">&lt;/i&gt;&nbsp;<i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle">&lt;/i&gt;&nbsp;<i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle-o"></i></i></i></td><td>个人首要编程语言，较熟练，写过爬虫、服务器等程序和部件。</td></tr><tr><td>C4D</td><td><i class="fa fa-circle">&lt;/i&gt;&nbsp;<i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle">&lt;/i&gt;&nbsp;<i class="fa fa-circle-o"></i>&nbsp;<i class="fa fa-circle-o"></i></i></i></td><td>建模渲染和简单动画，做过一些作品。</td></tr></tbody></table></div><p><br></p><p><strong>爱好</strong></p><ul><li>漫威忠实粉丝</li><li>科幻电影和谍战片（007/星际穿越）</li></ul><p><br></p><p><strong>个人公众号</strong></p><p><img src="/images/000.png" alt="file-list"></p><p><br></p><hr><p><span id="env"></span><br><br></p><h2 id="我使用的环境和工具"><a href="#我使用的环境和工具" class="headerlink" title="我使用的环境和工具"></a>我使用的环境和工具</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python_3.6.4_x64<br><strong>主要的包</strong></p><div class="table-container"><table><thead><tr><th>名称</th><th>版本</th><th>备注</th></tr></thead><tbody><tr><td>pip</td><td>9.0.1</td><td></td></tr><tr><td>wheel</td><td>0.30.0</td><td></td></tr><tr><td>beautifulsoup4</td><td>4.6.0</td><td></td></tr><tr><td>django</td><td>2.0.3</td><td></td></tr><tr><td>matplotlib</td><td>2.1.2</td><td></td></tr><tr><td>numpy</td><td>1.14.0</td><td></td></tr><tr><td>opencv-python</td><td>3.4.0.12</td><td></td></tr><tr><td>pandas</td><td>0.22.0</td><td></td></tr><tr><td>pyperclip</td><td>1.6.0</td><td></td></tr><tr><td>requests</td><td>2.18.4</td><td></td></tr><tr><td>scikit-learn</td><td>0.19.1</td><td></td></tr><tr><td>scipy</td><td>1.0.0</td></tr></tbody></table></div><hr><p><br></p><h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><p>&emsp;<i class="fa fa-wechat">&lt;/i&gt;&emsp;John_Theo<br>&emsp;<i class="fa fa-qq"></i>&emsp;905176554（不常用）<br>&emsp;<i class="fa fa-envelope">&lt;/i&gt;&emsp;B_W_Ghost@163.com / John_Theo@foxmail.com<br>&emsp;<i class="fa fa-linkedin-square"></i>&emsp;<a href="www.linkedin.com/in/庄心昊-johntheo">领英首页</a><br>&emsp;<i class="fa fa-cloud"></i>&emsp;<a href="https://pan.baidu.com/s/1DSjHOjyeyFg_3yUgalpYCQ" target="_blank" rel="noopener">在线作品集</a>（提取码：4rc2）</i></i></p>]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
