<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Hello World!</title>
      <link href="/2018/03/18/new/"/>
      <content type="html"><![CDATA[<p>本文是不置顶的。</p><a id="more"></a>]]></content>
      
      
    </entry>
    
    <entry>
      <title>指令简析</title>
      <link href="/2017/10/09/asm/"/>
      <content type="html"><![CDATA[<p>本文是上学期学习汇编语言时候的课堂笔记。<br>单击命令直接索引：<a href="2017/10/09/asm/#1"><code>JG</code></a>、<a href="#1"><code>JL</code></a>、<a href="#3"><code>MOV</code></a> </p><a id="more"></a><h2 id="符号数相关"><a href="#符号数相关" class="headerlink" title="符号数相关"></a>符号数相关</h2><h3 id="1">jg/jl大小比较</h3><p>jg 符号数大于<br>jl 符号数小于</p><blockquote><p>跳转依据：</p></blockquote><table><thead><tr><th style="text-align:center">符号</th><th>依据</th></tr></thead><tbody><tr><td style="text-align:center">a &lt; b</td><td>SF！=OF</td></tr><tr><td style="text-align:center">a==b</td><td>ZF=0</td></tr><tr><td style="text-align:center">a &gt; b</td><td>SF=OF且ZF=0</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ah=0FFh, bh=1</span><br><span class="line">cmp ah, bh</span><br><span class="line">jg ah_is_larger; </span><br><span class="line">//跳转不发生（0FF作为符号数为-1）</span><br></pre></td></tr></table></figure><h3 id="2">imul 符号数乘法</h3><ul><li><strong>imul eax<code>只寄存器</code>, ebx<code>寄存器或变量</code>, 1234h<code>只常数</code></strong><br>eax = ebx * 1234h</li><li><strong>imul eax, ebx</strong><br>eax自乘ebx</li></ul><hr><h2 id="通用数据传送指令"><a href="#通用数据传送指令" class="headerlink" title="通用数据传送指令"></a>通用数据传送指令</h2><h3 id="3">MOV 指令</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[√] <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">bx</span>], <span class="number">ah</span></span><br><span class="line">[×] <span class="keyword">mov</span>              <span class="built_in">ax</span> , <span class="number">bh</span> <span class="comment">;左右操作数宽度必须相等</span></span><br></pre></td></tr></table></figure><ul><li><code>DS</code> / <code>CS</code> / <code>IP</code> 不能被mov改变</li></ul><p><strong>mov 的变体</strong></p><ul><li><code>movzx</code> : move by zero extention</li><li><code>movsx</code> : move by sign extention</li><li><code>[rep] movsb</code>  ; 以字节为单位移动CX个字符</li></ul><blockquote><p>DS : SI 指向源字符串<br>ES : DI 指向目标字符串<br>若 DF=0 即正方向则SI++，DI++，否则反之。</p></blockquote><h3 id="POP-PUSH-指令"><a href="#POP-PUSH-指令" class="headerlink" title="POP / PUSH 指令"></a>POP / PUSH 指令</h3><ul><li>不能对8位值进行push/pop:</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[×] <span class="keyword">push</span> <span class="number">ah</span></span><br></pre></td></tr></table></figure><h3 id="XCHG-指令"><a href="#XCHG-指令" class="headerlink" title="XCHG 指令"></a>XCHG 指令</h3><p>（略）</p><h3 id="IN-OUT-指令"><a href="#IN-OUT-指令" class="headerlink" title="IN / OUT 指令"></a>IN / OUT 指令</h3><p>基本格式：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>, <span class="number">21h</span></span><br></pre></td></tr></table></figure></p><p>从21h号端口读取一个字节存放到AL中</p><blockquote><ul><li>端口地址&gt;=100h，必须存放到DX</li><li>端口地址的范围是：[0000h, 0FFFFh]，共65536个端口。</li></ul></blockquote><hr><h2 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h2><p>（1）lea <code>取变量的偏移地址</code><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lea</span> <span class="built_in">eax</span>, [<span class="built_in">ebp</span>-<span class="number">64</span>]</span><br></pre></td></tr></table></figure></p><p>EAX = EBP-64</p><blockquote><ul><li>lea dx, ds:[1000h] ; DX=1000h</li><li>设BX=1000h, SI=2<br>lea ax, ds:[bx+si+3]; AX=bx+si+3=1005h</li></ul></blockquote><p>(2) lds <code>把远指针装到DS:dest</code><br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lds</span> dest, src</span><br></pre></td></tr></table></figure></p><p>把 <code>src</code> 指向的地址，高位存放在<code>DS</code>中，低位存放在<code>dest</code>中。</p><blockquote><p>16位时，<br>比如当前DS=1000H, BX=0100H.<br>当前内存:<br>1000:0100 01<br>1000:0101 02<br>1000:0102 03<br>1000:0103 04<br>而有一条指令:LDS BX,[BX]<br>[BX]指向1000:0100,执行后BX存低位的内容,也就是BX=0201H,<br>而DS则存高位的内容,也就是[BX+2]的内容,DS=0403H</p></blockquote><p>（3）les <code>把远指针装到ES:dest</code><br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">les</span> dest, src</span><br></pre></td></tr></table></figure></p><p>（4）PUSHF，POPF <code>标志寄存器传送指令</code><br>（把FL压入/弹出ax）<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pushf</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ax</span> <span class="comment">; AX=FL</span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">ax</span>, <span class="number">1</span><span class="comment">; 第0位变1，其它位不变</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">popf</span>    <span class="comment">; FL=AX</span></span><br></pre></td></tr></table></figure></p><h2 id="转换指令"><a href="#转换指令" class="headerlink" title="转换指令"></a>转换指令</h2><p>（1）CBW，CWD <code>符号扩充指令</code></p><blockquote><p><strong>CBW:</strong> convert byte to word<br><strong>CWD:</strong> convert word to double word<br><strong>CDQ:</strong> convert double word to quadruple word(32位扩充为64位)</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">7Fh</span></span><br><span class="line"><span class="keyword">cbw</span>         <span class="comment">; AX=007F</span></span><br></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">0F9h</span></span><br><span class="line"><span class="keyword">cbw</span>         <span class="comment">; AX=0FFF9h</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 8000h</span><br><span class="line">cwd         ; <span class="attribute">DX</span>=0FFFFh, <span class="attribute">AX</span>=8000h</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, <span class="number">0</span>FFFFFFFFh</span><br><span class="line">cdq         ; EDX=<span class="number">0</span>FFFFFFFFh, EAX=<span class="number">0</span>FFFFFFFFh</span><br><span class="line">                  高<span class="number">32</span>位           低<span class="number">32</span>位</span><br></pre></td></tr></table></figure><ul><li><code>movzx</code> : move by zero extention</li><li><code>movsx</code> : move by sign extention</li></ul><p>（2）XLAT <code>换码指令</code><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 设 char t[]="0123456789ABCDEF";</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, offset t</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">10</span></span><br><span class="line"><span class="keyword">xlat</span><span class="comment">; 结果AL='A'</span></span><br><span class="line">     实际<span class="built_in">AL</span>=<span class="built_in">DS</span>:[<span class="built_in">BX</span>+<span class="built_in">AL</span>]</span><br></pre></td></tr></table></figure></p><hr><h2 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h2><h3 id="（1）加"><a href="#（1）加" class="headerlink" title="（1）加"></a>（1）加</h3><table><thead><tr><th>指令</th><th>用法</th></tr></thead><tbody><tr><td>add</td><td></td></tr><tr><td>inc</td><td>不影响CF位</td></tr><tr><td>adc</td><td>带进位加法。当进行32位以上运算时，要求低位字节相加，而高位字节再相加时就要考虑低位相加的进位，即CF</td></tr></tbody></table><h3 id="（2）减"><a href="#（2）减" class="headerlink" title="（2）减"></a>（2）减</h3><table><thead><tr><th>指令</th><th>用法</th></tr></thead><tbody><tr><td>sub</td><td></td></tr><tr><td>dec</td><td>自减</td></tr><tr><td>neg</td><td>求相反数</td></tr></tbody></table><h3 id="（3）乘-非符号"><a href="#（3）乘-非符号" class="headerlink" title="（3）乘 非符号"></a>（3）乘 <code>非符号</code></h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mul </span>src</span><br></pre></td></tr></table></figure><p>src <code>不能是立即数，寄存器和地址均可</code></p><table><thead><tr><th>src字节数</th><th>操作对象</th><th>结果存放</th></tr></thead><tbody><tr><td>8字节</td><td>al</td><td>ax</td></tr><tr><td>16字节</td><td>ax</td><td>dx : ax</td></tr><tr><td>32字节</td><td>eax</td><td>edx : eax</td></tr></tbody></table><p><code>即 AX = AL * src</code></p><h3 id="（4）除-非符号"><a href="#（4）除-非符号" class="headerlink" title="（4）除 非符号"></a>（4）除 <code>非符号</code></h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> op</span><br></pre></td></tr></table></figure><table><thead><tr><th>op字节数</th><th>操作对象</th><th>结果存放</th></tr></thead><tbody><tr><td>8字节</td><td>ax</td><td>al（整除）；ah（余数）</td></tr><tr><td>16字节</td><td>dx : ax</td><td>ax（整除）；dx（余数）</td></tr><tr><td>32字节</td><td>edx : eax</td><td>eax（整除）；edx（余数）</td></tr></tbody></table><blockquote><p>语句比较</p><ul><li><code>test</code> / <code>and</code>（<code>cmp</code> / <code>sub</code>）<br>运算结果不影响操作数，<strong>只影响标志位</strong>。<br><strong>影响标志：</strong> C,O,P,Z,S(其中C与O两个标志会被设为0)</li><li><code>neg</code> / <code>not</code><br><code>neg</code> 求相反数，<code>not</code> 逐位求反</li><li><code>inc</code> / <code>add</code><br>是否影响flag</li><li><code>jc</code> 与 <code>jb</code> 指令完全等价。<br><code>jz</code> 与 <code>je</code> 指令完全等价。</li></ul></blockquote><h3 id="比较方法"><a href="#比较方法" class="headerlink" title="比较方法"></a>比较方法</h3><ol><li>非符号数：CF / ZF</li><li>符号数：SF / OF / ZF<blockquote><p>OF=1 即结果溢出（有错），否定SF得到的符号结果</p></blockquote></li></ol><hr><h2 id="逻辑运算和移位"><a href="#逻辑运算和移位" class="headerlink" title="逻辑运算和移位"></a>逻辑运算和移位</h2><h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><p><code>AND</code>，<code>OR</code>，<code>XOR</code>，<code>NOT</code>，<code>TEST</code></p><h3 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h3><p><code>SHL</code>，<code>SHR</code>，<code>SAL</code>，<code>SAR</code>，<br><code>ROL</code>，<code>ROR</code>，<code>RCL</code>，<code>RCR</code><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shl</span> <span class="number">ah</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p><strong>单向</strong></p><table><thead><tr><th>符号</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td>SHL</td><td>逻辑左移</td><td>低位补0, 高位进CF</td></tr><tr><td>SHR</td><td>逻辑右移</td><td>低位进CF, 高位补0</td></tr><tr><td>SAL</td><td>算术左移</td><td>（同SHL）</td></tr><tr><td>SAR</td><td>算术右移</td><td>每位右移, 低位进CF, 高位不变</td></tr></tbody></table><p><code>它们的结果影响 OF、SF、ZF、PF、CF</code></p><p><strong>循环</strong></p><table><thead><tr><th>符号</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td>ROL</td><td>循环左移</td><td>高位到低位并送CF</td></tr><tr><td>ROR</td><td>循环右移</td><td>低位到高位并送CF</td></tr><tr><td>RCL</td><td>带进位循环左移</td><td>进位值(原CF)到低位, 高位进CF</td></tr><tr><td>RCR</td><td>带进位循环右移</td><td>进位值(原CF)到高位, 低位进CF</td></tr></tbody></table><p><code>它们的结果影响 OF、CF</code></p><blockquote><p>8086中，当次数&gt;=2时，移位次数应先赋值给 <strong>cl</strong></p></blockquote><hr><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="（1）MOVSB-字符串传送"><a href="#（1）MOVSB-字符串传送" class="headerlink" title="（1）MOVSB 字符串传送"></a>（1）MOVSB <code>字符串传送</code></h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">rep</span>] <span class="keyword">movsb</span></span><br></pre></td></tr></table></figure><p>以字节为单位，从 <strong>DS:SI</strong> 到 <strong>ES:DI</strong> 移动CX个字符</p><ul><li>DF控制方向。若DF=0即正方向则SI++，DI++。</li></ul><h3 id="（2）CMPSB-字符串比较"><a href="#（2）CMPSB-字符串比较" class="headerlink" title="（2）CMPSB 字符串比较"></a>（2）CMPSB <code>字符串比较</code></h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">repe</span> | <span class="keyword">repne</span>] <span class="keyword">cmpsb</span></span><br></pre></td></tr></table></figure><p>若本次比较 <code>相等</code> / <code>不等</code> 则继续比较下一个</p><h3 id="（3）SCASB-字符串查找"><a href="#（3）SCASB-字符串查找" class="headerlink" title="（3）SCASB 字符串查找"></a>（3）SCASB <code>字符串查找</code></h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">repe</span> | <span class="keyword">repne</span>] <span class="keyword">scasb</span></span><br></pre></td></tr></table></figure><p>设ES:DI → 以’\0’结束的字符串，要求该字符串长度<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">1000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>, <span class="number">1080h</span>   <span class="comment">; ES:DI → "ABC..."</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">0FFFFh</span>  <span class="comment">; ES:DI → "ABC",0,[]...</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">0</span>       <span class="comment">; AL=待查找的字符</span></span><br><span class="line"><span class="keyword">cld</span></span><br><span class="line"><span class="keyword">repne</span> <span class="keyword">scasb</span>     <span class="comment">; 循环结束时，DI=1088h, CX=FFFF-8</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">cx</span></span><br><span class="line"><span class="keyword">not</span> <span class="built_in">cx</span>          <span class="comment">; CX=FFFF-CX=字符串长度(不含0)</span></span><br></pre></td></tr></table></figure></p><h3 id="（4）STOSB-存入字符串"><a href="#（4）STOSB-存入字符串" class="headerlink" title="（4）STOSB 存入字符串"></a>（4）STOSB <code>存入字符串</code></h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">repe</span>] <span class="keyword">stosb</span></span><br></pre></td></tr></table></figure><p>stosb把AL的值保存到ES:DI所指向的内存单元中</p><ul><li>当DF==0时DI++，当DF==1时DI–</li></ul><p>设要把从地址1000:10A0开始共100h个字节内存单元全部填0<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">1000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span><span class="comment">; ES=1000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>, <span class="number">10A0h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">100h</span></span><br><span class="line"><span class="keyword">cld</span></span><br><span class="line"><span class="keyword">xor</span> <span class="built_in">al</span>, <span class="built_in">al</span></span><br><span class="line"><span class="keyword">rep</span> <span class="keyword">stosb</span></span><br></pre></td></tr></table></figure></p><h3 id="（5）LODSB-从字符串取字节或字"><a href="#（5）LODSB-从字符串取字节或字" class="headerlink" title="（5）LODSB 从字符串取字节或字"></a>（5）LODSB <code>从字符串取字节或字</code></h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lodsb</span></span><br></pre></td></tr></table></figure><p>AL = DS : [SI],  SI++</p><hr><h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><h3 id="（1）jmp"><a href="#（1）jmp" class="headerlink" title="（1）jmp"></a>（1）jmp</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[√] <span class="keyword">jmp</span> <span class="number">0108h</span></span><br><span class="line">[√] <span class="keyword">jmp</span> <span class="number">1234h</span>:<span class="number">5678h</span></span><br><span class="line">[√] <span class="keyword">jmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">10F0h</span>]</span><br></pre></td></tr></table></figure><h3 id="（2）LOOP"><a href="#（2）LOOP" class="headerlink" title="（2）LOOP"></a>（2）LOOP</h3><p>（略）</p><h3 id="（3）CALL，RETN，RETF-子程序调用与返回"><a href="#（3）CALL，RETN，RETF-子程序调用与返回" class="headerlink" title="（3）CALL，RETN，RETF 子程序调用与返回"></a>（3）CALL，RETN，RETF <code>子程序调用与返回</code></h3><p>retn表示近返回，可简写成ret;<br>retf表示远返回。<br>call既可以表示近调用，也可以表示远调用<br>retn [count]  ; <code>count</code>多出步骤：SP = SP + count</p><p><strong>堆栈传递</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">f:</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bp</span>, <span class="built_in">sp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="number">4</span>]<span class="comment">; 从堆栈中取得参数</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ax</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">3</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ax</span><span class="comment">; 参数压入到堆栈</span></span><br><span class="line">   <span class="keyword">call</span> f</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">sp</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>C语言函数调用y=f(2,3)求两数之和转化成汇编语言<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">f:</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">bp</span><span class="comment">;(4)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bp</span>, <span class="built_in">sp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="number">4</span>]</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="number">6</span>]</span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">bp</span><span class="comment">; (5)</span></span><br><span class="line">   <span class="keyword">ret</span><span class="comment">; (6)</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">3</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ax</span><span class="comment">; (1)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">2</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ax</span><span class="comment">; (2)</span></span><br><span class="line">   <span class="keyword">call</span> f<span class="comment">; (3)</span></span><br><span class="line"><span class="symbol">here:</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">sp</span>, <span class="number">4</span><span class="comment">;(7)</span></span><br></pre></td></tr></table></figure></p><p>上述程序运行过程中的堆栈布局如下:</p><blockquote><p>ss:1FF8 old bp &lt;- bp (4)<br>ss:1FFA here &lt;- (3)(5)<br>ss:1FFC 02   &lt;- (2)(6)<br>ss:1FFE 03   &lt;- (1)<br>ss:2000 ??   &lt;- (7)</p></blockquote><p>cx/dx可以随便用<br>ax一般用作返回值</p>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asm </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
