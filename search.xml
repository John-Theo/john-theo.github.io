<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>二十三种设计模式及其python实现</title>
      <link href="/2018/06/26/design_pattern_of_python/"/>
      <content type="html"><![CDATA[<blockquote><p>转载自 《<a href="http://www.cnblogs.com/Liqiongyu/" target="_blank" rel="noopener">李琼羽的博客</a>》<br>原文链接：<a href="https://www.cnblogs.com/Liqiongyu/p/5916710.html" target="_blank" rel="noopener">https://www.cnblogs.com/Liqiongyu/p/5916710.html</a><br>我做部分修改和注解</p></blockquote><p>本文源码托管于github：<a href="https://github.com/w392807287/Design_pattern_of_python" target="_blank" rel="noopener">https://github.com/w392807287/Design_pattern_of_python</a></p><p><strong>参考文献：</strong></p><ol><li><p>《大话设计模式》——吴强</p></li><li><p>《Python设计模式》——pythontip.com</p></li><li><p>《23种设计模式》——<a href="http://www.cnblogs.com/beijiguangyong/" target="_blank" rel="noopener">http://www.cnblogs.com/beijiguangyong/</a></p></li></ol><h2 id="设计模式是什么？"><a href="#设计模式是什么？" class="headerlink" title="设计模式是什么？"></a>设计模式是什么？</h2><p>设计模式是经过总结、优化的，对我们经常会碰到的一些编程问题的可重用解决方案。一个设计模式并不像一个类或一个库那样能够直接作用于我们的代码。反之，设计模式更为高级，它是一种必须在特定情形下实现的一种方法模板。设计模式不会绑定具体的编程语言。一个好的设计模式应该能够用大部分编程语言实现(如果做不到全部的话，具体取决于语言特性)。最为重要的是，设计模式也是一把双刃剑，如果设计模式被用在不恰当的情形下将会造成灾难，进而带来无穷的麻烦。然而如果设计模式在正确的时间被用在正确地地方，它将是你的救星。</p><a id="more"></a><p>起初，你会认为“模式”就是为了解决一类特定问题而特别想出来的明智之举。说的没错，看起来的确是通过很多人一起工作，从不同的角度看待问题进而形成的一个最通用、最灵活的解决方案。也许这些问题你曾经见过或是曾经解决过，但是你的解决方案很可能没有模式这么完备。</p><p>虽然被称为“设计模式”，但是它们同“设计“领域并非紧密联系。设计模式同传统意义上的分析、设计与实现不同，事实上设计模式将一个完整的理念根植于程序中，所以它可能出现在分析阶段或是更高层的设计阶段。很有趣的是因为设计模式的具体体现是程序代码，因此可能会让你认为它不会在具体实现阶段之前出现(事实上在进入具体实现阶段之前你都没有意识到正在使用具体的设计模式)。</p><p>可以通过程序设计的基本概念来理解模式：增加一个抽象层。抽象一个事物就是隔离任何具体细节，这么做的目的是为了将那些不变的核心部分从其他细节中分离出来。当你发现你程序中的某些部分经常因为某些原因改动，而你不想让这些改动的部分引发其他部分的改动，这时候你就需要思考那些不会变动的设计方法了。这么做不仅会使代码可维护性更高，而且会让代码更易于理解，从而降低开发成本。</p><p>这里列举了三种最基本的设计模式：</p><ol><li>创建模式，提供实例化的方法，为适合的状况提供相应的对象创建方法。</li><li>结构化模式，通常用来处理实体之间的关系，使得这些实体能够更好地协同工作。</li><li>行为模式，用于在不同的实体建进行通信，为实体之间的通信提供更容易，更灵活的通信方法。</li></ol><p><strong>创建型</strong></p><ol><li>Factory Method（工厂方法）</li><li>Abstract Factory（抽象工厂）</li><li>Builder（建造者）</li><li>Prototype（原型）</li><li>Singleton（单例）</li></ol><p><strong>结构型</strong></p><ol><li>Adapter Class/Object（适配器）</li><li>Bridge（桥接）</li><li>Composite（组合）</li><li>Decorator（装饰）</li><li>Facade（外观）</li><li>Flyweight（享元）</li><li>Proxy（代理）</li></ol><p><strong>行为型</strong></p><ol><li>Interpreter（解释器）</li><li>Template Method（模板方法）</li><li>Chain of Responsibility（责任链）</li><li>Command（命令）</li><li>Iterator（迭代器）</li><li>Mediator（中介者）</li><li>Memento（备忘录）</li><li>Observer（观察者）</li><li>State（状态）</li><li>Strategy（策略）</li><li>Visitor（访问者）</li></ol><h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><h3 id="１．Factory-Method（工厂方法）"><a href="#１．Factory-Method（工厂方法）" class="headerlink" title="１．Factory Method（工厂方法）"></a>１．Factory Method（工厂方法）</h3><p><img src="/images/design-pattern/Factory Method.png" alt="img"></p><p><strong>意图：</strong></p><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使<strong>一</strong>个类的实例化延迟到其子类。</p><p><strong>适用性：</strong></p><p>当一个类不知道它所必须创建的对象的类的时候。</p><p>当一个类希望由它的子类来指定它所创建的对象的时候。</p><p>当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</p><p><strong>实现：</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Factory Method</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaGetter</span>:</span></span><br><span class="line">    <span class="string">"""A simple localizer a la gettext"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.trans = dict(dog=<span class="string">u"小狗"</span>, cat=<span class="string">u"小猫"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, msgid)</span>:</span></span><br><span class="line">        <span class="string">"""We'll punt if we don't have a translation"""</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.trans[msgid]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">return</span> str(msgid)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnglishGetter</span>:</span></span><br><span class="line">    <span class="string">"""Simply echoes the msg ids"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, msgid)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(msgid)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_localizer</span><span class="params">(language=<span class="string">"English"</span>)</span>:</span></span><br><span class="line">    <span class="string">"""The factory method"""</span></span><br><span class="line">    languages = dict(English=EnglishGetter, China=ChinaGetter)</span><br><span class="line">    <span class="keyword">return</span> languages[language]()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create our localizers</span></span><br><span class="line">e, g = get_localizer(<span class="string">"English"</span>), get_localizer(<span class="string">"China"</span>)</span><br><span class="line"><span class="comment"># Localize some text</span></span><br><span class="line"><span class="keyword">for</span> msgid <span class="keyword">in</span> <span class="string">"dog parrot cat bear"</span>.split():</span><br><span class="line">    print(e.get(msgid), g.get(msgid))</span><br></pre></td></tr></table></figure><h3 id="2-Abstract-Factory（抽象工厂）"><a href="#2-Abstract-Factory（抽象工厂）" class="headerlink" title="2. Abstract Factory（抽象工厂）"></a>2. Abstract Factory（抽象工厂）</h3><p><img src="https://images2015.cnblogs.com/blog/824579/201609/824579-20160928181031672-1073974804.gif" alt="img"></p><p><strong>意图：</strong></p><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 </p><p><strong>适用性：</strong></p><p>一个系统要独立于它的产品的创建、组合和表示时。<br>一个系统要由多个产品系列中的一个来配置时。<br>当你要强调一系列相关的产品对象的设计以便进行联合使用时。<br>当你提供一个产品类库，而只想显示它们的接口而不是实现时。</p><p><strong>实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Abstract Factory</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PetShop</span>:</span></span><br><span class="line">    <span class="string">"""A pet shop"""</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, animal_factory=None)</span>:</span></span><br><span class="line">        <span class="string">"""pet_factory is our abstract factory.</span></span><br><span class="line"><span class="string">        We can set it at will."""</span></span><br><span class="line"> </span><br><span class="line">        self.pet_factory = animal_factory</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_pet</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Creates and shows a pet using the</span></span><br><span class="line"><span class="string">        abstract factory"""</span></span><br><span class="line"> </span><br><span class="line">        pet = self.pet_factory.get_pet()</span><br><span class="line">        print(<span class="string">"This is a lovely"</span>, str(pet))</span><br><span class="line">        print(<span class="string">"It says"</span>, pet.speak())</span><br><span class="line">        print(<span class="string">"It eats"</span>, self.pet_factory.get_food())</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Stuff that our factory makes</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"woof"</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Dog"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"meow"</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Factory classes</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pet</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Dog()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_food</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"dog food"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CatFactory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pet</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Cat()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_food</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"cat food"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create the proper family</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_factory</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Let's be dynamic!"""</span></span><br><span class="line">    <span class="keyword">return</span> random.choice([DogFactory, CatFactory])()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Show pets with various factories</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    shop = PetShop()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        shop.pet_factory = get_factory()</span><br><span class="line">        shop.show_pet()</span><br><span class="line">        print(<span class="string">"="</span> * <span class="number">20</span>)</span><br></pre></td></tr></table></figure><h3 id="3-Builder（建造者）"><a href="#3-Builder（建造者）" class="headerlink" title="3. Builder（建造者）"></a>3. Builder（建造者）</h3><p><strong>意图：</strong></p><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>适用性：</strong></p><p>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</p><p>当构造过程必须允许被构造的对象有不同的表示时。</p><p><img src="https://images2015.cnblogs.com/blog/824579/201609/824579-20160928195334656-2085921203.gif" alt="img"></p><p><strong>实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"> </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    Builder</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Director</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.builder = <span class="keyword">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_building</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.builder.new_building()</span><br><span class="line">        self.builder.build_floor()</span><br><span class="line">        self.builder.build_size()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_building</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.builder.building</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Abstract Builder</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.building = <span class="keyword">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_building</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.building = Building()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Concrete Builder</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuilderHouse</span><span class="params">(Builder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_floor</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.building.floor = <span class="string">'One'</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_size</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.building.size = <span class="string">'Big'</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuilderFlat</span><span class="params">(Builder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_floor</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.building.floor = <span class="string">'More than One'</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_size</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.building.size = <span class="string">'Small'</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Product</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.floor = <span class="keyword">None</span></span><br><span class="line">        self.size = <span class="keyword">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Floor: %s | Size: %s'</span> % (self.floor, self.size)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Client</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    director = Director()</span><br><span class="line">    director.builder = BuilderHouse()</span><br><span class="line">    director.construct_building()</span><br><span class="line">    building = director.get_building()</span><br><span class="line">    print(building)</span><br><span class="line">    director.builder = BuilderFlat()</span><br><span class="line">    director.construct_building()</span><br><span class="line">    building = director.get_building()</span><br><span class="line">    print(building)</span><br></pre></td></tr></table></figure><h3 id="4-Prototype（原型）"><a href="#4-Prototype（原型）" class="headerlink" title="4. Prototype（原型）"></a>4. Prototype（原型）</h3><p><strong>意图：</strong></p><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p><strong>适用性：</strong></p><p>当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者为了避免创建一个与产品类层次平行的工厂类层次时；或者当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p><p><img src="https://images2015.cnblogs.com/blog/824579/201609/824579-20160928194103188-1537654983.gif" alt="img"></p><p><strong>实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Prototype</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._objects = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register_object</span><span class="params">(self, name, obj)</span>:</span></span><br><span class="line">        <span class="string">"""Register an object"""</span></span><br><span class="line">        self._objects[name] = obj</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unregister_object</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""Unregister an object"""</span></span><br><span class="line">        <span class="keyword">del</span> self._objects[name]</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clone</span><span class="params">(self, name, **attr)</span>:</span></span><br><span class="line">        <span class="string">"""Clone a registered object and update inner attributes dictionary"""</span></span><br><span class="line">        obj = copy.deepcopy(self._objects.get(name))</span><br><span class="line">        obj.__dict__.update(attr)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"I am A"</span></span><br><span class="line"> </span><br><span class="line">    a = A()</span><br><span class="line">    prototype = Prototype()</span><br><span class="line">    prototype.register_object(<span class="string">'a'</span>, a)</span><br><span class="line">    b = prototype.clone(<span class="string">'a'</span>, a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">    print(a)</span><br><span class="line">    print(b.a, b.b, b.c)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="5-Singleton（单例）"><a href="#5-Singleton（单例）" class="headerlink" title="5. Singleton（单例）"></a>5. Singleton（单例）</h3><p><strong>意图：</strong></p><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>适用性：</strong></p><p>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</p><p>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</p><p><img src="https://images2015.cnblogs.com/blog/824579/201609/824579-20160928194345281-610274391.gif" alt="img"></p><p><strong>实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Singleton</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">''''' A python style singleton '''</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            org = super(Singleton, cls)</span><br><span class="line">            cls._instance = org.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SingleSpam</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, s)</span>:</span></span><br><span class="line">            self.s = s</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self.s</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    s1 = SingleSpam(<span class="string">'spam'</span>)</span><br><span class="line">    <span class="keyword">print</span> id(s1), s1</span><br><span class="line">    s2 = SingleSpam(<span class="string">'spa'</span>)</span><br><span class="line">    <span class="keyword">print</span> id(s2), s2</span><br><span class="line">    <span class="keyword">print</span> id(s1), s1</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码均为 Python 2，我一边验证一边更新代码和文章</p><p>（庄心昊）</p></blockquote>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-cv2 Contour 属性</title>
      <link href="/2018/06/01/cv2_contour/"/>
      <content type="html"><![CDATA[<p><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_features/py_contour_features.html" target="_blank" rel="noopener">Contour Features</a></p>]]></content>
      
      <categories>
          
          <category> 包特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进阶 </tag>
            
            <tag> cv2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python进阶函数和功能_#3（Collections）</title>
      <link href="/2018/05/17/python-collections/"/>
      <content type="html"><![CDATA[<p>collections 是 Python 内建的一个集合模块，提供了许多有用的集合类。</p><blockquote><p>参考资料：<a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001411031239400f7181f65f33a4623bc42276a605debf6000" target="_blank" rel="noopener">collections - 廖雪峰的官方网站</a></p></blockquote><div id="content"></div><blockquote><p><strong>下面是快捷方式</strong>（点击直达）<br><a href="/2018/05/17/python-collections/#tuple 和 NamedTuple"><code>tuple 和 NamedTuple</code></a>、<a href="/2018/05/17/python-collections/#DefaultDict"><code>DefaultDict</code></a>、<a href="/2018/05/17/python-collections/#Counter"><code>Counter</code></a></p></blockquote><a id="more"></a><h2 id="tuple-和-NamedTuple"><a href="#tuple-和-NamedTuple" class="headerlink" title="tuple 和 NamedTuple"></a>tuple 和 NamedTuple</h2><h3 id="tuple-不可变的相对性"><a href="#tuple-不可变的相对性" class="headerlink" title="tuple 不可变的相对性"></a>tuple 不可变的相对性</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">t</span> = ('<span class="built_in">text</span>', [<span class="number">11</span>, <span class="number">22</span>])</span><br><span class="line"><span class="built_in">t</span>[<span class="number">1</span>].append(<span class="number">33</span>)</span><br><span class="line">print(<span class="built_in">t</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><pre><code>(&apos;text&apos;, [11, 22, 33])</code></pre><h3 id="immutable-的优势"><a href="#immutable-的优势" class="headerlink" title="immutable 的优势"></a>immutable 的优势</h3><ol><li>性能优化：在编译时作为常量确定（python是解释型语言）</li><li>线程安全</li><li>可哈希（list 对象不可以）</li></ol><blockquote><p><strong>可哈希（hashable）和不可改变性（immutable）</strong></p><ul><li>如果一个对象在自己的生命周期中有一哈希值（hash value）是不可改变的，那么它就是可哈希的（hashable）的，因为这些数据结构内置了哈希值，每个可哈希的对象都内置了 <code>__hash__</code> 方法.</li><li>所以可哈希的对象可以 <strong>通过哈希值进行对比</strong> ，也可以 <strong>作为字典的键值</strong> 和 <strong>作为 <code>set</code> 函数的参数</strong> 。Python 中所有不可改变的的对象（imutable objects）都是可哈希的，比如 <code>字符串</code>，<code>元组</code>，也就是说可改变的容器如 <code>字典</code>，<code>列表</code> 不可哈希（unhashable）。我们用户所定义的 <code>类的实例对象</code> 默认是可哈希的（hashable），它们都是唯一的，而 hash 值也就是它们的id。</li><li>因为哈希键一定是不可改变的，所以它们对应的哈希值也不改变。如果允许它们改变，那么它们在数据结构如哈希表中的存储位置也会改变，因此会与哈希的概念违背，<strong>效率</strong> 会大打折扣。</li></ul></blockquote><h3 id="tuple-拆包"><a href="#tuple-拆包" class="headerlink" title="tuple 拆包"></a>tuple 拆包</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = (<span class="string">'John Theo'</span>, <span class="number">21</span>, <span class="number">176</span>, <span class="string">'Zhejiang University'</span>)</span><br><span class="line">name, *others = info</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(name)</span></span></span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><pre><code>John Theo</code></pre><p>结果包含了 <strong>位置对应</strong> 信息</p><h3 id="NamedTuple"><a href="#NamedTuple" class="headerlink" title="NamedTuple"></a>NamedTuple</h3><p>NamedTuple 相对 class 节省空间，因为少了很多魔术方法</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from collections import namedtuple</span><br><span class="line"></span><br><span class="line">User = namedtuple('User', ['name', 'age', 'height'])</span><br><span class="line">user_tuple = ('John_Theo', <span class="number">21</span>)</span><br><span class="line">user = User(<span class="name">*user_tuple</span>, <span class="number">176</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="name">user</span>.name, user.age, user.height)</span><br><span class="line">print(<span class="name">user</span>._asdict())</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><pre><code>John_Theo 21 176OrderedDict([(&apos;name&apos;, &apos;John_Theo&apos;), (&apos;age&apos;, 21), (&apos;height&apos;, 176)])</code></pre><blockquote><p>NamedTuple 继承 tuple，也支持拆包。</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="DefaultDict"><a href="#DefaultDict" class="headerlink" title="DefaultDict"></a>DefaultDict</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default_generator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">info_dict = defaultdict(default_generator)</span><br><span class="line"></span><br><span class="line">user_list = [<span class="string">'John'</span>, <span class="string">'Jack'</span>, <span class="string">'John'</span>, <span class="string">'Jack'</span>, <span class="string">'Jay'</span>]</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> user_list:</span><br><span class="line">    info_dict[user] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(info_dict)</span><br><span class="line"></span><br><span class="line">target_users = [<span class="string">'John'</span>, <span class="string">'Jack'</span>, <span class="string">'Jay'</span>, <span class="string">'Jessy'</span>]</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> target_users:</span><br><span class="line">    print(info_dict[user], end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><pre><code>defaultdict(&lt;function default_generator at 0x0000020AB6FA2EA0&gt;, {&apos;John&apos;: 2, &apos;Jack&apos;: 2, &apos;Jay&apos;: 1})2 2 1 0 </code></pre><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line">texts = [<span class="string">'a'</span>, <span class="string">'s'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'s'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'s'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>]</span><br><span class="line">letter_counter = Counter(texts)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(letter_counter)</span></span></span><br><span class="line"></span><br><span class="line">letter_counter.update(<span class="string">'dwqsadadwa'</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(letter_counter)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(letter_counter.most_common(<span class="number">2</span>)</span></span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><pre><code>Counter({&apos;a&apos;: 3, &apos;s&apos;: 3, &apos;d&apos;: 3, &apos;c&apos;: 1})Counter({&apos;a&apos;: 6, &apos;d&apos;: 6, &apos;s&apos;: 4, &apos;w&apos;: 2, &apos;c&apos;: 1, &apos;q&apos;: 1})[(&apos;a&apos;, 6), (&apos;d&apos;, 6)]</code></pre><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pandas 实用手记（concat/merge）</title>
      <link href="/2018/05/03/pandas-merge/"/>
      <content type="html"><![CDATA[<p>在使用 pandas 的过程中，经常用到 merge 或者 concat 操作，今小小补习，作笔记于此。<br>索引：<a href="/2018/05/03/pandas-merge/#merge"><code>merge</code></a> / <a href="/2018/05/03/pandas-merge/#concat"><code>concat</code></a></p><div id="content"></div><blockquote><p>参考资料：<a href="https://my.oschina.net/lionets/blog/279785?fromerr=Z1jmQb0L" target="_blank" rel="noopener">pandas 数据规整</a></p></blockquote><a id="more"></a><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a><strong>merge</strong></h2><p>merge 函数通过 <strong>一个或多个键</strong> 来将数据集的 <strong>行</strong> 连接起来。该函数的主要应用场景是针对同一个 <code>主键</code> 存在两张包含不同特征的表，通过该主键的连接，将两张表进行合并。合并之后，两张表的行数没有增加，列数是两张表的列数之和减一。<br>函数的具体参数为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">merge</span>(<span class="keyword">left</span>,<span class="keyword">right</span>,how=<span class="string">'inner'</span>,<span class="keyword">on</span>=<span class="keyword">None</span>,left_on=<span class="keyword">None</span>,right_on=<span class="keyword">None</span>,</span><br><span class="line">left_index=<span class="literal">False</span>,right_index=<span class="literal">False</span>,<span class="keyword">sort</span>=<span class="literal">False</span>,suffixes=(<span class="string">'_x'</span>,<span class="string">'_y'</span>),copy=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li><code>on=None</code> 指定连接的列名，若两列希望连接的列名不一样，可以通过 <code>left_on</code> 和 <code>right_on</code> 来具体指定</li><li><code>how=&#39;inner&#39;</code> 参数指的是左右两个表主键那一列中存在不重合的行时，取结果的方式：inner表示交集，outer 表示并集，left 和right 表示取某一边。 </li></ul><p>举例如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">df1 = pd.DataFrame([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">3</span>,<span class="number">9</span>,<span class="number">0</span>],[<span class="number">8</span>,<span class="number">0</span>,<span class="number">3</span>]], columns=['x1','x2','x3'])</span><br><span class="line">df2 = pd.DataFrame([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">9</span>]], columns=['x1','x4'])</span><br><span class="line"></span><br><span class="line">df3 = pd.merge(df1, df2, how='left', on='x1')</span><br><span class="line">print(df3)</span><br></pre></td></tr></table></figure><ul><li><code>on=&#39;x1&#39;</code>，即以两个表中的x1为主键进行连接，</li><li><code>how=&#39;left&#39;</code>，即是以两个表中 <code>merge</code> 函数中左边那个表的行为准，保持左边表行数不变，拿右边的表与之合并。</li></ul><p>df3 结果如下：</p><blockquote><p>  x1  x2  x3   x4<br>0   1   2   3  2.0<br>1   5   6   7  NaN<br>2   3   9   0  9.0<br>3   8   0   3  NaN</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a><strong>concat</strong></h2><p>concat 与其说是连接，更准确的说是拼接。就是把两个表直接合在一起。于是有一个突出的问题，是 <strong>横向拼接</strong> 还是 <strong>纵向拼接</strong>，所以 concat 函数的关键参数是 <code>axis</code> 。<br>函数的具体参数是：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat<span class="params">(objs,<span class="attr">axis</span>=0,<span class="attr">join</span>='outer',<span class="attr">join_axes</span>=None,<span class="attr">ignore_index</span>=False,<span class="attr">keys</span>=None,<span class="attr">levels</span>=None,<span class="attr">names</span>=None,<span class="attr">verigy_integrity</span>=False)</span></span><br></pre></td></tr></table></figure><ul><li><code>objs</code> 是需要拼接的对象集合，一般为列表或者字典</li><li><code>axis=0</code> 是 <strong>行拼接</strong>，拼接之后行数增加，列数也根据 <code>join</code> 来定，<code>join=&#39;outer&#39;</code> 时，列数是两表并集。同理<code>join=&#39;inner&#39;</code>，列数是两表交集。</li></ul><p>在默认情况下，<code>axis=0</code> 为纵向拼接，此时有：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">concat</span><span class="params">([df1,df2])</span></span>  &lt;=&gt;  df1.append(df2)</span><br></pre></td></tr></table></figure><p>在axis=1 时为横向拼接 ，此时有</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat([df1,df2],<span class="attribute">axis</span>=1)  &lt;=&gt;  merge(df1,df2,<span class="attribute">left_index</span>=<span class="literal">True</span>,right_index=True,how='outer')</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>], <span class="string">'data1'</span>: range(<span class="number">4</span>)&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'c'</span>], <span class="string">'data2'</span>: range(<span class="number">4</span>)&#125;)</span><br><span class="line"></span><br><span class="line">print(pd.concat([df1, df2],axis=<span class="number">1</span>))</span><br><span class="line">print(pd.merge(df1, df2, left_index=<span class="keyword">True</span>, right_index=<span class="keyword">True</span>, how=<span class="string">'outer'</span>))</span><br></pre></td></tr></table></figure><p>输出如下：</p><blockquote><p>   data1 key  data2 key<br>0      0   a      0   b<br>1      1   a      1   b<br>2      2   b      2   c<br>3      3   b      3   c</p></blockquote><blockquote><p>  data1 key_x  data2 key_y<br>0      0     a      0     b<br>1      1     a      1     b<br>2      2     b      2     c<br>3      3     b      3     c</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习资源链接汇总</title>
      <link href="/2018/03/28/ML-terms/"/>
      <content type="html"><![CDATA[<p><strong>快速链接</strong><br><a href="/2018/03/28/ML-terms/#课程"><code>课程</code></a>、<a href="/2018/03/28/ML-terms/#术语表"><code>术语表</code></a>、<a href="/2018/03/28/ML-terms/#三个月入门"><code>三个月入门</code></a></p><a id="more"></a><hr><h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><h3 id="Google-Crash-Course"><a href="#Google-Crash-Course" class="headerlink" title="Google Crash Course"></a>Google Crash Course</h3><p><i class="fa fa-arrow-circle-right"></i>&ensp;<a href="https://developers.google.cn/machine-learning/crash-course/?hl=zh-CN" target="_blank" rel="noopener"><code>转到</code></a></p><hr><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><h3 id="Google-×-TensorFlow"><a href="#Google-×-TensorFlow" class="headerlink" title="Google × TensorFlow"></a>Google × TensorFlow</h3><p><i class="fa fa-arrow-circle-right"></i>&ensp;<a href="https://developers.google.cn/machine-learning/crash-course/glossary?hl=zh-CN" target="_blank" rel="noopener"><code>转到</code></a></p><hr><h2 id="三个月入门"><a href="#三个月入门" class="headerlink" title="三个月入门"></a>三个月入门</h2><p><br></p><blockquote><p>Author: Siraj Raval @ Youtube<br>Original Link <a href="https://www.youtube.com/watch?v=Cr6VqTRO1v0" target="_blank" rel="noopener">Here</a></p></blockquote><h3 id="Month-1"><a href="#Month-1" class="headerlink" title="Month 1"></a>Month 1</h3><ul><li><strong>Week 1</strong> - <a href="https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/" target="_blank" rel="noopener"><code>Linear Algebra</code></a></li><li><strong>Week 2</strong> - <a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDMsr9K-rj53DwVRMYO3t5Yr" target="_blank" rel="noopener"><code>Calculus</code></a></li><li><strong>Week 3</strong> - <a href="https://www.edx.org/course/introduction-probability-science-mitx-6-041x-2" target="_blank" rel="noopener"><code>Probability</code></a></li><li><strong>Week 4</strong> - <a href="https://www.coursera.org/courses?languages=en&amp;query=Algorithm%20design%20and%20analysis" target="_blank" rel="noopener"><code>Algorithms</code></a></li></ul><h3 id="Month-2"><a href="#Month-2" class="headerlink" title="Month 2"></a>Month 2</h3><ul><li><strong>Week 1</strong><ul><li><a href="https://www.youtube.com/watch?v=T5pRlIbr6gg" target="_blank" rel="noopener">learn <code>python</code> for data science</a></li><li><a href="https://www.youtube.com/watch?v=xRJCOz3AfYY" target="_blank" rel="noopener"><code>Math</code> of Intelligence</a></li><li><a href="https://www.youtube.com/watch?v=2FmcHiLCwTU" target="_blank" rel="noopener">Intro to <code>Tensorflow</code></a><br><br></li></ul></li><li><strong>Week 2</strong><ul><li><a href="https://eu.udacity.com/course/intro-to-machine-learning--ud120" target="_blank" rel="noopener">Intro to <code>ML</code> (Udacity)</a><br><br></li></ul></li><li><strong>Week 3-4</strong><ul><li><a href="https://github.com/NirantK/awesome-project-ideas" target="_blank" rel="noopener">ML <code>Project</code> Ideas</a></li></ul></li></ul><h3 id="Month-3-Deep-Learning"><a href="#Month-3-Deep-Learning" class="headerlink" title="Month 3 (Deep Learning)"></a>Month 3 (Deep Learning)</h3><ul><li><strong>Week 1</strong> <ul><li><a href="https://www.youtube.com/watch?v=vOppzHpvTiQ" target="_blank" rel="noopener">Intro to <code>Deep Learning</code></a><br><br></li></ul></li><li><strong>Week 2</strong> <ul><li><a href="http://course.fast.ai/" target="_blank" rel="noopener">Deep Learning by <code>Fast.AI</code></a><br><br></li></ul></li><li><strong>Week 3-4</strong><ul><li><a href="https://github.com/llSourcell?tab=repositories" target="_blank" rel="noopener"><code>Re-implement</code> DL projects from my github</a></li></ul></li></ul><h3 id="For-the-future"><a href="#For-the-future" class="headerlink" title="For the future"></a>For the future</h3><ul><li><a href="https://www.quora.com/Who-should-I-follow-on-Twitter-to-get-useful-and-reliable-machine-learning-information" target="_blank" rel="noopener">ML <code>people to follow</code> on Twitter</a></li></ul><hr>]]></content>
      
      <categories>
          
          <category> 学习路径 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 链接 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 版本区别翻译</title>
      <link href="/2018/03/28/python-translation/"/>
      <content type="html"><![CDATA[<p>有言曰：</p><blockquote><p>了解一门语言最好的方法是了解它的历史沿革。</p></blockquote><p>本着这一宗旨，同时也为了目前 Python 学习和例程中不同版本写法不同带来的诸多困扰，我开始着手翻译 <a href="https://docs.python.org/3/whatsnew/3.0.html" target="_blank" rel="noopener"><code>What’s New In Python 3.0</code></a> 。如果你同样有兴趣，欢迎加入翻译工作。</p><p>为了协作方便，本项目就托管在github上了，完成的工作会定期迁移到本文。</p><p><strong><a href="https://github.com/John-Theo/PythonDocTranslation" target="_blank" rel="noopener"><code>Repo 传送门</code></a></strong></p><a id="more"></a><hr><blockquote><p>原文链接：<a href="https://docs.python.org/3/whatsnew/3.0.html" target="_blank" rel="noopener">https://docs.python.org/3/whatsnew/3.0.html</a><br>  原作者：Guido van Rossum<br>责任翻译：庄心昊</p></blockquote><p><strong>！ 注意：本文对比版本为 3.0 和 2.6，如果你关心最新版本的变化，请在</strong> <a href="https://docs.python.org/3/whatsnew/changelog.html#changelog" target="_blank" rel="noopener">这里</a> <strong>查看 change log。</strong></p><p><strong>另外，如果你发现本文的机制在最新的版本中不适用，请提交issue。</strong></p><p><strong>（以下为作者正文）</strong></p><hr><p>本文简述了 Python 3.0 相对于 2.6 版本的新功能。 Python 3.0 也被称为 “Python 3000” 或 “Py3K”，是有史以来第一个 <em>特意向后兼容</em>  的Python版本。比普通的发行版本有更多的变化，且对于所有Python用户来说更重要。尽管如此，在充分了解了这些变化之后，你会发现 Python 其实并没有改变太多 —— 总的来说，我们主要修复了广为提及的小问题，并去除了很多无用的设计。</p><p>本文的目的不是提供所有新功能的详细说明，而是试图给出一个简便的概述。有关完整的详细信息，请参阅 Python 3.0 的文档和/或文中引用的许多PEP。如果您想了解特定功能的完整实施和设计原理，PEP通常比常规文档具有更多的细节；但请注意，一旦功能完全实施，PEP通常不会保持在最新状态。</p><blockquote><p><strong>译者注：PEP (Python Enhancement Proposals) 是一份为Python社区提供各种增强功能的技术规格，也是提交新特性，以便让社区指出问题，精确化技术文档的提案。<a href="https://www.python.org/dev/peps/" target="_blank" rel="noopener"><code>传送门</code></a></strong></p></blockquote><p>由于时间限制，这个文件并不像它应该呈现的那样完整。与新的发行版本一样，源代码中的 <code>Misc/NEWS</code> 文件包含大量有关已更改的每个小细节的详细信息。</p><h2 id="常见的绊脚石"><a href="#常见的绊脚石" class="headerlink" title="常见的绊脚石"></a>常见的绊脚石</h2><p>如果您已经习惯于使用 Python 2.5，本节列出了最有可能困住您的一些变化。</p><h3 id="print-是一个函数"><a href="#print-是一个函数" class="headerlink" title="print 是一个函数"></a>print 是一个函数</h3><p><code>print</code> 语句已被 <a href="https://docs.python.org/3/library/functions.html#print" target="_blank" rel="noopener">print()</a> 函数替代，其中的关键字参数替换了原先 <code>print</code> 语句的大部分特殊语法（<a href="https://www.python.org/dev/peps/pep-3105" target="_blank" rel="noopener"><strong>PEP 3105</strong></a>）。 例程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Old: <span class="keyword">print</span> <span class="string">"The answer is"</span>, <span class="number">2</span>*<span class="number">2</span></span><br><span class="line">New: print(<span class="string">"The answer is"</span>, <span class="number">2</span>*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Old: <span class="keyword">print</span> x,           <span class="comment"># 结尾的逗号使输出结束后不换行</span></span><br><span class="line">New: print(x, end=<span class="string">" "</span>)  <span class="comment"># 每行结束后连接上end关键字传入的字符（译者注：本例中是一个空格）</span></span><br><span class="line"></span><br><span class="line">Old: <span class="keyword">print</span>              <span class="comment"># 输出新的一行</span></span><br><span class="line">New: print()            <span class="comment"># 你必须调用函数！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 译者注：输出重定向</span></span><br><span class="line">Old: <span class="keyword">print</span> &gt;&gt;sys.stderr, <span class="string">"fatal error"</span></span><br><span class="line">New: print(<span class="string">"fatal error"</span>, file=sys.stderr)</span><br><span class="line"></span><br><span class="line">Old: <span class="keyword">print</span> (x, y)       <span class="comment"># 输出 repr((x, y))（译者注：__repr__是魔术功能）</span></span><br><span class="line">New: print((x, y))      <span class="comment"># 和 print(x, y)不完全相同！（译者注：新旧表达作用一致）</span></span><br></pre></td></tr></table></figure></p><p>您也可以自定义元素之间的分隔符，例如：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">print</span>(<span class="string">"There are &lt;"</span>, 2*<span class="number">*32</span>, <span class="string">"&gt; possibilities!"</span>, <span class="attribute">sep</span>=<span class="string">""</span>)</span><br></pre></td></tr></table></figure></p><p><strong>输出：</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There are <span class="tag">&lt;<span class="name">4294967296</span>&gt;</span> possibilities!</span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong></p><ul><li><a href="https://docs.python.org/3/library/functions.html#print" target="_blank" rel="noopener">print()</a> 函数不支持旧 <code>print</code> 申明的 <code>softspace</code> 特征。例如在 Python 2.x 中，<code>print &quot;A\n&quot;, &quot;B&quot;</code> 会输出 <code>&quot;A\nB\n&quot;</code>；但是，在 Python 3.x 中，<code>print &quot;A\n&quot;, &quot;B&quot;</code> 输出 <code>&quot;A\n B\n&quot;</code>。</li><li>刚开始在交互模式中，你会发现自己码上很多旧的 <code>print x</code> 表达。是时候训练你的手指猛戳新的 <code>print(x)</code> 了！</li><li>在使用 <code>2to3</code> source-to-source 转换工具的时候，所有的 <code>print</code> 表达会自动转化成 <a href="https://docs.python.org/3/library/functions.html#print" target="_blank" rel="noopener">print()</a> 函数调用，所以这对比较大的项目不是特别大的麻烦。</li></ul><h3 id="返回-Views-对象-和-迭代器-而不再是-Lists"><a href="#返回-Views-对象-和-迭代器-而不再是-Lists" class="headerlink" title="返回 Views 对象 和 迭代器 而不再是 Lists"></a>返回 Views 对象 和 迭代器 而不再是 Lists</h3><p>一些著名的 API 接口不再返回列表（list）：</p><ul><li><a href="https://docs.python.org/3/library/stdtypes.html#dict" target="_blank" rel="noopener">dict</a> 方法 <a href="https://docs.python.org/3/library/stdtypes.html#dict.keys" target="_blank" rel="noopener">dict.keys()</a>，<a href="https://docs.python.org/3/library/stdtypes.html#dict.items" target="_blank" rel="noopener">dict.items()</a> 和 <a href="https://docs.python.org/3/library/stdtypes.html#dict.values" target="_blank" rel="noopener">dict.values()</a> 不再返回 list，而返回 view 对象 [<a href="#q1">1</a>]。例如，这样的表达不再生效：<code>k = d.keys(); k.sort()</code>。需要使用 <code>k = sorted(d)</code> 来代替（这在 Python 2.5 中一样适用，且一样快捷）。</li><li>同时，<code>dict.iterkeys()</code>，<code>dict.iteritems()</code> 和 <code>dict.itervalues()</code> 方法也不再受支持。</li><li><a href="https://docs.python.org/3/library/functions.html#map" target="_blank" rel="noopener">map()</a> 和 <a href="https://docs.python.org/3/library/functions.html#filter" target="_blank" rel="noopener">filter()</a> 返回迭代器（iterators）。如果你确实需要 list 对象，且传入序列全部等长，一个便捷的解决方案是把 <a href="https://docs.python.org/3/library/functions.html#map" target="_blank" rel="noopener">map()</a> 嵌套在 <a href="https://docs.python.org/3/library/stdtypes.html#list" target="_blank" rel="noopener">list()</a> 里，例如 <code>list(map(...))</code>，但是，一个更好的解决方案是尽量使用 list comprehension（尤其当原始代码使用了 <a href="https://docs.python.org/3/reference/expressions.html#lambda" target="_blank" rel="noopener">lambda</a> 时），或者重写代码，使其不需要用到 list（译者注：耿直了老铁）。一个特别的小技巧： <a href="https://docs.python.org/3/library/functions.html#map" target="_blank" rel="noopener">map()</a> 作为函数的 side effects 调用；正确的变形是使用普通的 <a href="https://docs.python.org/3/reference/compound_stmts.html#for" target="_blank" rel="noopener">for</a> 循环（因为创建一个 list 也是浪费）。<br>如果传入序列并不等长，<a href="https://docs.python.org/3/library/functions.html#map" target="_blank" rel="noopener">map()</a> 会在最短序列的末端停止 [<a href="#q2">2</a>]。若希望和 Python 2.x 中的 <a href="https://docs.python.org/3/library/functions.html#map" target="_blank" rel="noopener">map()</a> 完全兼容，同样可以把序列嵌套在 <code>itertools.zip_longest()</code> 中，例如：<code>map(func, *sequences)</code> 将写为 <code>list(map(func, itertools.zip_longest(*sequences)))</code>。</li><li>现在，<a href="https://docs.python.org/3/library/stdtypes.html#range" target="_blank" rel="noopener">range()</a> 函数的使用和 <code>xrange()</code> 函数曾经的用法类似，但是前者可以处理任意大小的值，后者不再存在。</li><li><a href="https://docs.python.org/3/library/functions.html#zip" target="_blank" rel="noopener">zip()</a> 现在也返回迭代器。</li></ul><div class="q1"></div><blockquote><p>[1] 译者注：关于更好理解 views 的概念，请看下例：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dishes = &#123;<span class="string">'eggs'</span>: <span class="number">2</span>, <span class="string">'sausage'</span>: <span class="number">1</span>, <span class="string">'bacon'</span>: <span class="number">1</span>, <span class="string">'spam'</span>: <span class="number">500</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys = dishes.keys()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = dishes.values()  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># iteration（译者注：更像是枚举？）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">0</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> val <span class="keyword">in</span> values:  </span><br><span class="line"><span class="meta">... </span>    n += val  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(n)  </span><br><span class="line"><span class="number">504</span>  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># keys 和 values 以相同的顺序被遍历</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(keys)</span><br><span class="line">[<span class="string">'eggs'</span>, <span class="string">'bacon'</span>, <span class="string">'sausage'</span>, <span class="string">'spam'</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(values)  </span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">500</span>]  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># view 对象动态反映 dict 的变化（译者注：从这个定义来看，view 也许可以翻译为“快照”）  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> dishes[<span class="string">'eggs'</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> dishes[<span class="string">'sausage'</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(keys)  </span><br><span class="line">[<span class="string">'spam'</span>, <span class="string">'bacon'</span>]  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 集合操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys &amp; &#123;<span class="string">'eggs'</span>, <span class="string">'bacon'</span>, <span class="string">'salad'</span>&#125;  </span><br><span class="line">&#123;<span class="string">'bacon'</span>&#125;</span><br></pre></td></tr></table></figure><div class="q2"></div><blockquote><p>[2] 译者注：原文对“会在最短序列的末端停止”的解释是：<br>With multiple iterables, the iterator stops when the shortest iterable is exhausted. For cases where the function inputs are already arranged into argument tuples, see <a href="https://docs.python.org/3/library/itertools.html#itertools.starmap" target="_blank" rel="noopener">itertools.starmap()</a>.</p></blockquote><h3 id="大小比较"><a href="#大小比较" class="headerlink" title="大小比较"></a>大小比较</h3><p>Python 3.0 简化了大小比较的流程：</p><ul><li>当表达式没有天然可比的标度时，顺序比较操作符 (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code>) 会抛出一个 TypeError exception。因此，诸如 <code>1 &lt; &#39;&#39;</code>，<code>0 &gt; None</code> 或 <code>len &lt;= len</code> 这样的表达式不再合法，而对于比如 <code>None &lt; None</code> 这样的表达，则会抛出一个 <a href="https://docs.python.org/3/library/exceptions.html#TypeError" target="_blank" rel="noopener">TypeError</a> 而不是返回 <code>False</code>。这就意味着对一个异质的 list 排序不再可行——所有元素必须互相之间可比。值得注意的是，这一限制对 <code>==</code> 和 <code>!=</code> 操作符并不存在：不同类型的对象比较结果总是不同。</li><li>builtin.sorted() 和 <a href="https://docs.python.org/3/library/stdtypes.html#list.sort" target="_blank" rel="noopener">list.sort()</a> 不再接受 <em>cmp</em> 参数指定的比较函数，而使用键值对指定。注意：<em>key</em> 和 <em>reverse</em> 参数现在只能通过键值对指定。</li><li>cmp() 函数应该被视为不存在了，而 __cmp__() 魔术方法也不再受支持。现在使用 <a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__" target="_blank" rel="noopener">__lt__()</a> 来排序， <a href="https://docs.python.org/3/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener">__eq__()</a> 配合 <a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener">__hash__()</a> 使用，以及其他所需的比较操作符。（如果你真的很想实现 cmp() 的功能，你可以使用如下表达式 <code>(a &gt; b) - (a &lt; b)</code> ，它的效果和 <code>cmp(a, b)</code> 相同。）</li></ul><blockquote><p>__cmp__() 魔术方法在目前的 python 3.6.4 中依然受到支持，但 cmp() 函数确实不见了。</p></blockquote><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><ul><li><a href="https://www.python.org/dev/peps/pep-0237" target="_blank" rel="noopener"><strong>PEP 237</strong></a>：事实上，long （译者注：长整型）被重命名为 <a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener">int</a>。这就意味着，只有一个內建（built-in）的叫做 <a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener">int</a> 的整形，但是从表现来看，它和原先的 long 差不多。</li><li><a href="https://www.python.org/dev/peps/pep-0238" target="_blank" rel="noopener"><strong>PEP 238</strong></a>：一个诸如 <code>1/2</code> 的表达式返回一个 float。而使用 <code>1//2</code> 来得到截尾（取整）的结果。（后面的表达形式已经存在了数年，至少从 Python 2.2 开始就有了。）</li><li>因为对整形的值不再有限制， <code>sys.maxint</code> 常量被取消。但是 <code>sys.maxsize</code> 可以被用作一个大于任何 practical list 和 string index（译者注：字符串索引？） 的整数。它符合现实的“自然”整数的大小，并且和上一次同一平台中发布版本中的 <code>sys.maxint</code> 相同（如果编译环境完全相同的话）。</li><li>长整数的 <a href="https://docs.python.org/3/library/functions.html#repr" target="_blank" rel="noopener">repr()</a> 函数不需要再尾随一个 <code>L</code> 了，所以无条件 strip 该对象的代码将会删去最后一位数字。（使用 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str()</a> 替代。）</li><li>八进制表示不再写作 <code>0720</code> 这样的形式；而使用例如 <code>0o720</code> 的形式来代替。</li></ul><h3 id="Text-Vs-Data-取代-Unicode-Vs-8-bit"><a href="#Text-Vs-Data-取代-Unicode-Vs-8-bit" class="headerlink" title="Text Vs. Data 取代 Unicode Vs. 8-bit"></a>Text Vs. Data 取代 Unicode Vs. 8-bit</h3><p>你此前关于 二进制数据 和 Unicode 的 认识被全部改变了。</p><ul><li>Python 3.0 使用 <em>text</em> 和 （二进制）数据 的概念来取代 Unicode 字符串 和 8位字符串。所有的 text 都是 Unicode；而已编码的 Unicode（数据）则被作为 二进制数据。用来存放 text 的类型是 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a>，用来存放数据（data）的数据类型是字节（byte）。Python 3.0 和 2.x 之间最大的区别是任何企图混淆 text 和 data 的做法都会引发 <a href="https://docs.python.org/3/library/exceptions.html#TypeError" target="_blank" rel="noopener">TypeError</a>；而如果你要在 Python 2.x 中将 Unicode 和 8位字符串 混合使用，当 8位字符串 正好只有7位（ASCII）时，是没问题的；但当其中包含非ASCII值时，就会引发 <a href="https://docs.python.org/3/library/exceptions.html#UnicodeDecodeError" target="_blank" rel="noopener">UnicodeDecodeError</a> 错误。这样针对数值的做法在近几年引起了众多的不满。</li><li>因为这一点原则性的变化，几乎所有使用Unicode，编码或二进制数据的代码都需要更改。这项改变是有建设性的，因为在 2.x 版本中，由编码和非编码字符混合使用导致了非常多的bug。 要在 Python 2.x 中准备好，请对所有未编码的 text 使用 Unicode，并且对二进制或已编码数据使用 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a>。 然后 <code>2to3</code> 工具将为您完成大部分工作。</li><li>以后，您不需要再对 Unicode 文本使用 <code>u&quot;...&quot;</code> 这样的表达了。然而，您仍然需要对二进制数据使用 <code>b&quot;...&quot;</code> 这样的表达。</li><li>因为 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a> 和 <a href="https://docs.python.org/3/library/stdtypes.html#bytes" target="_blank" rel="noopener">bytes</a> 类型不能混用，您必须明确声明两者之间的转换。使用 <a href="https://docs.python.org/3/library/stdtypes.html#str.encode" target="_blank" rel="noopener">str.encode()</a> 来将 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a> 转换为 <a href="https://docs.python.org/3/library/stdtypes.html#bytes" target="_blank" rel="noopener">bytes</a>，<a href="https://docs.python.org/3/library/stdtypes.html#bytes.decode" target="_blank" rel="noopener">bytes.decode()</a> 反之。你也可以分别使用 <code>bytes(s, encoding=...)</code> 和 <code>str(b, encoding=...)</code>。</li><li>和 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a> 一样，<a href="https://docs.python.org/3/library/stdtypes.html#bytes" target="_blank" rel="noopener">bytes</a> 类型也是不可变的。有一个单独的 _可变_ 类型来保存缓冲（buffered）的二进制数据，<a href="https://docs.python.org/3/library/stdtypes.html#bytearray" target="_blank" rel="noopener">bytearray</a>。几乎所有接受 <a href="https://docs.python.org/3/library/stdtypes.html#bytes" target="_blank" rel="noopener">bytes</a> 的接口也接受 <a href="https://docs.python.org/3/library/stdtypes.html#bytearray" target="_blank" rel="noopener">bytearray</a>。可变的 API 基于 collections.MutableSequence。</li><li>所有在原始（raw）字符串里的反斜杠都会被编译为它字面的意思。这意味着 <code>&#39;\U&#39;</code> 和 <code>&#39;\u&#39;</code> 在原始（raw）字符串中的转义不会被专门处理。比如，<code>r&#39;\u20ac&#39;</code> 在 Python 3.0 中是一个含有6个字符的字符串；而在 2.6 版本中，<code>ur&#39;\u20ac&#39;</code> 则表示一个单独的“欧元”符号。（当然，这项改变仅仅影响原始字符串书面形式，在 Python 3.0 中，欧元符号用 <code>&#39;\u20ac&#39;</code> 表示。）</li><li>內建（built-in）的 basestring 抽象类型被移去了。取而代之的是 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a>。<a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a> 和 <a href="https://docs.python.org/3/library/stdtypes.html#bytes" target="_blank" rel="noopener">bytes</a> 类型没有足够多的共同功能来共享同一个基类。 <code>2to3</code> 工具（见下文）会将所有出现的 basestring 替换成 <a href="https://docs.python.org/3/library/stdtypes.html#str" target="_blank" rel="noopener">str</a>。</li><li>以文本文件（text files）打开的文件（目前作为 <a href="https://docs.python.org/3/library/functions.html#open" target="_blank" rel="noopener">open()</a> 函数的默认模式）通常使用一种编码方式将（内存中的）字符串和（硬盘上的）字节进行映射。以二进制文件（binary files）打开的文件（打开时在 mode 参数处为 <code>&#39;b&#39;</code>）通常在内存中使用字节存储。这意味着，如果一个文件以错误的模式或编码被打开，I/O 会报错，而不是安静地对错误数据进行处理。这也意味着即使是 Unix 的用户也需要在打开文件时制定正确的模式（text 或 binary）。有一种依赖平台（操作系统）的默认编码，在 Unix 系的平台上可以通过环境变量 <code>LANG</code> 设置（个别情况下需要通过对平台特异性本地环境相关的环境变量进行设置）。在大多数情况下，但不是全部情形，系统的默认编码是 UTF-8；你永远不要指望这个默认值派大用场（译者注：谁说的！明明很多乱码问题设成 utf-8 就好了，你骗人）。任何读写非纯 ASCII 文本的应用推荐覆写编码。所以再也没有必要在 codecs 模块里，使用需要关注编码的数据流了。</li></ul>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python进阶函数和功能_#2（杂记）</title>
      <link href="/2018/03/28/python-adv-2/"/>
      <content type="html"><![CDATA[<p>本文是近期学习中零散的一些知识点，主要是面向对象，记于此。</p><div id="content"></div><blockquote><p><strong>下面是快捷方式</strong>（点击直达）<br><a href="/2018/03/28/python-adv-2/#导入模块"><code>导入模块</code></a>、<a href="/2018/03/28/python-adv-2/#导入模块"><code>导入模块</code></a>、<a href="/2018/03/28/python-adv-2/#面向对象文法"><code>面向对象文法</code></a>、<a href="/2018/03/28/python-adv-2/#属性优先级"><code>属性优先级</code></a>、<a href="/2018/03/28/python-adv-2/#类方法"><code>类方法</code></a>、<a href="/2018/03/28/python-adv-2/#类的继承"><code>类的继承</code></a>、<a href="/2018/03/28/python-adv-2/#面相对象比较"><code>面相对象比较</code></a>、<a href="/2018/03/28/python-adv-2/#不定参数的传递"><code>不定参数的传递</code></a>、<a href="/2018/03/28/python-adv-2/#关于Python版本和函数使用"><code>关于Python版本和函数使用</code></a>、</p></blockquote><a id="more"></a><h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尝试导入较老版本模块</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> simplejson <span class="keyword">as</span> json</span><br><span class="line"></span><br><span class="line">print(json.dumps(&#123;<span class="string">'python'</span>:<span class="number">3.6</span>&#125;))</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="面向对象文法"><a href="#面向对象文法" class="headerlink" title="面向对象文法"></a>面向对象文法</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(name, gender, birth)</span></span><span class="symbol">:</span></span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">xiaoming = Person(<span class="string">'Xiao Ming'</span>, <span class="string">'Male'</span>, <span class="string">'1990-1-1'</span>)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">TypeError:</span> __init_<span class="number">_</span>() takes exactly <span class="number">3</span> arguments (<span class="number">4</span> given)</span><br></pre></td></tr></table></figure><p>这会导致创建失败或运行不正常，因为第一个参数name被Python解释器传入了实例的引用，从而导致整个方法的调用参数位置全部没有对上。</p><p><strong>正确写法：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 第一个参数一定要是self！</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, birth)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><blockquote><p>第一个参数一定要是 <code>self</code>！</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="属性优先级"><a href="#属性优先级" class="headerlink" title="属性优先级"></a>属性优先级</h2><p>当实例属性和类属性重名时，实例属性优先级高，它将屏蔽掉对类属性的访问。</p><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    address = <span class="string">'Earth'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line">p2 = Person(<span class="string">'Alice'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Person.address = '</span> + Person.address)</span><br><span class="line"></span><br><span class="line">p1.address = <span class="string">'China'</span></span><br><span class="line">print(<span class="string">'p1.address = '</span> + p1.address)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Person.address = '</span> + Person.address)</span><br><span class="line">print(<span class="string">'p2.address = '</span> + p2.address)</span><br></pre></td></tr></table></figure></p><pre><code>Person.address = Earthp1.address = ChinaPerson.address = Earthp2.address = Earth</code></pre><p>我们发现，在设置了 p1.address = ‘China’ 后，p1访问 address 确实变成了 ‘China’，但是，Person.address和p2.address仍然是’Earch’，怎么回事？</p><blockquote><p>原因是 p1.address = ‘China’并 <strong>没有改变 Person 的 address</strong> ，而是给 p1这个实例绑定了<code>实例属性</code>address ，对p1来说，它有一个实例属性address（值是’China’），而它所属的类Person也有一个<code>类属性</code>address，所以:</p></blockquote><ul><li>访问 p1.address 时，优先查找实例属性，返回’China’。</li><li>访问 p2.address 时，p2没有实例属性address，但是有类属性address，因此返回’Earth’。</li></ul><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p><code>@classmethod</code> 装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    __count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">how_many</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.__count</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        Person.__count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(Person.how_many())</span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line">print(Person.how_many())</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>函数 <code>super(子类, self)</code> 将返回当前类继承的父类，然后调用<strong>init</strong>()方法，注意self参数已在super()中传入，在<strong>init</strong>()中将隐式传递，不需要写出（也不能写）。</p><p><strong>例如</strong>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, gender)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.gender = gender</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">Person</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, gender, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">super</span>(Student, <span class="keyword">self</span>).__init_<span class="number">_</span>(name, gender)</span><br><span class="line">        <span class="keyword">self</span>.score = score</span><br></pre></td></tr></table></figure><blockquote><p>一定要用 super(Student, self).<strong>init</strong>(name, gender) 去初始化父类，否则，继承自 Person 的 Student 将没有 name 和 gender。</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="面相对象比较"><a href="#面相对象比较" class="headerlink" title="面相对象比较"></a>面相对象比较</h2><p>使用魔术方法，这里有一种巧妙的表达：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">object</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'(%s: %s)'</span> % (<span class="keyword">self</span>.name, <span class="keyword">self</span>.score)</span><br><span class="line"></span><br><span class="line">    __repr_<span class="number">_</span> = __str_<span class="number">_</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__cmp__</span><span class="params">(<span class="keyword">self</span>, s)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> False == isinstance(s, Student)<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -cmp(<span class="keyword">self</span>.score, s.score) <span class="keyword">or</span> cmp(<span class="keyword">self</span>.name, s.name)</span><br><span class="line"></span><br><span class="line">L = [Student(<span class="string">'Tim'</span>, <span class="number">99</span>), Student(<span class="string">'Bob'</span>, <span class="number">88</span>), Student(<span class="string">'Alice'</span>, <span class="number">99</span>)]</span><br><span class="line"></span><br><span class="line">print(sorted(L))</span><br></pre></td></tr></table></figure></p><blockquote><p>需要特别注意的是，python 3.x 中不再支持 cmp() 函数，取而代之使用：<br><strong>lt</strong>() for sorting, <strong>eq</strong>() with <strong>hash</strong>(), and other rich comparisons as needed. (If you really need the cmp() functionality, you could use the expression (a &gt; b) - (a &lt; b) as the equivalent for cmp(a, b).</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="不定参数的传递"><a href="#不定参数的传递" class="headerlink" title="不定参数的传递"></a>不定参数的传递</h2><p>对于Person类的定义：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, gender)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.gender = gender</span><br></pre></td></tr></table></figure></p><p>希望除了 name和gender 外，可以提供任意额外的关键字参数，并绑定到实例，请修改 Person 的 <strong>init</strong>() 定 义，完成该功能。</p><p><strong>例程</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, **kw)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        <span class="comment"># Python 2.7 中 iteritems 独立封装，返回一个迭代器；但是3.*版本整合进了字典内建函数 items。</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> kw.items():</span><br><span class="line">            setattr(self, k, v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">'Bob'</span>, <span class="string">'Male'</span>, age=<span class="number">18</span>, course=<span class="string">'Python'</span>)</span><br><span class="line">print(p.age)</span><br><span class="line">print(p.course)</span><br><span class="line"><span class="comment"># Python 2.7 中 filter 对象可以直接输出，但是在3.*版本需要强制转化成 list 对象，否则输出 &lt;filter object at ...&gt;</span></span><br><span class="line">print(list(filter(<span class="keyword">lambda</span> x: x[<span class="number">0</span>] != <span class="string">'_'</span>, dir(p))))</span><br></pre></td></tr></table></figure></p><blockquote><ul><li><code>**kw</code> 以字典的形式接受参数表</li><li><code>*args</code> 以元组的方式接受参数表</li><li>关于Python版本和函数使用（<code>链接</code>）</li></ul></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p><code>__repr__</code>：调试时输出的字符串<br><code>__str__</code>：用户使用时输出的字符串<br><code>__cmp__</code>：sorted等函数调用时返回结果，可以配合 <code>cmp()</code> 函数等使用<br><code>__len__</code>：（略）<br><code>__add__</code>、<code>__sub__</code>、<code>__mul__</code>、<code>__div__</code></p><h3 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h3><p>由于Python是动态语言，任何实例在运行期都可以动态地添加属性。</p><p>如果要限制添加的属性，例如，Student类只允许添加 name、gender和score 这3个属性，就可以利用Python的一个特殊的 <code>__slots__</code> 来实现。</p><p>顾名思义，<code>__slots__</code> 是指一个类允许的属性列表：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">object</span>):</span></span><br><span class="line">    __slots_<span class="number">_</span> = (<span class="string">'name'</span>, <span class="string">'gender'</span>, <span class="string">'score'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, gender, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.gender = gender</span><br><span class="line">        <span class="keyword">self</span>.score = score</span><br></pre></td></tr></table></figure></p><p>现在，对实例进行操作：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; s = Student(<span class="string">'Bob'</span>, <span class="string">'male'</span>, <span class="number">59</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s.name = <span class="string">'Tim'</span> <span class="comment"># OK</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s.score = <span class="number">99</span> <span class="comment"># OK</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; s.grade = <span class="string">'A'</span></span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">  ...</span><br><span class="line"><span class="symbol">AttributeError:</span> <span class="string">'Student'</span> object has no attribute <span class="string">'grade'</span></span><br></pre></td></tr></table></figure></p><p><code>__slots__</code>的目的是限制当前类所能拥有的属性，如果不需要添加任意动态的属性，使用<strong>slots</strong>也能节省内存。</p><h4 id="在继承中使用slot"><a href="#在继承中使用slot" class="headerlink" title="在继承中使用slot"></a>在继承中使用<strong>slot</strong></h4><p>假设Person类通过<strong>slots</strong>定义了name和gender，请在派生类Student中通过<strong>slots</strong>继续添加score的定义，使Student类可以实现name、gender和score 3个属性。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="title">object</span>):</span></span><br><span class="line"></span><br><span class="line">    __slots_<span class="number">_</span> = (<span class="string">'name'</span>, <span class="string">'gender'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, gender)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.gender = gender</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">Person</span>):</span></span><br><span class="line"></span><br><span class="line">    __slots_<span class="number">_</span> = (<span class="string">'score'</span>,)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, gender, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">super</span>(Student, <span class="keyword">self</span>).__init_<span class="number">_</span>(name, gender)</span><br><span class="line">        <span class="keyword">self</span>.score = score</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">'Bob'</span>, <span class="string">'male'</span>, <span class="number">59</span>)</span><br><span class="line">s.name = <span class="string">'Tim'</span></span><br><span class="line">s.score = <span class="number">99</span></span><br><span class="line">print(s.score)</span><br></pre></td></tr></table></figure></p><h3 id="call"><a href="#call" class="headerlink" title="call"></a><strong>call</strong></h3><p>在Python中，函数其实是一个对象：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; f = abs</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; f.__name_<span class="number">_</span></span><br><span class="line"><span class="string">'abs'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; f(-<span class="number">123</span>)</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></p><p>由于 f 可以被调用，所以，f 被称为可调用对象。</p><p>所有的函数都是可调用对象。</p><p>一个类实例也可以变成一个可调用对象，只需要实现一个特殊方法<strong>call</strong>()。</p><p>我们把 Person 类变成一个可调用对象：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, gender)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(<span class="keyword">self</span>, friend)</span></span><span class="symbol">:</span></span><br><span class="line">        print(<span class="string">'My name is %s...'</span> % <span class="keyword">self</span>.name)</span><br><span class="line">        print(<span class="string">'My friend is %s...'</span> % friend)</span><br></pre></td></tr></table></figure></p><p>现在可以对 Person 实例直接调用：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; p = Person(<span class="string">'Bob'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; p(<span class="string">'Tim'</span>)</span><br><span class="line">My name is Bob...</span><br><span class="line">My friend is Tim...</span><br></pre></td></tr></table></figure></p><p>单看 p(‘Tim’) 你无法确定 p 是一个函数还是一个类实例，所以，在Python中，函数也是对象，对象和函数的区别并不显著。</p><p><strong>例程（打印斐波那契数列）：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,num)</span>:</span></span><br><span class="line">        L = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">        i = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; num:</span><br><span class="line">            L.append(L[i<span class="number">-2</span>]+L[i<span class="number">-1</span>])</span><br><span class="line">            i=i+<span class="number">1</span>     </span><br><span class="line">        <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line">f = Fib()</span><br><span class="line"><span class="keyword">print</span> f(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="get-set-及-property-装饰器"><a href="#get-set-及-property-装饰器" class="headerlink" title="get()/set() 及 @property 装饰器"></a>get()/set() 及 @property 装饰器</h2><p>考察 Student 类：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.score = score</span><br></pre></td></tr></table></figure></p><p>当我们想要修改一个 Student 的 scroe 属性时，可以这么写：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Student(<span class="string">'Bob'</span>, <span class="number">59</span>)</span><br><span class="line">s<span class="selector-class">.score</span> = <span class="number">60</span></span><br></pre></td></tr></table></figure></p><p>但是也可以这么写：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s<span class="selector-class">.score</span> = <span class="number">1000</span></span><br></pre></td></tr></table></figure></p><p>显然，直接给属性赋值无法检查分数的有效性。</p><p>如果利用两个方法：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.__score = score</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.__score</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(<span class="keyword">self</span>, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> score &lt; <span class="number">0</span> <span class="keyword">or</span> score &gt; <span class="number">100</span><span class="symbol">:</span></span><br><span class="line">            raise ValueError(<span class="string">'invalid score'</span>)</span><br><span class="line">        <span class="keyword">self</span>.__score = score</span><br></pre></td></tr></table></figure></p><p>这样一来，s.set_score(1000) 就会报错。</p><p>这种使用 get/set 方法来封装对一个属性的访问在许多面向对象编程的语言中都很常见。</p><p>但是写 s.get_score() 和 s.set_score() 没有直接写 s.score 来得直接。</p><p>有没有两全其美的方法？—-有。</p><p>因为Python支持高阶函数，在函数式编程中我们介绍了装饰器函数，可以用装饰器函数把 get/set 方法“装饰”成属性调用：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.__score = score</span><br><span class="line">    @property</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.__score</span><br><span class="line">    @score.setter</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(<span class="keyword">self</span>, score)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> score &lt; <span class="number">0</span> <span class="keyword">or</span> score &gt; <span class="number">100</span><span class="symbol">:</span></span><br><span class="line">            raise ValueError(<span class="string">'invalid score'</span>)</span><br><span class="line">        <span class="keyword">self</span>.__score = score</span><br></pre></td></tr></table></figure></p><blockquote><p>注意: 第一个score(self)是get方法，用@property装饰，第二个score(self, score)是set方法，用@score.setter装饰，@score.setter是前一个@property装饰后的副产品。</p></blockquote><p>现在，就可以像使用属性一样设置score了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; s = Student(<span class="string">'Bob'</span>, 59)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; s.score = 60</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span> s.score</span></span><br><span class="line">60</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; s.score = 1000</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: invalid score</span><br></pre></td></tr></table></figure></p><p>说明对 score 赋值实际调用的是 set方法。</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="关于Python版本和函数使用"><a href="#关于Python版本和函数使用" class="headerlink" title="关于Python版本和函数使用"></a>关于Python版本和函数使用</h2><p><strong>map、filter 和 reduce</strong><br>这三个函数号称是函数式编程的代表。在 Python3.x 和 Python2.x 中也有了很大的差异。</p><p>首先我们先简单的在 Python2.x 的交互下输入 map 和 filter,看到它们两者的类型是 <code>built-in function</code> (内置函数):</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; map</span><br><span class="line">&lt;built-in function map&gt;</span><br><span class="line">&gt;&gt;&gt; filter</span><br><span class="line">&lt;built-in function filter&gt;</span><br></pre></td></tr></table></figure><p>它们输出的结果类型都是列表:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">map</span>(lambda <span class="attribute">x</span>:x *<span class="number">2</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="selector-attr">[2, 4, 6]</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">filter</span>(lambda <span class="attribute">x</span>:x %<span class="number">2</span> ==<span class="number">0</span>,range(<span class="number">10</span>))</span><br><span class="line"><span class="selector-attr">[0, 2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>但是在Python 3.x中它们却不是这个样子了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; map</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">map</span>'&gt;</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; map(print,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">&lt;map object at <span class="number">0x10d8bd400</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; filter</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">filter</span>'&gt;</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; filter(lambda <span class="symbol">x:</span>x % <span class="number">2</span> == <span class="number">0</span>, range(<span class="number">10</span>))</span><br><span class="line">&lt;filter object at <span class="number">0x10d8bd3c8</span>&gt;</span><br></pre></td></tr></table></figure><p>首先它们从函数变成了类，其次，它们的返回结果也从当初的列表成了一个可迭代的对象, 我们尝试用 next 函数来进行手工迭代:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f =filter(<span class="name">lambda</span> x<span class="symbol">:x</span> %<span class="number">2</span> ==0, range(<span class="number">10</span>))</span><br><span class="line">&gt;&gt;&gt; next(<span class="name">f</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt;&gt;&gt; next(<span class="name">f</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt; next(<span class="name">f</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt; next(<span class="name">f</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>对于比较高端的 reduce 函数，它在 Python 3.x 中已经不属于 built-in 了，被挪到 functools 模块当中。</p><blockquote><p>另外，关于更多 Python 2.x 和 Python 3.x 中的不同，可以参看 <a href="/2018/03/28/python-translation/#"><code>这里</code></a>，希望有时间我可以仔细翻译一下。</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python进阶函数和功能_#1（函数式编程）</title>
      <link href="/2018/03/19/python-adv/"/>
      <content type="html"><![CDATA[<p>最开始接触 Python 是因为女票选了 Python 的课，为了秀一下“男友力”，我花了2个钟头读完 Python 3.6 的文档，做了她一学期的私人答疑。嗯，一点点秀。</p><p>在使用Python的过程中，其 <strong>解释性的语言</strong>，<strong>众多彩蛋语法糖</strong>，<strong>优雅的数据结构</strong>，<strong>优秀的包管理工具</strong>，<strong>大量的例程和学习资料</strong>，让我一直把 Python 作为我的 <strong>首要编程语言</strong>。</p><p>本文是我在研究 Python 语言本身 <strong>高级特性</strong> 时所做的笔记，会慢慢更新。<br>如果你恰好也和我一样喜欢 Python。希望本文能对你的学习有所帮助！</p><div id="content"></div><blockquote><p><strong>下面是快捷方式</strong>（点击直达）<br><a href="/2018/03/19/python-adv/#map"><code>map()</code></a>、<a href="/2018/03/19/python-adv/#reduce"><code>reduce()</code></a>、<a href="/2018/03/19/python-adv/#filter"><code>filter()</code></a>、<a href="/2018/03/19/python-adv/#sorted"><code>sorted()</code></a>、<a href="/2018/03/19/python-adv/#Python中返回函数"><code>返回函数</code></a>、<a href="/2018/03/19/python-adv/#闭包"><code>闭包</code></a>、<a href="/2018/03/19/python-adv/#匿名函数"><code>匿名函数</code></a>、<a href="/2018/03/19/python-adv/#装饰器"><code>装饰器</code></a>、<a href="/2018/03/19/python-adv/#偏函数"><code>偏函数</code></a></p></blockquote><a id="more"></a><h2 id="map"><a href="#map" class="headerlink" title="map()"></a><strong>map()</strong></h2><p>map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。</p><p>例如，对于list [1, 2, 3, 4, 5, 6, 7, 8, 9]</p><p>如果希望把list的每个元素都作平方，就可以用map()函数：</p><p><img src="http://img.mukewang.com/54c8a7e40001327303410245.png" alt="file-list"></p><p>因此，我们只需要传入函数f(x)=x*x，就可以利用map()函数完成这个计算：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line">print(map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure></p><p><strong>输出结果：</strong>[1, 4, 9, 10, 25, 36, 49, 64, 81]</p><p><code>注意：map()函数不改变原有的 list，而是返回一个新的 list。</code></p><p>利用map()函数，可以把一个 list 转换为另一个 list，只需要传入转换函数。</p><p>由于list包含的元素可以是任何类型，因此，map() 不仅仅可以处理只包含数值的 list，事实上它可以处理包含任意类型的 list，只要传入的函数f可以处理这种数据类型。</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a><strong>reduce()</strong></h2><p>reduce()函数也是Python内置的一个高阶函数。reduce()函数接收的参数和 map()类似，<code>一个函数 f</code>，<code>一个list</code>，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。</p><p>例如，编写一个f函数，接收x和y，返回x和y的和：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p><p>调用 reduce(f, [1, 3, 5, 7, 9])时，reduce函数将做如下计算：</p><blockquote><ol><li>先计算头两个元素：f(1, 3)，结果为4； </li><li>再把结果和第3个元素计算：f(4, 5)，结果为9； </li><li>再把结果和第4个元素计算：f(9,7)，结果为16； </li><li>再把结果和第5个元素计算：f(16, 9)，结果为25；</li><li>由于没有更多的元素了，计算结束，返回结果25。</li></ol></blockquote><p>上述计算实际上是对 list的所有元素求和。虽然Python内置了求和函数sum()，但是，利用reduce()求和也很简单。</p><p>reduce()还可以接收第3个可选参数，作为计算的初始值。如果把初始值设为100，计算：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], <span class="number">100</span>)</span><br></pre></td></tr></table></figure></p><p>结果将变为<code>125</code>，因为第一轮计算是：</p><p>计算初始值和第一个元素：<code>f(100, 1)</code>，结果为<code>101</code>。</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a><strong>filter()</strong></h2><p>filter()函数是 Python 内置的另一个有用的高阶函数，filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，<strong>filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。</strong></p><p>例如，要从一个list [1, 4, 6, 7, 9, 12, 17]中删除偶数，保留奇数，首先，要编写一个判断奇数的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>然后，利用filter()过滤掉偶数：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(is_odd, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">17</span>])</span><br></pre></td></tr></table></figure></p><p><strong>结果:</strong> [1, 7, 9, 17]</p><p>利用filter()，可以完成很多有用的功能，例如，删除 None 或者空字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_not_empty</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> len(s.strip()) &gt; <span class="number">0</span></span><br><span class="line">filter(is_not_empty, [<span class="string">'test'</span>, <span class="keyword">None</span>, <span class="string">''</span>, <span class="string">'str'</span>, <span class="string">'  '</span>, <span class="string">'END'</span>])</span><br></pre></td></tr></table></figure></p><p><strong>结果：</strong>[‘test’, ‘str’, ‘END’]</p><p><code>注意: s.strip(rm) 删除 s 字符串中开头、结尾处的 rm 序列的字符。</code></p><p>当rm为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)，如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> = <span class="string">'     123'</span></span><br><span class="line"><span class="selector-tag">a</span>.strip()</span><br></pre></td></tr></table></figure></p><p><strong>结果：</strong> ‘123’<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a='<span class="symbol">\t</span><span class="symbol">\t</span>123<span class="symbol">\r</span><span class="symbol">\n</span>'</span><br><span class="line">a.strip()</span><br></pre></td></tr></table></figure></p><p><strong>结果：</strong>‘123’</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a><strong>sorted()</strong></h2><p>Python内置的 sorted()函数可对list进行排序：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">21</span>])</span><br><span class="line"></span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">21</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure></p><p>但 sorted()也是一个高阶函数，它可以接收一个比较函数来实现自定义排序，比较函数的定义是，传入两个待比较的元素 x, y，<strong>如果 x 应该排在 y 的前面，返回 -1，如果 x 应该排在 y 的后面，返回 1。如果 x 和 y 相等，返回 0。</strong></p><p>因此，如果我们要实现倒序排序，只需要编写一个reversed_cmp函数：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversed_cmp</span><span class="params">(x, y)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="symbol">y:</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="symbol">y:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>这样，调用 sorted() 并传入 reversed_cmp 就可以实现倒序排序：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">21</span>], reversed_cmp)</span><br><span class="line">[<span class="number">36</span>, <span class="number">21</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><p>sorted()也可以对字符串进行排序，字符串默认按照ASCII大小来比较：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>])</span><br><span class="line">[<span class="string">'Credit'</span>, <span class="string">'Zoo'</span>, <span class="string">'about'</span>, <span class="string">'bob'</span>]</span><br></pre></td></tr></table></figure></p><p>‘Zoo’排在’about’之前是因为’Z’的ASCII码比’a’小。</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>sort()是<code>list内置</code>的方法，也可以和python内置的全局sorted()方法一样来对可迭代的序列排序生成新的序列。</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="key参数-函数"><a href="#key参数-函数" class="headerlink" title="key参数/函数"></a>key参数/函数</h3><p>从python2.4开始，list.sort()和sorted()函数增加了key参数来指定一个函数，此函数将在每个元素比较前被调用。 例如通过key指定的函数来忽略字符串的大小写：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted(<span class="string">"This is a test string from Andrew"</span>.<span class="built_in">split</span>(), <span class="built_in">key</span>=<span class="built_in">str</span>.lower)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'Andrew'</span>, <span class="string">'from'</span>, <span class="string">'is'</span>, <span class="string">'string'</span>, <span class="string">'test'</span>, <span class="string">'This'</span>]</span><br></pre></td></tr></table></figure></p><p>key参数的值为一个函数，此函数只有一个参数且返回一个值用来进行比较。这个技术是快速的因为key指定的函数将准确地对每个元素调用。</p><p>更广泛的使用情况是用复杂对象的某些值来对复杂对象的序列排序，例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; student_tuples = [</span><br><span class="line">        (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>),</span><br><span class="line">        (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>),</span><br><span class="line">        (<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>),</span><br><span class="line">]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(student_tuples, key=lambda <span class="symbol">student:</span> student[<span class="number">2</span>])   <span class="comment"># sort by age</span></span><br><span class="line">[(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</span><br></pre></td></tr></table></figure><p>对对象的属性进行索引：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, grade, age)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.name = name</span><br><span class="line">            <span class="keyword">self</span>.grade = grade</span><br><span class="line">            <span class="keyword">self</span>.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> repr((<span class="keyword">self</span>.name, <span class="keyword">self</span>.grade, <span class="keyword">self</span>.age))</span><br><span class="line"></span><br><span class="line">student_objects = [</span><br><span class="line">    Student(<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>),</span><br><span class="line">    Student(<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>),</span><br><span class="line">    Student(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sorted(student_objects, key=lambda <span class="symbol">student:</span> student.age)   <span class="comment"># sort by age</span></span><br></pre></td></tr></table></figure></p><pre><code>结果：[(&apos;dave&apos;, &apos;B&apos;, 10), (&apos;jane&apos;, &apos;B&apos;, 12), (&apos;john&apos;, &apos;A&apos;, 15)]</code></pre><p>key函数不仅可以访问需要排序元素的内部数据，还可以访问外部的资源，例如，如果学生的成绩是存储在dictionary中的，则 <strong>可以使用此dictionary来对学生名字的list排序</strong> ，如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; students = [<span class="string">'dave'</span>, <span class="string">'john'</span>, <span class="string">'jane'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; newgrades = &#123;<span class="string">'john'</span>: <span class="string">'F'</span>, <span class="string">'jane'</span><span class="symbol">:<span class="string">'A'</span></span>, <span class="string">'dave'</span>: <span class="string">'C'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(students, key=newgrades.__getitem_<span class="number">_</span>)</span><br><span class="line">[<span class="string">'jane'</span>, <span class="string">'dave'</span>, <span class="string">'john'</span>]</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="Operator-模块函数"><a href="#Operator-模块函数" class="headerlink" title="Operator 模块函数"></a>Operator 模块函数</h3><p>上面的key参数的使用非常广泛，因此python提供了一些方便的函数来使得访问方法更加容易和快速。<code>operator模块</code>有<code>itemgetter</code>，<code>attrgetter</code>，从2.6开始还增加了<code>methodcaller方法</code>。使用这些方法，上面的操作将变得更加简洁和快速：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; from operator import itemgetter, attrgetter</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(student_tuples, key=itemgetter(<span class="number">2</span>))</span><br><span class="line">[(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(student_objects, key=attrgetter(<span class="string">'age'</span>))</span><br><span class="line">[(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</span><br></pre></td></tr></table></figure><p>operator模块还允许 <strong>多级</strong> 的排序，例如，先以grade，然后再以age来排序：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(student_tuples, key=itemgetter(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">[(<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>), (<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(student_objects, key=attrgetter(<span class="string">'grade'</span>, <span class="string">'age'</span>))</span><br><span class="line">[(<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>), (<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="升序和降序"><a href="#升序和降序" class="headerlink" title="升序和降序"></a>升序和降序</h3><p>list.sort()和sorted()都接受一个<code>参数reverse</code>（True or False）来表示升序或降序排序。例如对上面的student降序排序如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(<span class="number">2</span>), <span class="keyword">reverse</span>=<span class="literal">True</span>)</span><br><span class="line">[(<span class="symbol">'john</span>', <span class="string">'A'</span>, <span class="number">15</span>), (<span class="symbol">'jane</span>', <span class="string">'B'</span>, <span class="number">12</span>), (<span class="symbol">'dave</span>', <span class="string">'B'</span>, <span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; sorted(student_objects, key=attrgetter(<span class="symbol">'age</span>'), <span class="keyword">reverse</span>=<span class="literal">True</span>)</span><br><span class="line">[(<span class="symbol">'john</span>', <span class="string">'A'</span>, <span class="number">15</span>), (<span class="symbol">'jane</span>', <span class="string">'B'</span>, <span class="number">12</span>), (<span class="symbol">'dave</span>', <span class="string">'B'</span>, <span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="排序的稳定性和复杂排序"><a href="#排序的稳定性和复杂排序" class="headerlink" title="排序的稳定性和复杂排序"></a>排序的稳定性和复杂排序</h3><p>从python2.2开始，排序被保证为稳定的。意思是说多个元素如果有相同的key，则排序前后他们的先后顺序不变。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; data = [(<span class="string">'red'</span>, <span class="number">1</span>), (<span class="string">'blue'</span>, <span class="number">1</span>), (<span class="string">'red'</span>, <span class="number">2</span>), (<span class="string">'blue'</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(data, key=itemgetter(<span class="number">0</span>))</span><br><span class="line">[(<span class="string">'blue'</span>, <span class="number">1</span>), (<span class="string">'blue'</span>, <span class="number">2</span>), (<span class="string">'red'</span>, <span class="number">1</span>), (<span class="string">'red'</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure></p><p>注意在排序后’blue’的顺序被保持了，即（’blue’, 1）在（’blue’, 2）的前面。<br>更复杂地你可以构建<code>多个步骤</code>来进行更复杂的排序，例如对student数据先以grade降序排列，然后再以age升序排列。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = sorted(student_objects, <span class="built_in">key</span>=attrgetter(<span class="string">'age'</span>))     # <span class="built_in">sort</span> on secondary <span class="built_in">key</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; sorted(s, <span class="built_in">key</span>=attrgetter(<span class="string">'grade'</span>), <span class="built_in">reverse</span>=True)       # now <span class="built_in">sort</span> on primary <span class="built_in">key</span>, descending</span><br><span class="line">[(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="最老土的排序方法-DSU"><a href="#最老土的排序方法-DSU" class="headerlink" title="最老土的排序方法-DSU"></a>最老土的排序方法-DSU</h3><p>我们称其为DSU（Decorate-Sort-Undecorate）,原因为排序的过程需要下列三步：</p><ol><li>对原始的list进行装饰，使得新list的值可以用来控制排序；</li><li>对装饰后的list排序；</li><li>将装饰删除，将排序后的装饰list重新构建为原来类型的list；</li></ol><p>例如，使用DSU方法来对student数据根据grade排序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>decorated = [(student.grade, i, student) <span class="keyword">for</span> i, student <span class="keyword">in</span> enumerate(student_objects)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>decorated.sort()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[student <span class="keyword">for</span> grade, i, student <span class="keyword">in</span> decorated]               <span class="comment"># undecorate</span></span><br><span class="line">[(<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>)]</span><br></pre></td></tr></table></figure></p><p>上面的比较能够工作，原因是 <code>__tuples是可以用来比较的__</code></p><blockquote><p>tuples间的比较首先比较tuples的第一个元素，如果第一个相同再比较第二个元素，以此类推。</p></blockquote><p>并不是所有的情况下都需要在以上的tuples中包含索引，但是包含索引可以有以下好处：</p><ul><li>排序是<code>稳定的</code>，如果两个元素有相同的key，则他们的原始先后顺序保持不变；</li><li>原始的元素不必用来做比较，因为tuples的第一和第二元素用来比较已经是足够了。</li></ul><p>此方法被RandalL.在perl中广泛推广后，他的另一个名字为也被称为Schwartzian transform。</p><p>对大的list或list的元素计算起来太过复杂的情况下，在python2.4前，DSU很可能是最快的排序方法。但是在2.4之后，上面解释的key函数提供了类似的功能。</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="其他语言普遍使用的排序方法-cmp函数"><a href="#其他语言普遍使用的排序方法-cmp函数" class="headerlink" title="其他语言普遍使用的排序方法-cmp函数"></a>其他语言普遍使用的排序方法-cmp函数</h3><p>在python2.4前，sorted()和list.sort()函数没有提供key参数，但是提供了cmp参数来让用户指定比较函数。此方法在其他语言中也普遍存在。</p><p>在python3.0中，cmp参数被彻底的移除了，从而简化和统一语言，减少了高级比较和<strong>cmp</strong>方法的冲突。</p><p>在python2.x中cmp参数指定的函数用来进行元素间的比较。此函数需要2个参数，然后返回负数表示小于，0表示等于，正数表示大于。例如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">numeric_compare</span><span class="params">(x, y)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> x - y</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted([<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>], cmp=numeric_compare)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><p>或者你可以反序排序：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">reverse_numeric</span><span class="params">(x, y)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> y - x</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted([<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>], cmp=reverse_numeric)</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><blockquote><p>当我们将现有的2.x的代码移植到3.x时， <strong>需要将cmp函数转化为key函数</strong><br>以下的wrapper很有帮助：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmp_to_key</span><span class="params">(mycmp)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="string">'Convert a cmp= function into a key= function'</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">K</span>(<span class="title">object</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, obj, *args)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.obj = obj</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(<span class="keyword">self</span>, other)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(<span class="keyword">self</span>.obj, other.obj) &lt; <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(<span class="keyword">self</span>, other)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(<span class="keyword">self</span>.obj, other.obj) &gt; <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(<span class="keyword">self</span>, other)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(<span class="keyword">self</span>.obj, other.obj) == <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__le__</span><span class="params">(<span class="keyword">self</span>, other)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(<span class="keyword">self</span>.obj, other.obj) &lt;= <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__ge__</span><span class="params">(<span class="keyword">self</span>, other)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(<span class="keyword">self</span>.obj, other.obj) &gt;= <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__ne__</span><span class="params">(<span class="keyword">self</span>, other)</span></span><span class="symbol">:</span></span><br><span class="line">            <span class="keyword">return</span> mycmp(<span class="keyword">self</span>.obj, other.obj) != <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> K</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>当需要将cmp转化为key时，只需要：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>], <span class="type">key</span>=cmp_to_key(reverse_numeric))</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p></blockquote><p>从python2.7，cmp_to_key()函数被增加到了functools模块中。</p><p>其实排序在内部是调用元素的<strong>cmp</strong>来进行的，所以我们可以为元素类型增加<strong>cmp</strong>方法使得元素可比较，例如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; Student.__lt_<span class="number">_</span> = lambda self, <span class="symbol">other:</span> self.age &lt; other.age</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sorted(student_objects)</span><br><span class="line">[(<span class="string">'dave'</span>, <span class="string">'B'</span>, <span class="number">10</span>), (<span class="string">'jane'</span>, <span class="string">'B'</span>, <span class="number">12</span>), (<span class="string">'john'</span>, <span class="string">'A'</span>, <span class="number">15</span>)]</span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a><strong>返回函数</strong></h2><p>Python的函数不但可以返回int、str、list、dict等数据类型，还可以返回函数！</p><p>例如，定义一个函数 f()，我们让它返回一个函数 g，可以这样写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'call f()...'</span>)</span><br><span class="line">    <span class="comment"># 定义函数g:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'call g()...'</span>)</span><br><span class="line">    <span class="comment"># 返回函数g:</span></span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure></p><p>仔细观察上面的函数定义，我们在函数 f 内部又定义了一个函数 g。由于函数 g 也是一个对象，函数名 g 就是指向函数 g 的变量，所以，最外层函数 f 可以返回变量 g，也就是函数 g 本身。</p><p>调用函数 f，我们会得到 f 返回的一个函数：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; x = f()   <span class="comment"># 调用f()</span></span><br><span class="line">call f()...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x   <span class="comment"># 变量x是f()返回的函数：</span></span><br><span class="line">&lt;function g at <span class="number">0x1037bf320</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; x()   <span class="comment"># x指向函数，因此可以调用</span></span><br><span class="line">call g()...   <span class="comment"># 调用x()就是执行g()函数定义的代码</span></span><br></pre></td></tr></table></figure></p><p>请注意区分返回函数和返回值：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myabs</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> abs   <span class="comment"># 返回函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myabs2</span><span class="params">(x)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> abs(x)   <span class="comment"># 返回函数调用的结果，返回值是一个数值</span></span><br></pre></td></tr></table></figure></p><p>返回函数可以把一些计算延迟执行。例如，如果定义一个普通的求和函数：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span><span class="params">(lst)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> sum(lst)</span><br></pre></td></tr></table></figure></p><p>调用calc_sum()函数时，将立刻计算并得到结果：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>但是，如果返回一个函数，就可以“延迟计算”：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span><span class="params">(lst)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> sum(lst)</span><br><span class="line">    <span class="keyword">return</span> lazy_sum</span><br><span class="line"><span class="comment"># 调用calc_sum()并没有计算出结果，而是返回函数:</span></span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; f = calc_sum([1, 2, 3, 4])</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; f</span></span><br><span class="line">&lt;function lazy_sum at 0x1037bfaa0&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 对返回的函数进行调用时，才计算出结果:</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; f()</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>由于可以返回函数，我们在后续代码里就可以决定到底要不要调用该函数。</p><p>编写一个函数calc_prod(lst)，它接收一个list，返回一个函数，返回函数可以计算参数的乘积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_prod</span><span class="params">(lst)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方法一：</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prod</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x * y, lst)</span><br><span class="line">    <span class="keyword">return</span> prod</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方法二：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> :reduce(<span class="keyword">lambda</span> x, y: x * y, lst)</span><br><span class="line"></span><br><span class="line">f = calc_prod([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(f())</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><strong>闭包</strong></h2><p>在函数内部定义的函数和外部定义的函数是一样的，只是他们无法被外部访问：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'g()...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f()...'</span>)</span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure></p><p>将 g 的定义移入函数 f 内部，防止其他代码调用 g：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f()...'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'g()...'</span>)</span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure></p><p>但是，考察上一小节定义的 calc_sum 函数：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span><span class="params">(lst)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> sum(lst)</span><br><span class="line">    <span class="keyword">return</span> lazy_sum</span><br></pre></td></tr></table></figure></p><p><code>注意: 发现没法把 lazy_sum 移到 calc_sum 的外部，因为它引用了 calc_sum 的参数 lst。</code></p><p>像这种内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为闭包（Closure）。</p><p>闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。举例如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 希望一次返回3个函数，分别计算1x1,2x2,3x3:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>)<span class="symbol">:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">             <span class="keyword">return</span> i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br></pre></td></tr></table></figure></p><p>你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果全部都是 9（请自己动手验证）。</p><p>原因就是当count()函数返回了3个函数时，这3个函数所引用的<code>变量 i</code> 的值已经变成了3。由于f1、f2、f3并没有被调用，所以，此时他们并未计算 i*i，当 f1 被调用时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f1()</span><br><span class="line">9     # 因为f1现在才计算i*i，但现在i的值已经变为3</span><br></pre></td></tr></table></figure></p><p>因此，返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p><blockquote><p><strong>返回闭包不能引用循环变量，请改写count()函数，让它正确返回能计算1x1、2x2、3x3的函数。</strong></p></blockquote><blockquote><p>考察下面的函数 f:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> j*j</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>它可以正确地返回一个闭包g，g所引用的变量j不是循环变量，因此将正常执行。<br>在count函数的循环内部，如果借助f函数，就可以避免引用循环变量i。</p><blockquote><p><strong>参考代码:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    ---</span><br><span class="line">        <span class="comment"># 写法一：</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">                <span class="keyword">return</span> j*j</span><br><span class="line">            <span class="keyword">return</span> g</span><br><span class="line">        r = f(i)</span><br><span class="line">        fs.append(r)</span><br><span class="line">    ---</span><br><span class="line">        <span class="comment"># 写法二：</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">lambda</span> : i*i</span><br><span class="line">        fs.append(f(i))</span><br><span class="line">    ---</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line">print(f1(), f2(), f3())</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><strong>匿名函数</strong></h2><p>高阶函数可以接收函数做参数，有些时候，我们不需要显式地定义函数，直接传入匿名函数更方便。</p><p>在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算 f(x)=x2 时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">map</span>(lambda <span class="attribute">x</span>: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="selector-attr">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure><p>通过对比可以看出，匿名函数 <code>lambda x: x * x</code> 实际上就是：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br></pre></td></tr></table></figure></p><p>关键字<code>lambda</code>表示匿名函数，冒号前面的 x 表示<code>函数参数</code>。</p><blockquote><p>匿名函数有个限制，就是只能有一个表达式，不写return，返回值就是该表达式的结果。</p></blockquote><p>使用匿名函数，可以<code>不必定义函数名</code>，直接创建一个函数对象，很多时候可以简化代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">sorted</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">0</span>], lambda x,<span class="attribute">y</span>: -cmp(x,y))</span><br><span class="line"><span class="selector-attr">[9, 5, 3, 1, 0]</span></span><br></pre></td></tr></table></figure><p>返回函数的时候，也可以返回匿名函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; myabs = lambda x: -x <span class="keyword">if</span> x &lt; 0 <span class="keyword">else</span> x </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; myabs(-1)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; myabs(1)</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>不改变函数本身，但是改变函数功能。</p><p>使用高阶函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_f1</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(<span class="string">'call'</span> + f.__name__ + <span class="string">'()'</span>)</span><br><span class="line">        <span class="keyword">return</span> f(x)</span><br><span class="line">    <span class="keyword">return</span> fn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始调用</span></span><br><span class="line">g1 = new_f1(f1)</span><br><span class="line">print(g1(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐藏原始函数的调用</span></span><br><span class="line">f1 = new_f1(f1)</span><br><span class="line">print(f1(<span class="number">5</span>))</span><br></pre></td></tr></table></figure></p><blockquote><p>使用 <code>decorator</code> 用Python提供的 <code>@</code> 语法，这样可以避免手动编写 <code>f = decorate(f)</code> 这样的代码。</p></blockquote><p>装饰器的作用：</p><ul><li>打印日志：@log</li><li>检测性能：@performance</li><li>数据库失误：@transaction</li><li>URL路由：@post(‘/register’)</li></ul><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="无参数decorator"><a href="#无参数decorator" class="headerlink" title="无参数decorator"></a>无参数decorator</h3><p>考察一个@log的定义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(<span class="string">'call '</span> + f.__name__ + <span class="string">'()...'</span>)</span><br><span class="line">        <span class="keyword">return</span> f(x)</span><br><span class="line">    <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure></p><p>对于阶乘函数，@log工作得很好：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line">print(factorial(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">call</span></span> factorial()...</span><br><span class="line"><span class="number">3628800</span></span><br></pre></td></tr></table></figure></p><p>但是，对于参数不是一个的函数，调用将报错：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">"test.py"</span>, <span class="built_in">line</span> <span class="number">15</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    <span class="keyword">print</span>(<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">TypeError: fn() takes exactly <span class="number">1</span> <span class="keyword">argument</span> (<span class="number">2</span> given)</span><br></pre></td></tr></table></figure></p><p>因为 add() 函数需要传入两个参数，但是 @log 写死了只含一个参数的返回函数。</p><p>要让 @log 自适应任何参数定义的函数，可以利用Python的 *args 和 **kw，保证任意个数的参数总是能正常调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call '</span> + f.__name__ + <span class="string">'()...'</span>)</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure></p><p>现在，对于任意函数，@log 都能正常工作。</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="带参数decorator"><a href="#带参数decorator" class="headerlink" title="带参数decorator"></a>带参数decorator</h3><p>考察上一节的 @log 装饰器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(<span class="string">'call '</span> + f.__name__ + <span class="string">'()...'</span>)</span><br><span class="line">        <span class="keyword">return</span> f(x)</span><br><span class="line">    <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure></p><p>发现对于被装饰的函数，log打印的语句是不能变的（除了函数名）。</p><p>如果有的函数非常重要，希望打印出’[INFO] call xxx()…’，有的函数不太重要，希望打印出’[DEBUG] call xxx()…’，这时，log函数本身就需要传入’INFO’或’DEBUG’这样的参数，类似这样：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@log(<span class="string">'DEBUG'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p><p>把上面的定义翻译成高阶函数的调用，就是：</p><p><code>my_func = log(&#39;DEBUG&#39;)(my_func)</code></p><p>上面的语句看上去还是比较绕，再展开一下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log_decorator</span> = log(<span class="string">'DEBUG'</span>)</span><br><span class="line"><span class="attr">my_func</span> = log_decorator(my_func)</span><br></pre></td></tr></table></figure><p>上面的语句又相当于：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_decorator = log(<span class="string">'DEBUG'</span>)</span><br><span class="line"><span class="meta">@log_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>所以，带参数的log函数首先返回一个decorator函数，再让这个decorator函数接收my_func并返回新函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(prefix)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log_decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            print(<span class="string">'[%s] %s()...'</span> % (prefix, f.__name__))</span><br><span class="line">            <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> log_decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@log('DEBUG')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">print(test())</span><br></pre></td></tr></table></figure><p>执行结果：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="builtin-name">DEBUG</span>] test()<span class="built_in">..</span>.</span><br><span class="line">None</span><br></pre></td></tr></table></figure></p><p>对于这种3层嵌套的decorator定义，你可以先把它拆开：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准decorator:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'[%s] %s()...'</span> % (prefix, f.__name__))</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="keyword">return</span> log_decorator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回decorator:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(prefix)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> log_decorator(f)</span><br></pre></td></tr></table></figure></p><p>拆开以后会发现，调用会失败，因为在3层嵌套的decorator定义中，最内层的wrapper引用了最外层的参数prefix，所以，把一个闭包拆成普通的函数调用会比较困难。不支持闭包的编程语言要实现同样的功能就需要更多的代码。</p><p><strong>例程：函数运行时间打印</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">performance</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">per_dec</span><span class="params">(f)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            start = time.time()</span><br><span class="line">            ans = f(*args, **kw)</span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'call '</span>+f.__name__+<span class="string">'() in '</span>+ str(end-start) + s)</span><br><span class="line">            <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> fn</span><br><span class="line">    <span class="keyword">return</span> per_dec</span><br><span class="line"></span><br><span class="line"><span class="meta">@performance('s')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> factorial(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="完善decorator"><a href="#完善decorator" class="headerlink" title="完善decorator"></a>完善decorator</h3><p>@decorator可以动态实现函数功能的增加，但是，经过@decorator“改造”后的函数，和原函数相比，除了功能多一点外，有没有其它不同的地方？</p><p>在没有decorator的情况下，打印函数名：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">print</span> f1.__name__</span><br></pre></td></tr></table></figure></p><pre><code>输出： f1</code></pre><p>有decorator的情况下，再打印函数名：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call...'</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">print</span> f2.__name__</span><br></pre></td></tr></table></figure></p><pre><code>输出： wrapper</code></pre><p>可见，由于decorator返回的新函数函数名已经不是’f2’，而是@log内部定义的’wrapper’。 <strong>这对于那些依赖函数名的代码就会失效。</strong> decorator还改变了函数的<code>__doc__</code>等其它属性。如果要让调用者看不出一个函数经过了@decorator的“改造”，就需要把原函数的一些属性复制到新函数中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call...'</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">    wrapper.__name__ = f.__name__</span><br><span class="line">    wrapper.__doc__ = f.__doc__</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></p><p>这样写decorator很不方便，因为我们也很难把原函数的所有必要属性都一个一个复制到新函数上，所以Python内置的<code>functools</code>可以用来自动化完成这个“复制”的任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call...'</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></p><p>最后需要指出，由于我们把原函数签名改成了(*args, **kw)，因此， <strong>无法获得原函数的原始参数信息</strong> 。即便我们采用固定参数来装饰只有一个参数的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call...'</span></span><br><span class="line">        <span class="keyword">return</span> f(x)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></p><p>也可能改变原函数的参数名，因为新函数的参数名始终是 ‘x’，原函数定义的参数名不一定叫 ‘x’。</p><p><strong>例程：函数运行时间打印</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动复制原函数的__doc__等其它属性(新增部分)</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">performance</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">per_dec</span><span class="params">(f)</span>:</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 自动复制原函数的__doc__等其它属性(新增部分)</span></span><br><span class="line"><span class="meta">        @functools.wraps(f)</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            start = time.time()</span><br><span class="line">            ans = f(*args, **kw)</span><br><span class="line">            end = time.time()</span><br><span class="line">            print(<span class="string">'call '</span>+f.__name__+<span class="string">'() in '</span>+ str(end-start) + s)</span><br><span class="line">            <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> fn</span><br><span class="line">    <span class="keyword">return</span> per_dec</span><br><span class="line"></span><br><span class="line"><span class="meta">@performance('s')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">print(factorial(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>当一个函数有很多参数时，调用者就需要提供多个参数。如果减少参数个数，就可以简化调用者的负担。</p><p>比如，int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; int(<span class="string">'12345'</span>)</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure></p><p>但int()函数还提供额外的<code>base参数</code>，默认值为10。如果传入base参数，就可以做 N 进制的转换：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; int(<span class="string">'12345'</span>, base=<span class="number">8</span>)</span><br><span class="line"><span class="number">5349</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; int(<span class="string">'12345'</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">74565</span></span><br></pre></td></tr></table></figure></p><p>假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到， <strong>可以定义一个int2()的函数，默认把base=2传进去</strong> ：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int2</span><span class="params">(x, base=<span class="number">2</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> int(x, base)</span><br></pre></td></tr></table></figure></p><p>这样，我们转换二进制就非常方便了：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; int2(<span class="string">'1000000'</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; int2(<span class="string">'1010101'</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure></p><p><code>functools.partial</code> 就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import functools</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; int2 = functools.partial(int, base=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; int2(<span class="string">'1000000'</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; int2(<span class="string">'1010101'</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure></p><blockquote><p>所以，functools.partial可以把一个参数多的函数变成一个参数少的新函数，少的参数需要在创建时指定默认值，这样，新函数调用的难度就降低了。</p></blockquote><p><strong>例程：用functools.partial简化自定义排序函数</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line">sorted_ignore_case = functools.partial(sorted, <span class="built_in">key</span> = <span class="built_in">str</span>.lower)</span><br><span class="line"><span class="built_in">print</span>(sorted_ignore_case([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>]))</span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World !</title>
      <link href="/2018/03/18/new/"/>
      <content type="html"><![CDATA[<p><code>本文置顶。</code></p><p>这是庄心昊的 <strong>个人博客</strong> ，旨在分享个人学习路径中的所获所得，避免后生走弯路。<br>本博客中 <strong>所有代码均经过本人调试</strong> ，关于 <strong>调试环境</strong> 若无特殊说明请参看 <a href="/about/#env"><code>代码环境</code></a> 。</p><p>点 <strong><a href="/archives/"><code>这里</code></a></strong> 查看我的文章列表</p><blockquote><p><strong>注意：</strong>本博客内的所有文章采用&ensp; <strong><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></strong> &ensp;进行许可，转载请勿用于商业目的，并请著名原作者（若不是本人我会特别注明）及原文链接。</p></blockquote><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Happy coding !</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
    </entry>
    
    <entry>
      <title>汇编指令简析</title>
      <link href="/2017/10/09/asm/"/>
      <content type="html"><![CDATA[<p>本文是上学期学习汇编语言时候的课堂笔记。</p><div id="content"></div><blockquote><p><strong>分类索引</strong>（单击命令直接索引）</p></blockquote><table><thead><tr><th style="text-align:center">分类</th><th>命令</th></tr></thead><tbody><tr><td style="text-align:center">符号数相关</td><td><a href="/2017/10/09/asm/#1"><code>JG</code></a>、<a href="/2017/10/09/asm/#1"><code>JL</code></a>、<a href="/2017/10/09/asm/#2"><code>IMUL</code></a></td></tr><tr><td style="text-align:center">通用数据传送指令</td><td><a href="/2017/10/09/asm/#3"><code>MOV</code></a>、<a href="/2017/10/09/asm/#4"><code>POP</code></a>、<a href="/2017/10/09/asm/#4"><code>PUSH</code></a>、<a href="/2017/10/09/asm/#5"><code>XCHG</code></a>、<a href="/2017/10/09/asm/#6"><code>IN</code></a>、<a href="/2017/10/09/asm/#6"><code>OUT</code></a></td></tr><tr><td style="text-align:center">地址传送指令</td><td><a href="/2017/10/09/asm/#LEA"><code>LEA</code></a>、<a href="/2017/10/09/asm/#LDS"><code>LDS</code></a>、<a href="/2017/10/09/asm/#LES"><code>LES</code></a>、<a href="/2017/10/09/asm/#PUS"><code>PUSHF</code></a>、<a href="/2017/10/09/asm/#PUS"><code>POPF</code></a></td></tr><tr><td style="text-align:center">转换指令</td><td><a href="/2017/10/09/asm/#CBW"><code>CBW</code></a>、<a href="/2017/10/09/asm/#CBW"><code>CWD</code></a>、<a href="/2017/10/09/asm/#XLAT"><code>XLAT</code></a></td></tr><tr><td style="text-align:center">加减乘除</td><td><a href="/2017/10/09/asm/#PLU"><code>ADD</code></a>、<a href="/2017/10/09/asm/#PLU"><code>INC</code></a>、<a href="/2017/10/09/asm/#PLU"><code>ADC</code></a>、<a href="/2017/10/09/asm/#MIN"><code>SUB</code></a>、<a href="/2017/10/09/asm/#MIN"><code>DEC</code></a>、<a href="/2017/10/09/asm/#MIN"><code>NEG</code></a>、<a href="/2017/10/09/asm/#TIM"><code>MUL</code></a>、<a href="/2017/10/09/asm/#DIV"><code>DIV</code></a></td></tr><tr><td style="text-align:center">逻辑运算</td><td><a href="/2017/10/09/asm/#A"><code>AND</code></a>、<a href="/2017/10/09/asm/#A"><code>OR</code></a>、<a href="/2017/10/09/asm/#A"><code>XOR</code></a>、<a href="/2017/10/09/asm/#A"><code>NOT</code></a>、<a href="/2017/10/09/asm/#A"><code>TEST</code></a></td></tr><tr><td style="text-align:center">移位指令</td><td><a href="/2017/10/09/asm/#B"><code>SHL</code></a>、<a href="/2017/10/09/asm/#B"><code>SHR</code></a>、<a href="/2017/10/09/asm/#B"><code>SAL</code></a>、<a href="/2017/10/09/asm/#B"><code>SAR</code></a>、<a href="/2017/10/09/asm/#C"><code>ROL</code></a>、<a href="/2017/10/09/asm/#C"><code>ROR</code></a>、<a href="/2017/10/09/asm/#C"><code>RCL</code></a>、<a href="/2017/10/09/asm/#C"><code>RCR</code></a></td></tr><tr><td style="text-align:center">字符串操作</td><td><a href="/2017/10/09/asm/#MOV"><code>MOV</code></a>、<a href="/2017/10/09/asm/#CMPSB"><code>CMPSB</code></a>、<a href="/2017/10/09/asm/#SCASB"><code>SCASB</code></a>、<a href="/2017/10/09/asm/#STOSB"><code>STOSB</code></a>、<a href="/2017/10/09/asm/#LODSB"><code>LODSB</code></a></td></tr><tr><td style="text-align:center">控制转移指令</td><td><a href="/2017/10/09/asm/#JMP"><code>JMP</code></a>、<a href="/2017/10/09/asm/#LOOP"><code>LOOP</code></a>、<a href="/2017/10/09/asm/#CAL"><code>CALL</code></a>、<a href="/2017/10/09/asm/#CAL"><code>RETN</code></a>、<a href="/2017/10/09/asm/#CAL"><code>RETF</code></a></td></tr></tbody></table><a id="more"></a><p><br></p><hr><p><br></p><h2 id="符号数相关"><a href="#符号数相关" class="headerlink" title="符号数相关"></a>符号数相关</h2><h3 id="1">jg/jl大小比较</h3> <p>jg 符号数大于<br>jl 符号数小于</p><blockquote><p>跳转依据：</p></blockquote><table><thead><tr><th style="text-align:center">符号</th><th>依据</th></tr></thead><tbody><tr><td style="text-align:center">a &lt; b</td><td>SF！=OF</td></tr><tr><td style="text-align:center">a==b</td><td>ZF=0</td></tr><tr><td style="text-align:center">a &gt; b</td><td>SF=OF且ZF=0</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ah=0FFh, bh=1</span><br><span class="line">cmp ah, bh</span><br><span class="line">jg ah_is_larger; </span><br><span class="line">//跳转不发生（0FF作为符号数为-1）</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="2">imul 符号数乘法</h3><ul><li><strong>imul eax<code>只寄存器</code>, ebx<code>寄存器或变量</code>, 1234h<code>只常数</code></strong><br>eax = ebx * 1234h</li><li><strong>imul eax, ebx</strong><br>eax自乘ebx</li></ul><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="通用数据传送指令"><a href="#通用数据传送指令" class="headerlink" title="通用数据传送指令"></a>通用数据传送指令</h2><h3 id="3">MOV 指令</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[√] <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">bx</span>], <span class="number">ah</span></span><br><span class="line">[×] <span class="keyword">mov</span>              <span class="built_in">ax</span> , <span class="number">bh</span> <span class="comment">;左右操作数宽度必须相等</span></span><br></pre></td></tr></table></figure><ul><li><code>DS</code> / <code>CS</code> / <code>IP</code> 不能被mov改变</li></ul><p><strong>mov 的变体</strong></p><ul><li><code>movzx</code> : move by zero extention</li><li><code>movsx</code> : move by sign extention</li><li><code>[rep] movsb</code>  ; 以字节为单位移动CX个字符</li></ul><blockquote><p>DS : SI 指向源字符串<br>ES : DI 指向目标字符串<br>若 DF=0 即正方向则SI++，DI++，否则反之。</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="4">POP / PUSH 指令</h3><ul><li>不能对8位值进行push/pop:</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[×] <span class="keyword">push</span> <span class="number">ah</span></span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="5"> XCHG 指令 </h3><p>（略）</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="6"> IN / OUT 指令 </h3><p>基本格式：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>, <span class="number">21h</span></span><br></pre></td></tr></table></figure></p><p>从21h号端口读取一个字节存放到AL中</p><blockquote><ul><li>端口地址&gt;=100h，必须存放到DX</li><li>端口地址的范围是：[0000h, 0FFFFh]，共65536个端口。</li></ul></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h2><h3 id="LEA"> LEA  <code>取变量的偏移地址</code></h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lea</span> <span class="built_in">eax</span>, [<span class="built_in">ebp</span>-<span class="number">64</span>]</span><br></pre></td></tr></table></figure><p>EAX = EBP-64</p><blockquote><ul><li>lea dx, ds:[1000h] ; DX=1000h</li><li>设BX=1000h, SI=2<br>lea ax, ds:[bx+si+3]; AX=bx+si+3=1005h</li></ul></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="LDS"> LDS <code>把远指针装到DS:DEST</code> </h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lds</span> dest, src</span><br></pre></td></tr></table></figure><p>把 <code>src</code> 指向的地址，高位存放在<code>DS</code>中，低位存放在<code>dest</code>中。</p><blockquote><p>16位时，<br>比如当前DS=1000H, BX=0100H.<br>当前内存:<br>1000:0100 01<br>1000:0101 02<br>1000:0102 03<br>1000:0103 04<br>而有一条指令:LDS BX,[BX]<br>[BX]指向1000:0100,执行后BX存低位的内容,也就是BX=0201H,<br>而DS则存高位的内容,也就是[BX+2]的内容,DS=0403H</p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="LES"> LES <code>把远指针装到ES:DEST</code> </h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">les</span> dest, src</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="PUS"> PUSHF，POPF <code>标志寄存器传送指令</code> </h3><p>（把FL压入/弹出ax）<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pushf</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ax</span> <span class="comment">; AX=FL</span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">ax</span>, <span class="number">1</span><span class="comment">; 第0位变1，其它位不变</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">popf</span>    <span class="comment">; FL=AX</span></span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="转换指令"><a href="#转换指令" class="headerlink" title="转换指令"></a>转换指令</h2><h3 id="CBW"> CBW，CWD <code>符号扩充指令</code> </h3><blockquote><p><strong>CBW:</strong> convert byte to word<br><strong>CWD:</strong> convert word to double word<br><strong>CDQ:</strong> convert double word to quadruple word(32位扩充为64位)</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">7Fh</span></span><br><span class="line"><span class="keyword">cbw</span>         <span class="comment">; AX=007F</span></span><br></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">0F9h</span></span><br><span class="line"><span class="keyword">cbw</span>         <span class="comment">; AX=0FFF9h</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 8000h</span><br><span class="line">cwd         ; <span class="attribute">DX</span>=0FFFFh, <span class="attribute">AX</span>=8000h</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, <span class="number">0</span>FFFFFFFFh</span><br><span class="line">cdq         ; EDX=<span class="number">0</span>FFFFFFFFh, EAX=<span class="number">0</span>FFFFFFFFh</span><br><span class="line">                  高<span class="number">32</span>位           低<span class="number">32</span>位</span><br></pre></td></tr></table></figure><ul><li><code>movzx</code> : move by zero extention</li><li><code>movsx</code> : move by sign extention</li></ul><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="XLAT"> XLAT <code>换码指令</code> </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 设 char t[]="0123456789ABCDEF";</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, offset t</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">10</span></span><br><span class="line"><span class="keyword">xlat</span><span class="comment">; 结果AL='A'</span></span><br><span class="line">     实际<span class="built_in">AL</span>=<span class="built_in">DS</span>:[<span class="built_in">BX</span>+<span class="built_in">AL</span>]</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h2><h3 id="PLU"> 加 </h3><table><thead><tr><th>指令</th><th>用法</th></tr></thead><tbody><tr><td>add</td><td></td></tr><tr><td>inc</td><td>不影响CF位</td></tr><tr><td>adc</td><td>带进位加法。当进行32位以上运算时，要求低位字节相加，而高位字节再相加时就要考虑低位相加的进位，即CF</td></tr></tbody></table><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="MIN"> 减 </h3><table><thead><tr><th>指令</th><th>用法</th></tr></thead><tbody><tr><td>sub</td><td></td></tr><tr><td>dec</td><td>自减</td></tr><tr><td>neg</td><td>求相反数</td></tr></tbody></table><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="TIM"> 乘 <code>非符号</code> </h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mul </span>src</span><br></pre></td></tr></table></figure><p>src <code>不能是立即数，寄存器和地址均可</code></p><table><thead><tr><th>src字节数</th><th>操作对象</th><th>结果存放</th></tr></thead><tbody><tr><td>8字节</td><td>al</td><td>ax</td></tr><tr><td>16字节</td><td>ax</td><td>dx : ax</td></tr><tr><td>32字节</td><td>eax</td><td>edx : eax</td></tr></tbody></table><p><code>即 AX = AL * src</code></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="DIV"> 除 <code>非符号</code> </h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> op</span><br></pre></td></tr></table></figure><table><thead><tr><th>op字节数</th><th>操作对象</th><th>结果存放</th></tr></thead><tbody><tr><td>8字节</td><td>ax</td><td>al（整除）；ah（余数）</td></tr><tr><td>16字节</td><td>dx : ax</td><td>ax（整除）；dx（余数）</td></tr><tr><td>32字节</td><td>edx : eax</td><td>eax（整除）；edx（余数）</td></tr></tbody></table><blockquote><p>语句比较</p><ul><li><code>test</code> / <code>and</code>（<code>cmp</code> / <code>sub</code>）<br>运算结果不影响操作数，<strong>只影响标志位</strong>。<br><strong>影响标志：</strong> C,O,P,Z,S(其中C与O两个标志会被设为0)</li><li><code>neg</code> / <code>not</code><br><code>neg</code> 求相反数，<code>not</code> 逐位求反</li><li><code>inc</code> / <code>add</code><br>是否影响flag</li><li><code>jc</code> 与 <code>jb</code> 指令完全等价。<br><code>jz</code> 与 <code>je</code> 指令完全等价。</li></ul></blockquote><h4 id="比较方法"><a href="#比较方法" class="headerlink" title="比较方法"></a>比较方法</h4><ol><li>非符号数：CF / ZF</li><li>符号数：SF / OF / ZF<blockquote><p>OF=1 即结果溢出（有错），否定SF得到的符号结果</p></blockquote></li></ol><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="逻辑运算和移位"><a href="#逻辑运算和移位" class="headerlink" title="逻辑运算和移位"></a>逻辑运算和移位</h2><p><br></p><h3 id="A"> 逻辑运算指令 </h3><p><code>AND</code>，<code>OR</code>，<code>XOR</code>，<code>NOT</code>，<code>TEST</code></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h3><p><code>SHL</code>，<code>SHR</code>，<code>SAL</code>，<code>SAR</code>，<br><code>ROL</code>，<code>ROR</code>，<code>RCL</code>，<code>RCR</code><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shl</span> <span class="number">ah</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h4 id="B"> <strong>单向</strong> </h4><table><thead><tr><th>符号</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td>SHL</td><td>逻辑左移</td><td>低位补0, 高位进CF</td></tr><tr><td>SHR</td><td>逻辑右移</td><td>低位进CF, 高位补0</td></tr><tr><td>SAL</td><td>算术左移</td><td>（同SHL）</td></tr><tr><td>SAR</td><td>算术右移</td><td>每位右移, 低位进CF, 高位不变</td></tr></tbody></table><p><code>它们的结果影响 OF、SF、ZF、PF、CF</code></p><h4 id="C"> <strong>循环</strong> </h4><table><thead><tr><th>符号</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td>ROL</td><td>循环左移</td><td>高位到低位并送CF</td></tr><tr><td>ROR</td><td>循环右移</td><td>低位到高位并送CF</td></tr><tr><td>RCL</td><td>带进位循环左移</td><td>进位值(原CF)到低位, 高位进CF</td></tr><tr><td>RCR</td><td>带进位循环右移</td><td>进位值(原CF)到高位, 低位进CF</td></tr></tbody></table><p><code>它们的结果影响 OF、CF</code></p><blockquote><p>8086中，当次数&gt;=2时，移位次数应先赋值给 <strong>cl</strong></p></blockquote><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="MOV"> MOVSB <code>字符串传送</code> </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">rep</span>] <span class="keyword">movsb</span></span><br></pre></td></tr></table></figure><p>以字节为单位，从 <strong>DS:SI</strong> 到 <strong>ES:DI</strong> 移动CX个字符</p><ul><li>DF控制方向。若DF=0即正方向则SI++，DI++。</li></ul><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="CMPSB"> CMPSB <code>字符串比较</code> </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">repe</span> | <span class="keyword">repne</span>] <span class="keyword">cmpsb</span></span><br></pre></td></tr></table></figure><p>若本次比较 <code>相等</code> / <code>不等</code> 则继续比较下一个</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="SCASB"> SCASB <code>字符串查找</code> </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">repe</span> | <span class="keyword">repne</span>] <span class="keyword">scasb</span></span><br></pre></td></tr></table></figure><p>设ES:DI → 以’\0’结束的字符串，要求该字符串长度<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">1000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>, <span class="number">1080h</span>   <span class="comment">; ES:DI → "ABC..."</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">0FFFFh</span>  <span class="comment">; ES:DI → "ABC",0,[]...</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">0</span>       <span class="comment">; AL=待查找的字符</span></span><br><span class="line"><span class="keyword">cld</span></span><br><span class="line"><span class="keyword">repne</span> <span class="keyword">scasb</span>     <span class="comment">; 循环结束时，DI=1088h, CX=FFFF-8</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">cx</span></span><br><span class="line"><span class="keyword">not</span> <span class="built_in">cx</span>          <span class="comment">; CX=FFFF-CX=字符串长度(不含0)</span></span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="STOSB"> STOSB <code>存入字符串</code> </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">repe</span>] <span class="keyword">stosb</span></span><br></pre></td></tr></table></figure><p>stosb把AL的值保存到ES:DI所指向的内存单元中</p><ul><li>当DF==0时DI++，当DF==1时DI–</li></ul><p>设要把从地址1000:10A0开始共100h个字节内存单元全部填0<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">1000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span><span class="comment">; ES=1000h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>, <span class="number">10A0h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">100h</span></span><br><span class="line"><span class="keyword">cld</span></span><br><span class="line"><span class="keyword">xor</span> <span class="built_in">al</span>, <span class="built_in">al</span></span><br><span class="line"><span class="keyword">rep</span> <span class="keyword">stosb</span></span><br></pre></td></tr></table></figure></p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="LODSB"> LODSB <code>从字符串取字节或字</code> </h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lodsb</span></span><br></pre></td></tr></table></figure><p>AL = DS : [SI],  SI++</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><hr><h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><h3 id="JMP"> JMP </h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[√] <span class="keyword">jmp</span> <span class="number">0108h</span></span><br><span class="line">[√] <span class="keyword">jmp</span> <span class="number">1234h</span>:<span class="number">5678h</span></span><br><span class="line">[√] <span class="keyword">jmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">10F0h</span>]</span><br></pre></td></tr></table></figure><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="LOOP"> LOOP </h3><p>CX-1</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p><h3 id="CAL"> CALL，RETN，RETF <code>子程序调用与返回</code> </h3><p>retn表示近返回，可简写成ret;<br>retf表示远返回。<br>call既可以表示近调用，也可以表示远调用<br>retn [count]  ; <code>count</code>多出步骤：SP = SP + count</p><p><strong>堆栈传递</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">f:</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bp</span>, <span class="built_in">sp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="number">4</span>]<span class="comment">; 从堆栈中取得参数</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ax</span>, <span class="built_in">ax</span></span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">   <span class="keyword">ret</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">3</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ax</span><span class="comment">; 参数压入到堆栈</span></span><br><span class="line">   <span class="keyword">call</span> f</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">sp</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>C语言函数调用y=f(2,3)求两数之和转化成汇编语言<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">f:</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">bp</span><span class="comment">;(4)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bp</span>, <span class="built_in">sp</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="number">4</span>]</span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="number">6</span>]</span><br><span class="line">   <span class="keyword">pop</span> <span class="built_in">bp</span><span class="comment">; (5)</span></span><br><span class="line">   <span class="keyword">ret</span><span class="comment">; (6)</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">3</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ax</span><span class="comment">; (1)</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">2</span></span><br><span class="line">   <span class="keyword">push</span> <span class="built_in">ax</span><span class="comment">; (2)</span></span><br><span class="line">   <span class="keyword">call</span> f<span class="comment">; (3)</span></span><br><span class="line"><span class="symbol">here:</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">sp</span>, <span class="number">4</span><span class="comment">;(7)</span></span><br></pre></td></tr></table></figure></p><p>上述程序运行过程中的堆栈布局如下:</p><blockquote><p>ss:1FF8 old bp &lt;- bp (4)<br>ss:1FFA here &lt;- (3)(5)<br>ss:1FFC 02   &lt;- (2)(6)<br>ss:1FFE 03   &lt;- (1)<br>ss:2000 ??   &lt;- (7)</p></blockquote><p>cx/dx可以随便用<br>ax一般用作返回值</p><p><i class="fa fa-arrow-circle-up"></i>&ensp;<a href="#content"><code>回到目录</code></a></p>]]></content>
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asm </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <content type="html"><![CDATA[<h2 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h2><p>浙江大学2015级生物科学专业，辅修竺可桢学院创新与创业管理强化班（ITP）。<br>（有空了慢慢写吧！）</p><table><thead><tr><th>技能</th><th>水平</th><th>备注</th></tr></thead><tbody><tr><td>Python</td><td><i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle-o"></i></td><td>个人首要编程语言，较熟练，写过爬虫、服务器等程序和部件。</td></tr><tr><td>C4D</td><td><i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle"></i>&nbsp;<i class="fa fa-circle-o"></i>&nbsp;<i class="fa fa-circle-o"></i></td><td>建模渲染和简单动画，做过一些作品。</td></tr></tbody></table><p><br></p><p><strong>爱好</strong></p><ul><li>漫威忠实粉丝</li><li>科幻电影和谍战片（007/星际穿越）</li></ul><p><br></p><p><strong>个人公众号</strong></p><p><img src="/images/000.png" alt="file-list"></p><p><br></p><hr><p><span id="env"></span><br><br></p><h2 id="我使用的环境和工具"><a href="#我使用的环境和工具" class="headerlink" title="我使用的环境和工具"></a>我使用的环境和工具</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python_3.6.4_x64<br><strong>主要的包</strong></p><table><thead><tr><th>名称</th><th>版本</th><th>备注</th></tr></thead><tbody><tr><td>pip</td><td>9.0.1</td><td></td></tr><tr><td>wheel</td><td>0.30.0</td><td></td></tr><tr><td>beautifulsoup4</td><td>4.6.0</td><td></td></tr><tr><td>django</td><td>2.0.3</td><td></td></tr><tr><td>matplotlib</td><td>2.1.2</td><td></td></tr><tr><td>numpy</td><td>1.14.0</td><td></td></tr><tr><td>opencv-python</td><td>3.4.0.12</td><td></td></tr><tr><td>pandas</td><td>0.22.0</td><td></td></tr><tr><td>pyperclip</td><td>1.6.0</td><td></td></tr><tr><td>requests</td><td>2.18.4</td><td></td></tr><tr><td>scikit-learn</td><td>0.19.1</td><td></td></tr><tr><td>scipy</td><td>1.0.0</td></tr></tbody></table><hr><p><br></p><h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><p>&emsp;<i class="fa fa-wechat"></i>&emsp;John_Theo<br>&emsp;<i class="fa fa-qq"></i>&emsp;905176554（不常用）<br>&emsp;<i class="fa fa-envelope"></i>&emsp;<a href="mailto:B_W_Ghost@163.com" target="_blank" rel="noopener">B_W_Ghost@163.com</a> / <a href="mailto:John_Theo@foxmail.com" target="_blank" rel="noopener">John_Theo@foxmail.com</a><br>&emsp;<i class="fa fa-linkedin-square"></i>&emsp;<a href="www.linkedin.com/in/庄心昊-johntheo">领英首页</a><br>&emsp;<i class="fa fa-cloud"></i>&emsp;<a href="https://pan.baidu.com/s/1DSjHOjyeyFg_3yUgalpYCQ" target="_blank" rel="noopener">在线作品集</a>（提取码：4rc2）</p>]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
